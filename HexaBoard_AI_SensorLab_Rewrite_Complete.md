---
title: "HexaBoard AI Sensor Lab"
subtitle: "ESP32 기반 AIoT 시스템 개발 완벽 가이드"
author: "AIoT eBook Team"
date: "2025-12-15"
version: "2.0 (Rewrite Edition)"
---

# HexaBoard AI Sensor Lab

## ESP32 기반 AIoT 시스템 개발 완벽 가이드

**Version 2.0 - Rewrite Edition**

---

## 이 책에 대하여

이 책은 **헥사보드(HexaBoard)**라는 ESP32 기반 개발 보드를 사용하여 AIoT(AI + IoT) 시스템을 처음부터 끝까지 만드는 방법을 다룹니다.

단순한 기술 매뉴얼이 아닌, **스토리텔링 방식**의 전자책으로 초보자도 쉽게 따라할 수 있도록 구성했습니다.

### 무엇을 배우나요?

- **하드웨어 제어**: 버튼, LED, 센서
- **센서 데이터**: 온도, 습도, 빛 측정
- **무선 통신**: Wi-Fi, MQTT
- **인공지능**: OpenAI API 연동
- **웹 대시보드**: 실시간 모니터링
- **자동 제어**: AI 기반 의사결정

### 누구를 위한 책인가요?

- 🎓 IoT를 처음 시작하는 학생
- 👨‍🏫 IoT 교육을 준비하는 교사
- 💻 취미로 프로젝트를 만들고 싶은 메이커
- 🏢 AIoT 시스템을 이해하고 싶은 실무자

### 필요한 것

- **하드웨어**: 헥사보드 (ESP32), 센서 모듈
- **소프트웨어**: Thonny IDE, Python 3.x
- **지식**: 기초적인 프로그래밍 경험 (권장)

---

## 목차

### PART 1: AI 센서랩과 헥사보드 이해하기
- Chapter 1: HexaBoard AI Sensor Lab 소개
- Chapter 2: 헥사보드 구조 이해하기
- Chapter 3: 개발 환경 준비하기

### PART 2: 헥사보드 기본 제어 – 버튼과 네오픽셀
- Chapter 4: 디지털 입력의 기본 – 버튼 2개 다루기
- Chapter 5: 네오픽셀 기초 – 빛의 마법 시작하기
- Chapter 6: 상태 머신: 인터랙티브 시스템의 핵심

### PART 3: 센서로 세상을 읽다 – 온습도와 빛
- Chapter 7: DHT11 온습도 센서: 보이지 않는 것을 측정하기
- Chapter 8: 조도 센서: 빛의 밝기를 숫자로
- Chapter 9: 센서 데이터 처리: 원석을 보석으로
- Chapter 10: 데이터 시각화: 숫자를 그림으로

### PART 4: MQTT를 통한 센서 데이터 전송
- Chapter 11: MQTT: IoT의 언어
- Chapter 12: HiveMQ Cloud: 무료 클라우드 Broker 설정
- Chapter 13: 헥사보드 MQTT 구현
- Chapter 14: 멀티 헥사보드 시스템

### PART 5: Python + AI로 센서 데이터 분석 및 자동 제어
- Chapter 15: Python으로 MQTT 데이터 받기
- Chapter 16: 센서 데이터 요약 및 해석
- Chapter 17: OpenAI API 연동: AI의 힘 빌리기
- Chapter 18: AI 응답을 제어 명령으로 변환
- Chapter 19: 전체 시스템 통합: AI 기반 자동 제어

### PART 6: 실전 프로젝트 – AI 환경 무드 컨트롤러 만들기
- Chapter 20: 프로젝트: AI 환경 무드 컨트롤러
- Chapter 21: 시스템 아키텍처 설계
- Chapter 22: 단계별 구현
- Chapter 23: AI 프롬프트 튜닝 및 실험

### PART 7: 웹 대시보드로 모니터링과 제어
- Chapter 24: 웹 기반 센서 모니터링
- Chapter 25: 웹 기반 수동 LED 제어
- Chapter 26: 웹 기반 자연어 AI 제어

### PART 8: 교육 현장에서 활용하기
- Chapter 27: 교육 커리큘럼 설계 가이드
- Chapter 28: 미션 기반 실습 과제 및 평가
- Chapter 29: 확장 아이디어 및 다음 단계

---

## 저자 소개

이 책은 IoT와 AI 교육에 열정을 가진 메이커들이 함께 만들었습니다.

**연락처**: [이메일 또는 웹사이트]

---

## 라이선스

이 전자책은 교육 목적으로 자유롭게 사용할 수 있습니다.

---

**Happy Making! 🚀**

---


# PART 1: AI 센서랩과 헥사보드 이해하기

# Chapter 1. AI 센서랩이란 무엇인가

> **PART 1**: AI 센서랩과 헥사보드 이해하기

---

## 여정의 시작

여러분은 지금 특별한 여정을 시작하려고 합니다. 작은 LED 하나를 켜는 것에서 시작해서, 인공지능이 주변 환경을 이해하고 스스로 판단하여 제어하는 완전한 시스템을 만들게 될 것입니다. 마치 SF 영화에서나 보던 스마트 홈을 직접 구축하는 것이죠.

이 챕터에서는 우리가 앞으로 만들게 될 "AI 센서랩"이 무엇인지, 그리고 왜 이것이 중요한지 알아보겠습니다. 전문 용어들이 낯설게 느껴질 수 있지만, 걱정하지 마세요. 하나하나 차근차근 설명해드리겠습니다.

**이 챕터를 마치면**:

- AI 센서랩의 개념을 완전히 이해하게 됩니다
- IoT와 AIoT의 차이를 명확히 알게 됩니다
- 앞으로 만들 프로젝트의 전체 그림을 그릴 수 있습니다

**예상 소요 시간**: 편안히 앉아서 20분

---

## 사물인터넷의 진화: IoT에서 AIoT로

### IoT, 모든 것이 연결되는 세상

"사물인터넷", 영어로는 Internet of Things, 줄여서 **IoT**라고 부릅니다. 이름만 들어도 조금은 낯익지 않나요? 요즘 스마트 홈, 웨어러블 기기, 자동차의 블랙박스까지 우리 주변 곳곳에서 IoT 기술을 만날 수 있습니다.

IoT의 핵심은 간단합니다: **센서로 정보를 수집하고, 네트워크로 전송하고, 규칙에 따라 무언가를 제어**하는 것이죠.

예를 들어 볼까요? 여러분이 스마트 온도계를 만든다고 가정해봅시다.

```
1. 온도 센서가 현재 온도를 측정합니다 (예: 32°C)
2. 측정된 데이터를 서버로 전송합니다
3. 서버는 미리 정해진 규칙을 확인합니다
   → "온도가 30°C 이상이면 에어컨 켜기"
4. 에어컨에 제어 신호를 보냅니다
```

깔끔하고 명확하죠? 그런데 여기에는 큰 문제가 있습니다.

### IoT의 한계

아침 7시, 여러분이 잠에서 깹니다. 실내 온도는 26°C입니다. 겨울이라면 따뜻하고 좋은 온도지만, 한여름이라면 이미 더운 온도죠. 하지만 전통적인 IoT 시스템은 이런 맥락을 이해하지 못합니다. 단지 "26°C = 에어컨 끄기"라는 규칙만 따를 뿐입니다.

더 복잡한 상황을 생각해볼까요?

- 습도가 높은 날의 28°C와 건조한 날의 28°C는 체감이 완전히 다릅니다
- 낮에 밝을 때의 적정 온도와 밤에 자려고 할 때의 적정 온도가 다릅니다
- 운동을 하고 막 돌아왔을 때와 조용히 독서를 할 때 원하는 환경이 다릅니다

이 모든 경우의 수를 규칙으로 만든다면? 수백, 수천 개의 IF-THEN 규칙이 필요할 겁니다. 그리고 새로운 상황이 생길 때마다 규칙을 추가해야 하죠. 이게 과연 "스마트"한 걸까요?

더 큰 문제는 사용자와의 소통 방식입니다. "에어컨 켜줘", "좀 시원하게 해줘", "자려고 하는데 환경 좀 맞춰줘" 같은 자연스러운 명령을 이해하지 못합니다. 스위치를 누르거나, 앱에서 정확한 온도를 설정해야만 하죠.

### AIoT, 인공지능이 더해진 사물인터넷

이제 **AIoT**의 등장입니다. AI(인공지능)와 IoT(사물인터넷)의 합성어인 AIoT는 말 그대로 인공지능이 더해진 사물인터넷입니다.

AIoT 시스템은 단순히 규칙을 따르는 것이 아니라, **상황을 이해하고 판단**합니다.

```
1. 센서가 현재 상황을 측정합니다
   → 온도 32°C, 습도 75%, 시간 오후 2시, 밝기 밝음

2. 수집된 데이터를 AI에게 전달합니다

3. AI가 데이터를 분석하고 맥락을 이해합니다
   → "한여름 오후, 높은 온도에 높은 습도까지...
      불쾌지수가 높은 상황이군요"

4. AI가 적절한 조치를 결정합니다
   → "제습 모드로 온도를 27°C로 낮추는 게 좋겠습니다"

5. 사용자에게 알리거나 자동으로 실행합니다
```

더 놀라운 건 자연어 이해 능력입니다.

사용자: "너무 덥고 불쾌해요"  
AI: "현재 불쾌지수가 높습니다. 제습 모드로 전환하고 온도를 낮추겠습니다."

사용자: "자려고 하는데 환경 좀 맞춰줘"  
AI: "수면에 적합한 환경으로 설정합니다. 온도 24°C, 조명 10% 밝기로 조절하겠습니다."

이것이 바로 AIoT의 힘입니다. 규칙을 벗어나 진짜로 "생각"하는 것처럼 작동하는 시스템이죠.

---

## AI 센서랩: 여러분만의 AIoT 실험실

### 우리가 만들 것

이 책에서 우리는 **AI 센서랩**을 만들 것입니다. 센서랩이란 센서를 활용한 실험실이라는 뜻이죠. 여러분의 책상 위, 또는 방 한구석이 첨단 AIoT 연구소가 되는 겁니다.

핵심 구성 요소는 다음과 같습니다:

**1. 헥사보드 (HexaBoard)**

- ESP32라는 강력한 마이크로컨트롤러 기반
- 5×5 그리드의 화려한 LED (네오픽셀)
- 2개의 버튼으로 입력 가능
- Wi-Fi로 인터넷에 연결

**2. 센서들**

- DHT11 온습도 센서: 주변의 온도와 습도를 측정
- 조도 센서: 밝기를 감지

**3. MQTT 통신**

- 센서 데이터를 실시간으로 전송하는 가벼운 프로토콜
- HiveMQ라는 무료 클라우드 서비스 활용

**4. Python AI 서버**

- 데이터를 받아서 처리하는 중앙 서버
- OpenAI의 GPT 모델을 활용해 지능적으로 판단

**5. 웹 대시보드**

- 브라우저에서 실시간 데이터 확인
- 클릭 한 번으로 제어
- 자연어로 명령 가능

### 전체 데이터 흐름

우리 시스템의 데이터가 어떻게 흐르는지 큰 그림을 그려봅시다:

```
┌─────────────────────────────────┐
│  헥사보드 (여러분의 책상 위)      │
│  • 온도, 습도, 밝기 측정         │
│  • LED로 상태 표시               │
│  • 버튼으로 수동 제어            │
└────────────┬────────────────────┘
             │
             │ Wi-Fi + MQTT
             │ (센서 데이터 전송)
             ↓
┌─────────────────────────────────┐
│  클라우드 MQTT Broker            │
│  (HiveMQ - 메시지 중개소)        │
└────────────┬────────────────────┘
             │
             │ 데이터 구독
             ↓
┌─────────────────────────────────┐
│  Python AI 서버 (여러분의 PC)    │
│  • 센서 데이터 수집 및 분석      │
│  • OpenAI로 상황 판단            │
│  • 제어 명령 생성                │
└────────────┬────────────────────┘
             │
             │ 제어 명령 발행
             ↓
┌─────────────────────────────────┐
│  클라우드 MQTT Broker            │
└────────────┬────────────────────┘
             │
             │ 명령 수신
             ↓
┌─────────────────────────────────┐
│  헥사보드 (LED 제어 실행)        │
└─────────────────────────────────┘

        동시에 ↔︎

┌─────────────────────────────────┐
│  웹 대시보드 (브라우저)          │
│  • 실시간 센서 모니터링          │
│  • 그래프로 변화 추이 확인       │
│  • 수동/AI 제어                  │
└─────────────────────────────────┘
```

처음 보면 복잡해 보이지만, 각 부분을 차근차근 만들어가다 보면 자연스럽게 이해가 될 것입니다.

---

## 우리가 완성할 최종 프로젝트

### AI 환경 무드 컨트롤러

29개 챕터를 모두 마치면, 여러분은 **AI 환경 무드 컨트롤러**라는 완성된 시스템을 갖게 됩니다. 멋진 이름이죠?

이 시스템의 핵심 기능을 살펴봅시다:

**기능 1: 실시간 환경 감지**

헥사보드에 연결된 센서들이 쉬지 않고 주변 환경을 측정합니다. 온도는 어떤지, 습도는 쾌적한지, 방이 너무 어둡거나 밝지는 않은지. 마치 여러분의 방을 지키는 작은 기상 관측소 같습니다.

센서는 5초마다 데이터를 수집하고, MQTT를 통해 클라우드로 전송합니다. 실시간으로요!

**기능 2: AI 기반 상황 분석**

Python 서버가 데이터를 받으면, OpenAI의 GPT 모델에게 물어봅니다.

"지금 온도는 28°C이고 습도는 70%인데, 이 환경은 어떤가요?"

GPT는 방대한 학습 데이터를 바탕으로 대답합니다:

"온도와 습도가 모두 높아 불쾌지수가 높은 상황입니다. 제습과 냉방이 필요한 'Hot & Humid' 무드입니다."

단순히 "덥다"고 판단하는 게 아니라, 온도와 습도의 조합, 계절, 시간대 등을 종합적으로 고려하는 것이죠.

**기능 3: 자동 LED 무드 표시**

AI가 판단한 환경 상태를 5×5 LED 그리드로 시각적으로 표현합니다:

- **🟢 Perfect**: 완벽한 환경 (초록색, 부드러운 빛)
- **🟡 Good**: 쾌적한 환경 (노란색)
- **🔴 Hot**: 너무 더운 환경 (빨간색, 깜빡임)
- **🔵 Cold**: 추운 환경 (파란색, 깜빡임)
- **🟣 Humid**: 습한 환경 (보라색, 펄스)

방에 들어서는 순간 LED 색깔만 봐도 지금 환경이 어떤지 직관적으로 알 수 있습니다.

**기능 4: 웹 대시보드로 모든 것을 한눈에**

스마트폰이나 컴퓨터에서 브라우저를 열면, 실시간 대시보드가 펼쳐집니다:

- 큰 숫자로 표시되는 현재 온도, 습도, 밝기
- 시간에 따른 변화를 보여주는 그래프
- 지금 무드 상태와 AI의 추천 사항
- 클릭 한 번으로 LED 색상과 패턴 변경

더 놀라운 건, 자연어 입력 기능입니다:

입력창에 "좀 시원하게 해줘"라고 타이핑하면, AI가 이해하고 적절한 LED 색상(파란색)과 패턴으로 변경합니다. 마치 스마트 스피커처럼요!

**기능 5: 학습과 확장**

이 프로젝트의 진짜 가치는 여기서 끝나지 않습니다.

기본 시스템을 완성한 후에는:

- 더 많은 센서 추가 (공기질, 소음, 움직임)
- 패턴 학습 (여러분의 선호도를 기억)
- 여러 방의 환경을 동시에 모니터링
- 실제 가전제품 제어 (릴레이 모듈 추가)
- 음성 명령 통합

등등 무한한 확장이 가능합니다. 이 책은 시작점일 뿐, 여러분의 상상력이 더해지면 훨씬 더 멋진 시스템이 탄생할 것입니다.

---

## 학습 로드맵: 29개 챕터의 여정

이제 앞으로의 여정을 간단히 살펴봅시다. 29개 챕터가 많아 보이지만, 각 챕터는 하나의 작은 성취입니다. 작은 성공을 쌓다 보면 어느새 완전한 시스템이 완성되어 있을 것입니다.

### PART 1-2: 첫 걸음 (약 4시간)

가장 기초부터 시작합니다. 헥사보드가 무엇인지, 어떻게 연결하는지, 버튼을 누르면 LED가 켜지게 하려면 어떻게 해야 하는지.

프로그래밍이 처음이라도 괜찮습니다. 모든 코드를 한 줄 한 줄 설명하니까요. 이 파트를 마치면 여러분은 LED 25개를 마음대로 제어할 수 있게 됩니다. 색깔도, 패턴도, 밝기도!

### PART 3: 세상을 감지하기 (약 3시간)

이제 센서를 연결합니다. 온도와 습도를 측정하는 DHT11 센서, 밝기를 감지하는 조도 센서.

처음으로 "입력"을 받는 거죠. 버튼은 여러분이 직접 눌러야 하지만, 센서는 자동으로 주변 환경을 측정합니다. 이 데이터를 LED로 시각화하면, 여러분만의 환경 모니터가 완성됩니다.

### PART 4: 세상과 연결하기 (약 3.5시간)

센서 데이터를 헥사보드 안에만 두면 아쉽죠. 인터넷으로 전송해봅시다!

MQTT라는 프로토콜을 배웁니다. 복잡해 보이지만 실제로는 매우 간단합니다. 무료 클라우드 서비스(HiveMQ)를 사용해서 몇 줄의 코드만으로 데이터를 전송할 수 있습니다.

이 파트를 마치면, 여러분의 헥사보드는 진짜 "사물인터넷" 장치가 됩니다.

### PART 5: 인공지능 추가하기 (약 4시간)

드디어 AI의 등장입니다!

Python 서버를 만들어서 센서 데이터를 받고, OpenAI의 GPT 모델로 분석합니다. "이 환경은 쾌적한가?", "어떤 조치가 필요한가?" 같은 질문에 AI가 답하도록 만듭니다.

이 파트가 조금 어려울 수 있습니다. 하지만 "빠른 시작" 가이드도 준비되어 있으니, 핵심만 빠르게 구현할 수도 있습니다.

### PART 6: 모든 것을 하나로 (약 3.5시간)

지금까지 배운 모든 것을 하나의 완전한 프로젝트로 통합합니다.

센서 → MQTT → AI → 제어, 이 전체 파이프라인이 자동으로 돌아가게 만듭니다. 시스템 설계, 구현, 테스트, 튜닝까지. 진짜 프로젝트를 만드는 전 과정을 경험합니다.

### PART 7: 웹의 힘 (약 1.5시간)

이제 웹 인터페이스를 추가합니다.

HTML과 JavaScript로 대시보드를 만들고, Tailwind CSS로 예쁘게 꾸밉니다. 서버 없이도 브라우저에서 직접 MQTT에 연결할 수 있다는 게 놀랍습니다.

자연어 입력 기능까지 추가하면, 완전한 AIoT 시스템의 완성입니다!

### PART 8: 그 다음은? (약 0.5시간)

마지막 파트는 앞으로의 방향을 제시합니다.

교육 커리큘럼을 어떻게 만들지, 미션 기반 학습은 어떻게 설계하는지, 어떤 확장 아이디어가 있는지.

이 책이 끝이 아니라 새로운 시작임을 알게 될 것입니다.

---

## 필요한 준비물과 마음가짐

### 하드웨어 (필수)

- **헥사보드**: ESP32 기반 개발 보드 (5×5 LED, 버튼 포함)
- **DHT11 센서 모듈**: 온습도 측정 (빌트인 저항 포함)
- **조도 센서 모듈**: 밝기 측정 (빌트인 저항 포함)
- **3핀 케이블**: 센서 연결용 × 2개
- **USB 케이블**: 헥사보드를 컴퓨터에 연결

총 비용은 5~7만원 정도입니다. 한 번 구입하면 이 책뿐만 아니라 다른 수많은 프로젝트에도 사용할 수 있습니다.

### 소프트웨어 (무료)

- **Thonny IDE**: MicroPython 개발 환경 (초보자 친화적)
- **Python 3.10+**: AI 서버용
- **웹 브라우저**: Chrome, Firefox, Safari 등 아무거나
- **HiveMQ Cloud**: 무료 MQTT 클라우드 (회원가입 필요)
- **OpenAI API**: 선택사항 (무료 크레딧으로 시작 가능)

모두 무료이거나 무료로 시작할 수 있습니다. OpenAI API는 테스트 단계에서는 비용이 거의 들지 않습니다.

### 사전 지식 (있으면 좋지만 필수는 아님)

- **Python 기초**: 변수, 함수, if문 정도
- **HTML 기초**: 태그 구조 이해

프로그래밍이 처음이라고요? 괜찮습니다! 이 책은 모든 코드를 자세히 설명합니다. 복사 붙여넣기만 해도 작동하지만, 이해하면서 따라하면 훨씬 더 많이 배울 수 있습니다.

### 가장 중요한 것: 호기심과 끈기

기술적인 지식보다 더 중요한 건 이 두 가지입니다:

**호기심**: "이게 왜 이렇게 작동하지?", "저기에 저 센서를 추가하면 어떻게 될까?" 같은 질문들. 궁금증이 학습의 가장 큰 동력입니다.

**끈기**: 코드가 작동하지 않을 때, 센서가 이상한 값을 출력할 때, 오류 메시지를 마주할 때. 포기하지 않는 것. 디버깅 과정에서 가장 많이 배웁니다.

---

## 시작하기 전에: 학습 팁

### 1. 직접 타이핑하세요

코드를 복사 붙여넣기하는 것보다 직접 타이핑하는 게 훨씬 좋습니다. 손이 기억합니다. 타이핑하다가 오타를 내고, 그걸 고치는 과정에서 코드가 어떻게 작동하는지 더 깊이 이해하게 됩니다.

### 2. 실험하세요

책에 나온 코드가 작동하면, 거기서 멈추지 마세요. 숫자를 바꿔보고, 순서를 바꿔보고, 새로운 기능을 추가해보세요. "이렇게 하면 어떻게 될까?"라는 질문이 최고의 학습 방법입니다.

### 3. 오류를 두려워하지 마세요

"Error", "Exception", "Failed" 같은 메시지들. 처음에는 무섭지만, 이것들은 여러분의 적이 아닙니다. 오히려 무엇이 잘못되었는지 알려주는 친절한 안내자입니다.

오류 메시지를 읽는 법을 배우면, 디버깅은 퍼즐을 푸는 것처럼 재미있어집니다.

### 4. 작은 성공을 축하하세요

LED 하나가 켜졌을 때, 센서값이 처음 출력되었을 때, MQTT 연결이 성공했을 때. 이런 작은 성공들을 축하하세요.

"겨우 이것밖에 못했네"가 아니라 "이걸 해냈어!"라고 생각하세요. 작은 성공들이 모여서 큰 프로젝트가 완성됩니다.

### 5. 커뮤니티를 활용하세요

막혔을 때 혼자 끙끙대지 마세요. 구글에 오류 메시지를 검색하고, MicroPython 포럼에 질문하고, GitHub Issues에 도움을 요청하세요.

대부분의 문제는 이미 누군가가 겪었고 해결했습니다. 그 지혜를 활용하세요.

---

## 이 책을 최대한 활용하는 법

### 순서대로 따라가기

챕터들은 순서가 있습니다. 뒤로 건너뛰고 싶은 마음이 들어도, 처음부터 차근차근 따라가는 게 좋습니다. 각 챕터는 이전 챕터의 지식을 바탕으로 만들어졌으니까요.

### 실습 위주로

이론을 읽는 것도 중요하지만, 이 책의 진짜 가치는 "직접 해보는 것"에 있습니다. 설명을 읽었으면 바로 코드를 작성하고 실행해보세요.

### 노트 작성

중요한 개념이나 자주 쓰는 코드 패턴을 따로 정리해두세요. 나중에 여러분만의 프로젝트를 만들 때 큰 도움이 됩니다.

### 쉬어가기

한 번에 너무 많이 하려고 하지 마세요. 하루에 1~2챕터 정도가 적당합니다. 뇌가 새로운 지식을 소화할 시간을 주세요.

---

## 여정의 시작

자, 이제 준비가 되었나요?

다음 챕터부터는 본격적으로 헥사보드를 만나고, 첫 프로그램을 작성하고, LED를 켜보게 됩니다. 작은 시작이지만, 이것이 완전한 AIoT 시스템으로 가는 첫 걸음입니다.

기억하세요: 여러분은 혼자가 아닙니다. 이 책이 옆에서 계속 안내할 것이고, 전 세계 수많은 메이커들이 같은 여정을 걷고 있습니다.

**"시작이 반이다"**라는 말이 있죠. 여러분은 이미 이 책을 열었고, 첫 챕터를 읽고 있습니다. 반은 이미 온 셈입니다!

그럼, 다음 챕터에서 헥사보드를 자세히 만나봅시다.

**즐거운 메이킹 되세요! 🚀**

---

**💡 핵심 요약**

- **IoT**: 센서로 측정하고 규칙으로 제어하는 사물인터넷
- **AIoT**: AI가 상황을 이해하고 판단하는 지능형 사물인터넷
- **AI 센서랩**: 헥사보드, 센서, AI를 결합한 우리만의 실험실
- **최종 목표**: 환경을 감지하고 AI로 분석하여 자동 제어하는 완전한 시스템
- **학습 방식**: 작은 단계들을 쌓아가며 29챕터 동안 점진적으로 완성

**다음 챕터 예고**: 헥사보드의 구조를 상세히 살펴보고, 각 부품이 무엇인지 알아봅니다.

---

# Chapter 2. 헥사보드 구조 한눈에 보기

> **PART 1**: AI 센서랩과 헥사보드 이해하기

---

## 여러분의 새로운 파트너를 만나보세요

컴퓨터나 스마트폰은 강력하지만, 주변 세계와 직접 소통하기는 어렵습니다. 온도를 느끼지 못하고, LED를 켜지 못하고, 버튼을 누르는 것도 감지하지 못하죠. 그래서 우리에게는 **헥사보드**가 필요합니다.

헥사보드는 단순한 전자 보드가 아닙니다. 이것은 여러분의 아이디어를 현실로 만들어줄 든든한 파트너이자, 센서로 세상을 감지하고 LED로 표현하며, Wi-Fi로 인터넷과 소통하는 작은 컴퓨터입니다.

이 챕터에서는 헥사보드의 모든 부품을 하나하나 살펴보고, 각각이 어떤 마법을 부릴 수 있는지 알아보겠습니다. 부품들의 이름과 핀 번호를 외울 필요는 없습니다. 이 챕터는 여러분의 파트너를 처음 만나는 시간입니다. 천천히, 편하게 알아가면 됩니다.

**이 챕터를 마치면**:

- 헥사보드의 모든 주요 부품과 그 역할을 이해하게 됩니다
- GPIO 핀 번호가 무엇이고 왜 중요한지 알게 됩니다
- 헥사보드를 컴퓨터에 연결하고 인식시킬 수 있습니다

**예상 소요 시간**: 편안히 읽으면서 20분

---

## ESP32: 헥사보드의 두뇌

### 작지만 강력한 마이크로컨트롤러

헥사보드의 심장부에는 **ESP32**라는 마이크로컨트롤러가 있습니다. 마이크로컨트롤러라는 이름이 어렵게 들리지만, 쉽게 말해 "아주 작은 컴퓨터"라고 생각하면 됩니다.

컴퓨터나 스마트폰처럼 복잡한 프로그램을 실행하거나 유튜브를 보는 건 불가능하지만, 대신 센서를 읽고, LED를 제어하고, 네트워크로 데이터를 주고받는 일에는 완벽합니다. 그리고 전력도 매우 적게 사용하죠.

### ESP32가 특별한 이유

ESP32는 2016년 중국의 Espressif Systems라는 회사에서 만들었습니다. 이 작은 칩이 IoT 세계에 혁명을 일으켰는데요, 그 이유는:

**1. Wi-Fi와 블루투스가 내장되어 있습니다**

아두이노 같은 전통적인 보드는 Wi-Fi를 사용하려면 별도의 모듈을 추가로 사야 했습니다. 비용도 더 들고, 연결도 복잡하죠. 하지만 ESP32는 처음부터 Wi-Fi가 들어있습니다. 그냥 코드만 작성하면 바로 인터넷에 연결할 수 있어요!

블루투스도 마찬가지입니다. 스마트폰과 직접 통신하거나, 블루투스 이어폰을 제어하는 것도 가능합니다.

**2. 강력한 성능**

- **듀얼 코어**: 두 개의 프로세서가 동시에 작동합니다. 하나는 센서를 읽고, 다른 하나는 네트워크 통신을 하는 식으로 멀티태스킹이 가능합니다.
- **240 MHz 클럭**: 아두이노의 16 MHz와 비교하면 무려 15배 빠릅니다!
- **520 KB RAM**: 복잡한 데이터 처리도 거뜬합니다.

**3. 저전력 설계**

배터리로 몇 주 동안 작동할 수 있을 만큼 전력 소비가 적습니다. 센서 노드를 멀리 떨어진 곳에 설치하는 IoT 프로젝트에 완벽하죠.

**4. 가격이 저렴합니다**

이 모든 기능을 가진 ESP32가 단돈 몇 천원입니다. 이 때문에 전 세계 메이커들이 ESP32를 사랑합니다.

**5. MicroPython 지원**

C/C++로만 프로그래밍해야 하는 다른 보드와 달리, ESP32는 **MicroPython**을 지원합니다. Python처럼 쉬운 언어로 하드웨어를 제어할 수 있다는 뜻이죠. 초보자에게는 엄청난 장점입니다.

### 헥사보드 = ESP32 + α

헥사보드는 ESP32를 기반으로, 여기에 우리가 바로 사용할 수 있는 부품들을 추가한 "올인원" 보드입니다:

- 5×5 네오픽셀 LED (화려한 출력)
- 2개의 버튼 (간단한 입력)
- 자이로 센서 (움직임 감지)
- 컬러 센서 (색상 인식)
- 외부 센서 연결 핀 (확장성)

ESP32 칩을 직접 사용하려면 브레드보드에 복잡하게 연결해야 하지만, 헥사보드는 USB만 꽂으면 바로 사용할 수 있습니다. 교육용으로 완벽하게 설계된 것이죠.

---

## 네오픽셀: 25개의 작은 캔버스

### 빛으로 그리는 그림

헥사보드의 중앙을 차지하는 5×5 그리드의 LED, 이것이 바로 **네오픽셀(NeoPixel)**입니다. 단순한 LED가 아닙니다. 각각이 독립적인 RGB LED로, 1,600만 가지 색상을 표현할 수 있습니다.

### 왜 네오픽셀이라고 부를까요?

네오픽셀은 사실 Adafruit라는 회사의 상표명입니다. 정식 이름은 **WS2812B**라는 스마트 LED 칩인데, 네오픽셀이라는 이름이 더 유명해졌죠.

일반 LED와의 결정적 차이는 이겁니다: **각 LED 안에 작은 컨트롤러가 들어있습니다**.

일반 LED를 25개 제어하려면 25개의 선이 필요하지만, 네오픽셀은 단 하나의 선으로 25개를 모두 제어할 수 있습니다. 마법 같죠? 이게 가능한 이유는 LED들이 체인처럼 연결되어 있고, 각자 자신의 순서를 알고 있기 때문입니다.

### 헥사보드의 네오픽셀 배치

```
LED 번호 (0부터 시작):

행 0:  [0]  [1]  [2]  [3]  [4]
행 1:  [5]  [6]  [7]  [8]  [9]
행 2:  [10] [11] [12] [13] [14]
행 3:  [15] [16] [17] [18] [19]
행 4:  [20] [21] [22] [23] [24]
```

0번이 첫 번째 LED이고, 24번이 마지막입니다. 데이터는 0번부터 시작해서 순서대로 전달됩니다.

### 네오픽셀로 할 수 있는 것들

**1. 센서 데이터 시각화**

온도가 올라가면 LED가 파란색에서 빨간색으로 변하는 온도계를 만들 수 있습니다. 숫자로 보는 것보다 훨씬 직관적이죠.

```python
# 온도에 따른 색상 예시
temp = 25  # 섭씨 온도

if temp < 20:
    color = (0, 0, 255)  # 파란색 (추움)
elif temp < 30:
    color = (0, 255, 0)  # 초록색 (쾌적)
else:
    color = (255, 0, 0)  # 빨간색 (더움)
```

**2. 상태 표시**

시스템의 상태를 색깔로 알려줄 수 있습니다:

- 초록색: 정상 작동
- 노란색: 주의 필요
- 빨간색: 오류 발생
- 파란색: 데이터 수신 중
- 보라색: AI가 분석 중

**3. 애니메이션과 패턴**

무지개 효과, 흐르는 물결, 깜빡이는 별, 회전하는 패턴... 상상하는 모든 것을 표현할 수 있습니다.

**4. 게임**

간단한 게임을 만들 수도 있습니다. LED가 무작위로 켜지면 빠르게 버튼을 누르는 반응속도 게임, 또는 뱀 게임, 테트리스까지!

**5. 알림**

새로운 이메일이 왔을 때, 날씨가 변할 때, 약 먹을 시간이 됐을 때... LED가 깜빡이며 알려줄 수 있습니다.

### 네오픽셀의 연결: GPIO 23번

헥사보드에서 네오픽셀은 **GPIO 23번** 핀에 연결되어 있습니다. GPIO는 "General Purpose Input/Output"의 약자로, "범용 입출력 핀"이라는 뜻입니다.

핀 번호 23은 ESP32의 디지털 핀 중 하나입니다. 우리가 코드에서 이 번호를 사용하면, ESP32는 "아, GPIO 23번으로 데이터를 보내야 하는구나" 하고 알아듣습니다.

```python
import neopixel
from machine import Pin

# GPIO 23번에 연결된 25개의 네오픽셀
np = neopixel.NeoPixel(Pin(23), 25)

# 첫 번째 LED를 빨간색으로
np[0] = (255, 0, 0)
np.write()  # 변경사항 적용
```

---

## 버튼: 가장 기본적인 입력

### 두 개면 충분합니다

헥사보드에는 **버튼 A**와 **버튼 B**, 두 개의 버튼이 있습니다. "고작 두 개?"라고 생각할 수 있지만, 이 두 개로도 놀라울 만큼 많은 것을 할 수 있습니다.

생각해보세요. 게임보이도 버튼이 몇 개 없었지만, 수백 개의 게임을 즐길 수 있었죠. 중요한 건 개수가 아니라 어떻게 사용하느냐입니다.

### 버튼의 위치와 연결

**버튼 A**

- 위치: 일반적으로 왼쪽 버튼
- GPIO: **35번**
- 역할: 주 버튼, 선택, 확인

**버튼 B**

- 위치: 일반적으로 오른쪽 버튼
- GPIO: **34번**
- 역할: 보조 버튼, 취소, 모드 변경

### Pull-down 방식 이해하기

버튼의 작동 방식을 이해하려면 "Pull-down"이라는 개념을 알아야 합니다.

전자 회로에서 버튼은 간단합니다: 누르면 연결되고, 안 누르면 끊어집니다. 하지만 문제가 있습니다. 버튼을 안 누를 때, 핀이 공중에 떠 있는 상태(floating)가 됩니다. 이 상태에서는 값이 불안정해서 0일 수도, 1일 수도, 중간일 수도 있습니다.

Pull-down 방식은 이 문제를 해결합니다:

- **버튼을 안 눌렀을 때**: 핀을 0V (GND)로 "끌어내립니다" (pull down) → 값은 0 (False)
- **버튼을 눌렀을 때**: 핀을 3.3V에 연결합니다 → 값은 1 (True)

코드에서는 이렇게 읽습니다:

```python
from machine import Pin

button_a = Pin(35, Pin.IN)  # 입력 모드

if button_a.value() == 1:
    print("버튼 A가 눌렸습니다!")
else:
    print("버튼 A가 안 눌렸습니다")
```

### 버튼 두 개로 할 수 있는 것들

**1. 기본 제어**

- A: 다음으로 이동
- B: 선택

**2. 모드 전환**

- A: 모드 1 (모니터링)
- B: 모드 2 (제어)

**3. 카운터**

- A: 숫자 증가
- B: 숫자 감소

**4. 동시 입력**

- A만: 기능 1
- B만: 기능 2
- A+B 동시: 기능 3 (특별한 조합!)

**5. 길게 누르기**

- 짧게: 일반 동작
- 길게 (2초 이상): 특수 동작 (리셋, 설정 진입 등)

**6. 더블 클릭**

- 한 번: 선택
- 빠르게 두 번: 실행

### 디바운싱: 버튼의 숨겨진 문제

버튼을 누르면 순간적으로 한 번만 신호가 가는 것 같지만, 실제로는 물리적 접점이 여러 번 붙었다 떨어지기를 반복합니다. 이것을 "바운싱(bouncing)"이라고 합니다.

```
이상적:  누름 ────┐
               └──────

실제:    누름 ─┐┌┐┌┐
            └┘└┘└───
            (여러 번 튐)
```

이 때문에 한 번 눌렀는데 여러 번 눌린 것으로 감지될 수 있습니다. 이 문제를 해결하는 것을 "디바운싱(debouncing)"이라고 하며, 나중에 코드로 처리하는 방법을 배우게 됩니다.

---

## 확장 핀: 무한한 가능성

### PIN1과 PIN2: 여러분의 센서를 위한 공간

헥사보드에는 **PIN1(GPIO 32)**과 **PIN2(GPIO 33)**라는 확장 핀이 있습니다. 여기에 외부 센서나 장치를 연결할 수 있습니다.

우리는 이 책에서:

- **PIN1 (GPIO 32)**: DHT11 온습도 센서 연결
- **PIN2 (GPIO 33)**: 조도 센서 (CdS) 연결

하지만 여기서 끝이 아닙니다. 나중에는 다른 센서들도 연결할 수 있습니다:

- 초음파 거리 센서
- 적외선 센서
- 토양 습도 센서
- 가스 센서
- 사운드 센서

### 아날로그 vs 디지털

**PIN1 (GPIO 32)**: 디지털 전용

- 0 아니면 1
- DHT11처럼 디지털 프로토콜을 사용하는 센서에 적합

**PIN2 (GPIO 33)**: 아날로그 입력 가능 (ADC)

- 0~4095 범위의 값
- 조도 센서처럼 연속적인 값을 측정하는 센서에 적합

ADC는 "Analog-to-Digital Converter"의 약자로, 아날로그 전압을 디지털 숫자로 변환해줍니다. 예를 들어:

- 0V → 0
- 1.65V → 2047
- 3.3V → 4095

### 전원 핀: 생명의 원천

센서들은 전력이 필요합니다. 헥사보드는 센서를 위한 전원 핀을 제공합니다:

**3.3V (VCC)**

- 센서에 전력을 공급
- ESP32는 3.3V 시스템 (5V 아님!)

**GND (Ground)**

- 접지, 0V
- 전류의 귀환 경로
- 모든 장치가 공통으로 연결해야 하는 기준점

전원 연결은 매우 중요합니다. 잘못 연결하면 센서나 보드가 고장날 수 있으니 항상 주의해야 합니다:

- ✅ 3.3V → VCC
- ✅ GND → GND
- ❌ 3.3V → GND (절대 안 됨! 단락)

---

## I2C: 똑똑한 통신 방식

### 두 선으로 여러 장치와 대화하기

헥사보드에는 **자이로 센서**와 **컬러 센서**가 내장되어 있습니다. 이 두 센서는 **I2C(Inter-Integrated Circuit)**라는 통신 방식을 사용합니다.

I2C의 마법은 이겁니다: **두 개의 선만으로 여러 장치와 동시에 통신할 수 있다**는 것입니다.

### I2C의 두 선

**SDA (Serial Data)** - GPIO 21

- 데이터가 오가는 선
- 양방향 통신

**SCL (Serial Clock)** - GPIO 22

- 타이밍을 맞추는 시계 신호
- 마스터(ESP32)가 제어

### 주소로 구분하기

"어떻게 같은 선에 연결된 여러 센서를 구별할까?" 궁금할 것입니다.

비밀은 **주소**입니다. 각 I2C 장치는 고유한 주소를 가지고 있습니다. 마치 집 주소처럼요.

```
헥사보드의 I2C 버스:

ESP32 (마스터)
  │
  ├── SDA (21번) ─┬─── 자이로 센서 (주소: 0x68)
  │               └─── 컬러 센서 (주소: 0x29)
  │
  └── SCL (22번) ─┴─── (같은 선에 연결)
```

ESP32가 "주소 0x68번, 데이터 주세요"라고 하면, 자이로 센서만 응답합니다. 컬러 센서는 자기 주소가 아니니까 무시하죠.

### 이 책에서의 I2C 센서

자이로 센서와 컬러 센서는 재미있는 센서이지만, 이 책의 핵심 주제가 아닙니다. AI 환경 모니터링에는 온도, 습도, 밝기가 더 중요하니까요.

그래서 이 두 센서는 부록에서만 간단히 다룹니다. 관심 있는 분들은 나중에 도전해보세요!

---

## 헥사보드 핀맵: 한눈에 보기

### 전체 구성도

```
┌──────────────────────────────────────────┐
│           헥사보드 핀맵 (ESP32)           │
├──────────────────────────────────────────┤
│                                          │
│  🔘 버튼 입력                             │
│    • 버튼 A  : GPIO 35 (왼쪽)            │
│    • 버튼 B  : GPIO 34 (오른쪽)          │
│                                          │
│  💡 네오픽셀 출력                         │
│    • LED 5×5 : GPIO 23 (25개)           │
│                                          │
│  📡 I2C 통신                              │
│    • SDA     : GPIO 21                   │
│    • SCL     : GPIO 22                   │
│    연결 장치:                             │
│      - 자이로 센서 (0x68)                │
│      - 컬러 센서   (0x29)                │
│                                          │
│  🔌 확장 핀                               │
│    • PIN1    : GPIO 32 (디지털)          │
│                → DHT11 온습도 센서       │
│    • PIN2    : GPIO 33 (ADC 가능)       │
│                → 조도 센서 (CdS)         │
│                                          │
│  ⚡ 전원                                  │
│    • 3.3V    : 센서 전원 공급            │
│    • GND     : 접지 (공통 그라운드)      │
│                                          │
│  🔌 USB                                  │
│    • 전원 + 프로그래밍 + 시리얼 통신     │
│                                          │
└──────────────────────────────────────────┘
```

### 자주 사용할 핀 번호 암기 팁

모든 핀 번호를 외울 필요는 없습니다. 자주 쓰는 것만 기억하고, 나머지는 필요할 때 찾아보면 됩니다.

**필수 암기** (자주 사용):

- 버튼 A: 35
- 버튼 B: 34
- 네오픽셀: 23
- PIN1: 32 (온습도)
- PIN2: 33 (조도)

**참고용** (가끔 사용):

- I2C SDA: 21
- I2C SCL: 22

**팁**: 코드에서는 상수로 정의해서 사용하므로 실제로 숫자를 외울 필요가 없습니다!

```python
# 이렇게 정의하면 숫자를 외울 필요 없음
BUTTON_A = 35
BUTTON_B = 34
NEOPIXEL_PIN = 23
TEMP_SENSOR_PIN = 32
LIGHT_SENSOR_PIN = 33
```

---

## 헥사보드 연결하고 인식하기

### 1단계: 물리적 연결

**필요한 것**:

- 헥사보드
- USB 케이블 (Micro USB 또는 USB-C)
- 컴퓨터 (Windows, Mac, Linux 모두 가능)

**연결 방법**:

1. USB 케이블의 한쪽을 헥사보드에 연결
2. 다른 쪽을 컴퓨터의 USB 포트에 연결
3. 헥사보드의 전원 LED가 켜지는지 확인 (보통 빨간색)

LED가 켜지면 성공입니다! 헥사보드가 전원을 받고 있다는 뜻이죠.

### 2단계: 컴퓨터에서 인식 확인

컴퓨터가 헥사보드를 "시리얼 포트"로 인식합니다. 이 포트를 통해 프로그램을 업로드하고 데이터를 주고받습니다.

**Windows에서 확인**:

1. 장치 관리자 열기 (Win + X → 장치 관리자)
2. "포트 (COM & LPT)" 항목 찾기
3. "USB-SERIAL CH340" 또는 "CP210x" 같은 이름 확인
4. 포트 번호 기억 (예: COM3, COM4)

**Mac에서 확인**:

1. 터미널 열기 (Cmd + Space → "터미널")
2. 명령 입력:
   ```bash
   ls /dev/tty.*
   ```
3. 결과에서 `/dev/tty.usbserial-XXX` 같은 것 찾기
4. 이 경로가 헥사보드의 포트입니다

**Linux에서 확인**:

1. 터미널 열기
2. 명령 입력:
   ```bash
   ls /dev/ttyUSB*
   ```
3. 보통 `/dev/ttyUSB0` 또는 `/dev/ttyUSB1`로 나타남

### 3단계: 드라이버 설치 (필요한 경우)

대부분의 경우 자동으로 드라이버가 설치되지만, Windows에서 인식이 안 된다면:

- **CH340 드라이버**: 대부분의 저가 보드가 사용
- **CP210x 드라이버**: Silicon Labs 칩 사용 시

해당 드라이버를 인터넷에서 검색해서 설치하면 됩니다.

### 문제 해결

**Q: LED는 켜지는데 포트가 안 보여요**
A: 드라이버 설치가 필요할 수 있습니다. 또는 USB 케이블이 충전 전용(데이터 불가)일 수 있으니 다른 케이블로 시도해보세요.

**Q: 포트가 여러 개 보여요**
A: 헥사보드를 연결했다 뺐다 해보면서 사라졌다 나타나는 포트를 찾으세요.

**Q: Mac에서 권한 오류가 나요**
A: 터미널에서 `sudo chmod 666 /dev/tty.usbserial-XXX` 명령 실행 (비밀번호 입력 필요)

---

## 헥사보드 둘러보기: 실제 확인하기

이제 헥사보드를 손에 들고 직접 확인해봅시다.

### 체크리스트

**외관 확인**:

- [ ] 5×5 네오픽셀 LED가 보이나요? (보통 가운데에 격자 형태)
- [ ] 버튼 2개가 있나요? (누르면 딸깍 소리)
- [ ] PIN1, PIN2 라벨이나 핀이 있나요?
- [ ] USB 포트가 있나요?

**연결 확인**:

- [ ] USB 케이블을 연결했나요?
- [ ] 전원 LED가 켜졌나요?
- [ ] 컴퓨터가 포트를 인식했나요?

**버튼 테스트**:

- [ ] 버튼 A를 눌러보세요. 클릭감이 느껴지나요?
- [ ] 버튼 B를 눌러보세요. 클릭감이 느껴지나요?

모두 체크되었나요? 축하합니다! 헥사보드가 정상입니다.

### 첫 만남의 설렘

지금 여러분 손에 들린 이 작은 보드가 앞으로 놀라운 일들을 해낼 것입니다:

- 방의 온도와 습도를 측정하고
- 화려한 LED로 데이터를 표현하고
- Wi-Fi로 클라우드에 데이터를 전송하고
- 인공지능의 명령을 받아 스스로 제어하고
- 웹 브라우저에서 실시간으로 상태를 보여주고...

이 모든 것이 여러분이 작성할 코드로 가능해집니다.

---

## 헥사보드와 다른 보드 비교

궁금할 것입니다. "왜 하필 헥사보드일까? 아두이노나 라즈베리파이는 어때?"

### 아두이노 vs 헥사보드

**아두이노**:

- ✅ 엄청난 커뮤니티와 자료
- ✅ 매우 안정적
- ❌ Wi-Fi 없음 (별도 모듈 필요)
- ❌ 성능이 약함 (16 MHz, 2KB RAM)
- ❌ Python 미지원

**헥사보드 (ESP32)**:

- ✅ Wi-Fi/블루투스 내장
- ✅ 강력한 성능 (240 MHz, 520KB RAM)
- ✅ MicroPython 지원
- ✅ LED, 센서 등 기본 장착
- ⚠️ 아두이노보다 자료가 적음 (하지만 빠르게 증가 중)

### 라즈베리파이 vs 헥사보드

**라즈베리파이**:

- ✅ 완전한 컴퓨터 (Linux 실행)
- ✅ 복잡한 프로그램 가능
- ❌ 비쌈 (7만원 이상)
- ❌ 전력 소비 많음
- ❌ 실시간 제어에는 부적합
- ❌ GPIO 전압이 3.3V로 제한적

**헥사보드**:

- ✅ 저렴함 (3~5만원)
- ✅ 저전력
- ✅ 실시간 제어 완벽
- ✅ 교육용으로 최적화
- ❌ 복잡한 프로그램 불가 (브라우저, 동영상 등)

### 결론: 적재적소

- **웹 서버, AI 처리, 복잡한 계산**: 라즈베리파이
- **센서 제어, 실시간 반응, IoT**: 헥사보드/ESP32
- **전통적인 로봇, 안정성 중시**: 아두이노

우리의 AIoT 프로젝트에는 헥사보드가 완벽한 선택입니다!

---

## 핵심 요약

### 헥사보드의 정체

- **ESP32 기반**: 듀얼 코어 240MHz, Wi-Fi/블루투스 내장
- **올인원 설계**: LED, 버튼, 센서가 기본 장착
- **MicroPython 지원**: 쉬운 프로그래밍
- **교육용 최적화**: 바로 사용 가능

### 주요 부품과 핀 번호

| 부품     | GPIO | 용도               |
| -------- | ---- | ------------------ |
| 버튼 A   | 35   | 입력 (메인)        |
| 버튼 B   | 34   | 입력 (서브)        |
| 네오픽셀 | 23   | 출력 (5×5 LED)     |
| PIN1     | 32   | 확장 (온습도 센서) |
| PIN2     | 33   | 확장 (조도 센서)   |
| I2C SDA  | 21   | 통신 (자이로/컬러) |
| I2C SCL  | 22   | 통신 (자이로/컬러) |

### 기억해야 할 개념

1. **GPIO**: 범용 입출력 핀, 번호로 구분
2. **네오픽셀**: 25개의 스마트 RGB LED, 한 선으로 제어
3. **Pull-down**: 버튼 방식, 안 누름=0, 누름=1
4. **I2C**: 두 선으로 여러 장치 통신
5. **ADC**: 아날로그를 디지털로 변환 (0~4095)

---

## 다음 단계

헥사보드의 구조를 완전히 이해했습니다! 이제 각 부품이 무엇인지, 어디에 연결되어 있는지, 무엇을 할 수 있는지 알게 되었죠.

다음 챕터에서는 이 멋진 보드를 실제로 프로그래밍할 환경을 구축합니다. Thonny IDE를 설치하고, MicroPython 펌웨어를 업로드하고, 첫 번째 코드 "Hello World"를 작성해볼 것입니다.

**드디어 LED가 켜집니다!** 🎉

---

**💡 작은 팁**

헥사보드의 핀맵을 스마트폰으로 사진 찍어두거나, 종이에 인쇄해서 책상에 붙여두세요. 코딩할 때 "PIN1이 몇 번이었지?" 하고 매번 찾아보는 것보다 훨씬 편합니다!

---

**다음 챕터 예고**  
Chapter 3 - 개발 환경 준비하기

Thonny IDE 설치부터 첫 LED 켜기까지, 드디어 실습이 시작됩니다!

---

# Chapter 3. 개발 환경 준비하기

> **PART 1**: AI 센서랩과 헥사보드 이해하기

---

## 도구를 갖추는 시간

목수가 집을 짓기 전에 망치와 톱을 준비하듯이, 우리도 헥사보드를 프로그래밍하기 전에 개발 환경을 준비해야 합니다. 하지만 걱정하지 마세요. 복잡한 설정이나 어려운 과정은 없습니다.

이 챕터에서는 **Thonny IDE**라는 초보자 친화적인 프로그램 하나만 설치하면 됩니다. 그리고 헥사보드에 이미 설치되어 있는 MicroPython을 확인한 뒤, 첫 번째 코드를 실행해볼 것입니다.

20-30분이면 모든 준비가 끝나고, LED가 여러분의 명령에 따라 깜빡이기 시작할 것입니다!

**이 챕터를 마치면**:

- Thonny IDE를 설치하고 헥사보드와 연결할 수 있습니다
- MicroPython이 무엇인지, 왜 사용하는지 이해합니다
- 첫 번째 코드를 작성하고 실행할 수 있습니다
- 오류가 발생했을 때 어떻게 해결하는지 알게 됩니다

**예상 소요 시간**: 30분 (설치 포함)

---

## MicroPython: 작은 보드를 위한 Python

### Python? MicroPython? 뭐가 다른가요?

먼저 **Python**에 대해 알아봅시다. Python은 세계에서 가장 인기 있는 프로그래밍 언어 중 하나입니다. 읽기 쉽고, 배우기 쉽고, 강력합니다. 웹 개발, 데이터 분석, AI... 거의 모든 분야에서 사용되죠.

하지만 일반 Python은 컴퓨터나 서버처럼 큰 시스템을 위해 만들어졌습니다. ESP32 같은 작은 마이크로컨트롤러에서 실행하기에는 너무 크고 무겁습니다.

여기서 **MicroPython**이 등장합니다!

### MicroPython의 탄생

2013년, Damien George라는 영국의 물리학자가 킥스타터 캠페인을 시작했습니다. 목표는 간단했습니다: "작은 마이크로컨트롤러에서도 Python을 실행하자!"

그의 노력으로 MicroPython이 탄생했고, 이제는 ESP32를 포함한 수많은 보드에서 사용됩니다. Python의 문법을 그대로 사용하면서도, 작은 메모리와 제한된 자원에서 효율적으로 동작하도록 최적화되었습니다.

### 왜 C/C++가 아니라 MicroPython일까?

전통적으로 마이크로컨트롤러는 C나 C++로 프로그래밍했습니다. 아두이노가 대표적이죠. C/C++는 빠르고 효율적이지만, 초보자에게는 어렵습니다.

**C/C++ 코드 예시** (LED 깜빡이기):

```cpp
#include <Arduino.h>

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  delay(1000);
  digitalWrite(LED_BUILTIN, LOW);
  delay(1000);
}
```

**MicroPython 코드 예시** (같은 동작):

```python
from machine import Pin
import time

led = Pin(2, Pin.OUT)

while True:
    led.on()
    time.sleep(1)
    led.off()
    time.sleep(1)
```

어느 쪽이 더 읽기 쉬운가요? MicroPython은 영어 문장처럼 읽힙니다. `led.on()` - LED를 켜라. `time.sleep(1)` - 1초 기다려라. 명확하죠!

### MicroPython의 장점

1. **배우기 쉽습니다**: Python은 초보자를 위해 설계된 언어입니다
2. **즉시 실험 가능**: 코드를 한 줄씩 실행하며 테스트할 수 있습니다 (REPL)
3. **빠른 개발**: 컴파일 과정 없이 바로 실행됩니다
4. **풍부한 라이브러리**: 센서, 통신, 디스플레이 등 다양한 라이브러리
5. **커뮤니티**: 전 세계 개발자들의 지원과 예제

### 헥사보드와 MicroPython

좋은 소식이 있습니다: **헥사보드에는 이미 MicroPython이 설치되어 있습니다!**

별도의 펌웨어 설치 과정 없이, USB만 연결하면 바로 MicroPython을 사용할 수 있습니다. 이것이 헥사보드의 또 다른 장점이죠.

---

## Thonny IDE: 가장 쉬운 개발 도구

### IDE가 뭔가요?

IDE는 "Integrated Development Environment"의 약자로, "통합 개발 환경"이라는 뜻입니다. 쉽게 말하면, 코드를 작성하고, 실행하고, 디버깅하는 모든 것을 한 곳에서 할 수 있는 프로그램입니다.

메모장으로도 코드를 작성할 수 있지만, IDE를 사용하면 훨씬 편합니다:

- 코드 자동 완성
- 오류 표시
- 실행 버튼 한 번으로 테스트
- 파일 관리

### 왜 Thonny인가?

MicroPython을 위한 IDE는 여러 가지가 있습니다. VS Code, PyCharm, Mu Editor... 하지만 우리는 **Thonny**를 선택합니다. 이유는:

1. **초보자를 위해 만들어졌습니다**

   - 복잡한 설정 불필요
   - 깔끔한 인터페이스
   - 영어 외에 한국어 포함 다국어 지원

2. **MicroPython을 공식 지원합니다**

   - ESP32 자동 인식
   - 파일 업로드/다운로드 쉬움
   - REPL 내장

3. **무료이고 가볍습니다**

   - 설치 파일 크기 작음
   - 느린 컴퓨터에서도 잘 돌아감

4. **교육용으로 완벽합니다**
   - 변수의 값이 어떻게 변하는지 보여줌
   - 단계별 실행 가능
   - 오류 메시지가 친절함

---

## Thonny 설치하기

### Windows 사용자

**1단계: 다운로드**

1. 웹 브라우저를 열고 https://thonny.org 접속
2. 큰 "Windows" 버튼을 클릭
3. `thonny-4.x.x.exe` 파일 다운로드 (파일 크기 약 20MB)

**2단계: 설치**

1. 다운로드한 파일을 더블클릭
2. "이 파일을 실행하시겠습니까?" → "예"
3. 설치 옵션에서 **"Install for me only"** 권장 (관리자 권한 불필요)
4. "Next" → "Next" → "Install" 클릭
5. 1-2분 기다리면 설치 완료
6. "Finish" 클릭

**3단계: 실행**

- 바탕화면의 Thonny 아이콘 더블클릭
- 또는 시작 메뉴에서 "Thonny" 검색 후 실행

처음 실행하면 언어를 선택하는 창이 나올 수 있습니다. 한국어를 선택하세요!

### Mac 사용자

**1단계: 다운로드**

1. https://thonny.org 접속
2. "Mac" 버튼 클릭
3. `thonny-4.x.x.pkg` 파일 다운로드

**2단계: 설치**

1. 다운로드한 pkg 파일 더블클릭
2. "~을(를) 열 수 없습니다" 보안 경고가 나오면:
   - 시스템 환경설정 → 보안 및 개인정보 보호
   - 하단에 "확인 없이 열기" 버튼 클릭
3. 설치 안내를 따라 진행
4. 관리자 비밀번호 입력
5. 설치 완료

**3단계: 실행**

- Applications 폴더에서 Thonny 찾기
- Launchpad에서 "Thonny" 검색
- 첫 실행 시 "인터넷에서 다운로드한 응용 프로그램입니다" 경고 → "열기"

### Linux 사용자 (Ubuntu/Debian)

터미널을 열고 (Ctrl + Alt + T):

```bash
# 패키지 목록 업데이트
sudo apt update

# Thonny 설치
sudo apt install thonny

# 실행
thonny
```

다른 리눅스 배포판:

```bash
# Fedora
sudo dnf install thonny

# Arch Linux
sudo pacman -S thonny
```

### 설치 확인

Thonny가 정상적으로 실행되면, 다음과 같은 화면을 볼 수 있습니다:

- 상단: 메뉴 바와 도구 버튼
- 중앙: 코드 편집기 (비어있음)
- 하단: Shell 창 (>>> 프롬프트)

축하합니다! 첫 번째 관문을 통과했습니다. 🎉

---

## 헥사보드와 Thonny 연결하기

### 1단계: 물리적 연결

1. USB 케이블을 준비하세요
2. 헥사보드의 USB 포트에 연결
3. 컴퓨터의 USB 포트에 연결
4. 헥사보드의 전원 LED가 켜지는지 확인 (보통 빨간색)

LED가 켜졌나요? 좋습니다! 전원은 공급되고 있습니다.

### 2단계: Thonny에서 인터프리터 설정

**방법 1: 빠른 설정** (권장)

1. Thonny 우측 하단을 보세요
2. "Python 3.x.x" 또는 "Local Python 3" 같은 텍스트가 보입니다
3. 이것을 클릭!
4. 드롭다운 메뉴에서 **"MicroPython (ESP32)"** 또는 **"MicroPython (generic)"** 선택
5. 잠시 기다리면 자동으로 연결됩니다

**방법 2: 수동 설정**

1. 메뉴에서 **도구(Tools) → 옵션(Options)** 클릭
2. **인터프리터(Interpreter)** 탭 선택
3. 첫 번째 드롭다운에서 **"MicroPython (ESP32)"** 선택
4. 두 번째 드롭다운(Port)에서:

   - Windows: `COM3`, `COM4` 등에서 선택
   - Mac: `/dev/cu.usbserial-xxx` 선택
   - Linux: `/dev/ttyUSB0` 선택

   포트가 여러 개면? 헥사보드를 뺐다가 다시 꽂아보면서 사라졌다 나타나는 포트를 찾으세요.

5. **OK** 클릭

### 3단계: 연결 확인

성공적으로 연결되면, Thonny 하단의 Shell 창에 이런 메시지가 보입니다:

```
MPY: soft reboot
MicroPython v1.24.0 on 2024-10-25; ESP32 module with ESP32
Type "help()" for more information.
>>>
```

`>>>` 프롬프트가 보이나요? **완벽합니다!** 헥사보드와 통신하고 있습니다!

### 문제 해결

**Q: 포트가 안 보여요 / "No interpreter" 뜬다**

A: 드라이버 설치가 필요할 수 있습니다.

- Windows: CH340 드라이버 또는 CP210x 드라이버 검색 후 설치
- Mac: 보통 자동 인식되지만, Big Sur 이상에서는 드라이버 필요할 수 있음
- Linux: 사용자 권한 추가 필요
  ```bash
  sudo usermod -a -G dialout $USER
  # 로그아웃 후 다시 로그인
  ```

**Q: 연결했다가 끊어집니다**

A:

- USB 케이블이 충전 전용(데이터 불가)일 수 있습니다. 다른 케이블로 시도
- USB 허브 사용 중이면, 컴퓨터에 직접 연결 시도
- 다른 USB 포트 시도 (USB 3.0보다 USB 2.0이 안정적일 수 있음)

**Q: "Error connecting" 메시지**

A:

- Thonny를 완전히 종료하고 재시작
- 헥사보드를 뽑았다가 다시 연결
- 컴퓨터 재시작 (마지막 수단)

---

## 첫 번째 코드: Hello World!

### 프로그래밍의 전통

모든 프로그래밍 언어를 배울 때, 전통적으로 첫 번째로 작성하는 프로그램이 있습니다: **"Hello, World!"를 출력하는 것**.

이 전통은 1978년 발행된 전설적인 책 "The C Programming Language"에서 시작되었습니다. 이제 여러분도 이 전통에 동참할 차례입니다!

### 코드 작성하기

1. **Thonny의 상단 편집기(빈 공간)에 다음 코드를 입력하세요**:

```python
print("Hello, HexaBoard!")
```

2. **실행하기**:

   - 초록색 ▶️ 버튼 클릭
   - 또는 키보드에서 **F5** 키
   - 또는 메뉴에서 실행(Run) → Run current script

3. **결과 확인**:

하단 Shell 창에 이렇게 출력됩니다:

```
Hello, HexaBoard!
```

**축하합니다!** 🎉

여러분의 첫 번째 MicroPython 프로그램이 성공적으로 실행되었습니다. 간단해 보이지만, 이것은 중요한 순간입니다. 여러분의 컴퓨터가 헥사보드와 통신하고, 헥사보드가 여러분의 명령을 이해하고 실행했습니다!

### 조금 더 실험해볼까요?

코드를 수정해서 다시 실행해보세요:

```python
print("Hello, HexaBoard!")
print("My name is [여러분의 이름]")
print("Let's build something amazing!")
```

실행하면:

```
Hello, HexaBoard!
My name is [여러분의 이름]
Let's build something amazing!
```

이렇게 여러 줄을 출력할 수 있습니다!

### REPL: 대화하듯 코드 작성하기

하단 Shell 창의 `>>>` 프롬프트에 직접 코드를 입력할 수도 있습니다:

```python
>>> print("즉시 실행!")
즉시 실행!
>>> 2 + 2
4
>>> "Python" + " is " + "fun"
'Python is fun'
```

이것을 **REPL**이라고 합니다 (Read-Eval-Print Loop: 읽고-평가하고-출력하는 반복). 코드를 한 줄씩 실험하고 결과를 바로 볼 수 있는 대화형 모드입니다.

아두이노에는 없는 MicroPython의 큰 장점입니다!

---

## 진짜 하드웨어 제어: LED 깜빡이기

### 드디어 LED를 켭니다!

"Hello World"는 좋았지만, 하드웨어의 진짜 재미는 물리적인 것을 제어할 때 시작됩니다. LED를 켜봅시다!

ESP32에는 내장 LED가 있습니다 (보드에 따라 GPIO 2번 또는 다른 핀). 이 LED를 제어하는 코드를 작성해봅시다.

### 코드

Thonny 편집기에 다음 코드를 입력하세요:

```python
from machine import Pin
import time

# 내장 LED (GPIO 2번)
led = Pin(2, Pin.OUT)

# 5번 깜빡이기
for i in range(5):
    led.on()   # LED 켜기
    print(f"깜빡 {i+1}: LED ON")
    time.sleep(0.5)  # 0.5초 대기

    led.off()  # LED 끄기
    print(f"깜빡 {i+1}: LED OFF")
    time.sleep(0.5)  # 0.5초 대기

print("완료!")
```

### 실행하기

F5를 누르거나 실행 버튼을 클릭하세요.

헥사보드의 작은 LED가 0.5초 간격으로 5번 깜빡일 것입니다! 동시에 Shell 창에는:

```
깜빡 1: LED ON
깜빡 1: LED OFF
깜빡 2: LED ON
깜빡 2: LED OFF
...
완료!
```

**여러분이 방금 한 것**: 코드로 물리적 세계를 제어했습니다! 🚀

### 코드 설명

하나하나 이해해봅시다:

```python
from machine import Pin
```

→ `machine` 모듈에서 `Pin` 클래스를 가져옵니다. Pin은 GPIO 핀을 제어하는 도구입니다.

```python
import time
```

→ `time` 모듈을 가져옵니다. 대기 시간(sleep)을 위해 필요합니다.

```python
led = Pin(2, Pin.OUT)
```

→ GPIO 2번 핀을 출력 모드로 설정합니다. 이제 `led` 변수로 이 핀을 제어할 수 있습니다.

```python
for i in range(5):
```

→ 5번 반복합니다 (i = 0, 1, 2, 3, 4).

```python
led.on()
```

→ LED를 켭니다 (핀에 HIGH 신호 = 3.3V).

```python
time.sleep(0.5)
```

→ 0.5초 기다립니다.

```python
led.off()
```

→ LED를 끕니다 (핀에 LOW 신호 = 0V).

간단하죠? 이것이 MicroPython의 힘입니다!

### 실험해보기

코드를 수정해서 다양하게 실험해보세요:

**더 빠르게 깜빡이기**:

```python
time.sleep(0.1)  # 0.5 대신 0.1초
```

**더 많이 깜빡이기**:

```python
for i in range(10):  # 5 대신 10번
```

**모스 부호 SOS 만들기**:

```python
# S: 짧게 3번
for i in range(3):
    led.on()
    time.sleep(0.2)
    led.off()
    time.sleep(0.2)

# 중간 쉼
time.sleep(0.6)

# O: 길게 3번
for i in range(3):
    led.on()
    time.sleep(0.6)
    led.off()
    time.sleep(0.2)

# 중간 쉼
time.sleep(0.6)

# S: 짧게 3번
for i in range(3):
    led.on()
    time.sleep(0.2)
    led.off()
    time.sleep(0.2)
```

창의력을 발휘해보세요!

---

## 파일 저장하기

### 컴퓨터 vs 헥사보드

Thonny에서 코드를 작성할 때, 두 곳에 저장할 수 있습니다:

1. **컴퓨터 (This computer)**: 여러분의 PC/Mac에 저장
2. **헥사보드 (MicroPython device)**: 헥사보드의 메모리에 저장

### 저장 방법

**Ctrl + S** (또는 Cmd + S)를 누르면 저장 위치를 묻습니다:

- **"This computer"**: 나중에 다시 불러와서 편집 가능. 백업용으로 좋음.
- **"MicroPython device"**: 헥사보드가 부팅할 때 자동 실행하려면 여기에 저장.

### 자동 실행 설정

헥사보드가 전원을 켤 때 자동으로 프로그램을 실행하고 싶나요?

1. 코드를 **"MicroPython device"**에 저장
2. 파일 이름을 **`main.py`**로 지정
3. 완료!

이제 헥사보드를 USB에서 분리했다가 다시 연결하면 (또는 배터리로 전원을 켜면), `main.py`가 자동으로 실행됩니다.

**주의**: 무한 루프나 오류가 있는 코드를 `main.py`로 저장하면, 보드가 부팅할 때마다 문제가 생길 수 있습니다. 이럴 때는 보드를 연결하자마자 Thonny의 "Stop" 버튼(빨간 사각형)을 빠르게 눌러 실행을 중단하고, 파일을 삭제하거나 수정하세요.

---

## Thonny의 유용한 기능들

### 1. 파일 탐색기

**보기(View) → Files** 메뉴를 선택하면, 좌측에 파일 탐색기가 나타납니다.

두 개의 섹션이 보입니다:

- **This computer**: 여러분의 PC/Mac 파일
- **MicroPython device**: 헥사보드의 파일

파일을 드래그 앤 드롭으로 업로드/다운로드할 수 있습니다!

### 2. 변수 창

**보기(View) → Variables** 메뉴를 선택하면, 현재 변수들의 값을 실시간으로 볼 수 있습니다.

디버깅할 때 매우 유용합니다.

### 3. 플로터 (고급)

**보기(View) → Plotter** 메뉴를 선택하면, 숫자 데이터를 그래프로 시각화할 수 있습니다.

센서 값의 변화를 그래프로 보고 싶을 때 사용합니다.

### 4. 단계별 실행

복잡한 코드를 한 줄씩 실행하며 어떻게 작동하는지 볼 수 있습니다:

- F6: 다음 줄 실행 (Step over)
- F7: 함수 안으로 들어가기 (Step into)

### 5. 자동 완성

코드를 입력하다가 `Ctrl + Space`를 누르면, 자동 완성 제안이 나타납니다.

예: `Pin.` 까지 입력하고 Ctrl + Space → `on()`, `off()`, `value()` 등의 메서드 목록이 보입니다.

---

## 오류를 두려워하지 마세요

### 오류는 친구입니다

프로그래밍을 하다 보면 오류 메시지를 자주 만나게 됩니다. 좌절하지 마세요! **오류는 적이 아니라 선생님**입니다. 무엇이 잘못되었는지 알려주는 친절한 안내자죠.

### 흔한 오류들

**1. SyntaxError: invalid syntax**

```python
print("Hello World"  # 닫는 괄호 빠짐!
```

→ 문법 오류입니다. 괄호, 따옴표, 콜론(:)을 빠뜨렸거나 잘못 입력한 경우가 많습니다.

**2. NameError: name 'xxx' isn't defined**

```python
print(myVariable)  # myVariable을 정의하지 않았음!
```

→ 정의되지 않은 변수나 함수를 사용하려고 했습니다. 철자를 확인하세요.

**3. IndentationError: unexpected indent**

```python
print("Hello")
    print("World")  # 들여쓰기가 잘못됨!
```

→ Python은 들여쓰기가 매우 중요합니다. 탭과 스페이스를 섞어 쓰지 마세요. Thonny는 보통 자동으로 맞춰주지만, 주의하세요.

**4. OSError: [Errno 19] ENODEV**

→ 헥사보드와의 연결이 끊어졌습니다. USB 케이블을 확인하고 재연결하세요.

### 오류 해결 전략

1. **오류 메시지를 읽으세요**: 어디서(몇 번째 줄) 무엇이 잘못되었는지 알려줍니다
2. **구글에 검색하세요**: "MicroPython [오류 메시지]"로 검색하면 대부분 해답을 찾을 수 있습니다
3. **한 줄씩 확인하세요**: 주석 처리(#)로 코드를 하나씩 비활성화하며 어디가 문제인지 찾습니다
4. **처음부터 다시 작성하세요**: 때로는 다시 작성하는 게 더 빠릅니다

---

## 핵심 요약

### 설치한 것

- **Thonny IDE**: MicroPython 개발을 위한 초보자 친화적인 IDE

### 배운 것

1. **MicroPython**: 마이크로컨트롤러용으로 최적화된 Python
2. **Thonny 설정**: 헥사보드와 연결하는 방법
3. **첫 코드 실행**: print() 문으로 텍스트 출력
4. **LED 제어**: GPIO 핀으로 실제 하드웨어 제어
5. **파일 저장**: 컴퓨터와 헥사보드에 저장하는 방법
6. **오류 처리**: 오류 메시지 읽고 해결하는 방법

### 중요한 코드 패턴

```python
# 1. LED 제어 기본
from machine import Pin
led = Pin(2, Pin.OUT)
led.on()   # 켜기
led.off()  # 끄기

# 2. 시간 지연
import time
time.sleep(1)  # 1초 대기

# 3. 반복
for i in range(5):  # 5번 반복
    # 코드
```

---

## 다음 단계

개발 환경 준비 완료! 🎉

이제 여러분은:

- Thonny를 설치하고 설정할 수 있습니다
- 헥사보드와 통신할 수 있습니다
- 코드를 작성하고 실행할 수 있습니다
- LED를 제어할 수 있습니다

다음 챕터부터는 본격적으로 헥사보드의 기능을 하나씩 배워갑니다:

- 버튼 입력 받기
- 네오픽셀 LED를 화려하게 제어하기
- 상태 머신으로 복잡한 동작 구현하기

**준비되셨나요? 시작합니다!** 🚀

---

**💡 작은 팁**

Thonny에서 Shell 창의 글자가 너무 작거나 크다면?
→ **도구(Tools) → 옵션(Options) → 테마(Theme)** 에서 글자 크기 조절 가능!

---

**다음 챕터 예고**  
Chapter 4 - 디지털 입력의 기본: 버튼 2개 다루기

버튼을 누르면 어떻게 감지할까요? 한 번 누르는 것과 길게 누르는 것을 어떻게 구별할까요? 다음 챕터에서 알아봅니다!

---

# PART 2: 헥사보드 기본 제어 – 버튼과 네오픽셀

# Chapter 4. 디지털 입력의 기본 – 버튼 2개 다루기

> **PART 2**: 헥사보드 기본 제어 – 버튼과 네오픽셀

---

## 세상과 소통하기: 입력의 시작

지금까지 우리는 헥사보드에게 명령을 내렸습니다. "LED를 켜라", "메시지를 출력해라". 하지만 진정한 상호작용은 **양방향**입니다. 헥사보드도 우리의 행동에 반응할 수 있어야 하죠.

버튼은 가장 간단하면서도 가장 중요한 입력 장치입니다. 스마트폰의 전원 버튼, 엘리베이터의 층 버튼, 게임 컨트롤러의 A/B 버튼... 우리 주변은 버튼으로 가득합니다.

이 챕터에서는 헥사보드의 두 개 버튼(A와 B)을 사용하여:

- 버튼 누름을 감지하는 방법
- 한 번 누름과 계속 누르고 있음을 구별하는 방법
- 두 버튼을 동시에 사용하는 방법
- 버튼으로 카운터를 만드는 방법

을 배웁니다.

간단해 보이지만, 이것이 모든 인터랙티브 시스템의 기초입니다!

**예상 소요 시간**: 30분

---

## 디지털 입력이란?

### 아날로그 vs 디지털

우리가 사는 세계는 **아날로그**입니다. 온도는 20.5°C, 21.3°C, 22.7°C... 무한히 많은 값을 가질 수 있죠. 소리의 크기, 빛의 밝기, 거리... 모두 연속적인 값입니다.

하지만 컴퓨터는 **디지털**입니다. 0과 1, 두 가지 값만 이해합니다.

버튼은 완벽한 디지털 입력 장치입니다:

- **0 (LOW, False)**: 버튼을 누르지 않은 상태
- **1 (HIGH, True)**: 버튼을 누른 상태

중간 상태는 없습니다. "50% 눌림" 같은 건 없죠. 눌렸거나, 안 눌렸거나. 명확합니다.

### GPIO: 범용 입출력 핀

**GPIO**는 "General Purpose Input/Output"의 약자입니다. "범용 입출력"이라는 뜻이죠.

ESP32의 GPIO 핀은 마법 같습니다:

- **출력 모드**: LED를 켜고 끄기, 모터 제어, 신호 보내기
- **입력 모드**: 버튼 읽기, 센서 데이터 받기

같은 핀이지만, 우리가 어떻게 설정하느냐에 따라 역할이 바뀝니다!

헥사보드에는 수십 개의 GPIO 핀이 있지만, 우리는 그중 두 개를 버튼 전용으로 사용합니다:

- **버튼 A**: GPIO 35번
- **버튼 B**: GPIO 34번

### Pull-up? Pull-down?

버튼을 마이크로컨트롤러에 연결할 때, 한 가지 문제가 있습니다.

버튼을 누르지 않았을 때, 핀이 아무것도 연결되지 않은 "떠있는" 상태가 됩니다. 이를 **floating** 상태라고 하는데, 이때 핀의 값은 예측 불가능합니다. 0일 수도, 1일 수도 있고, 계속 변할 수도 있습니다.

이를 해결하기 위해 **저항**을 사용합니다:

**Pull-up 방식**:

- 버튼을 누르지 않으면 → 1 (HIGH)
- 버튼을 누르면 → 0 (LOW)

**Pull-down 방식**:

- 버튼을 누르지 않으면 → 0 (LOW)
- 버튼을 누르면 → 1 (HIGH)

헥사보드는 **Pull-down 방식**을 사용합니다. 더 직관적이죠:

- 버튼 안 누름 = 0 = False = "아무 일도 없음"
- 버튼 누름 = 1 = True = "버튼이 눌렸어!"

다행히 ESP32에는 내부 Pull-down 저항이 내장되어 있어서, 별도의 외부 저항이 필요 없습니다. 코드에서 `Pin.PULL_DOWN`만 지정하면 됩니다!

---

## 실습 준비

### 필요한 것

- 헥사보드 × 1
- USB 케이블 × 1
- Thonny IDE (이미 설치됨)

### 헥사보드의 버튼 찾기

헥사보드를 보세요. 보드 위에 작은 버튼 두 개가 있습니다:

- **버튼 A**: 왼쪽 (또는 위쪽)
- **버튼 B**: 오른쪽 (또는 아래쪽)

보통 "A"와 "B"라고 표시되어 있습니다. 손가락으로 살짝 눌러보세요. 딸깍 소리와 함께 눌리는 느낌이 있나요? 정상입니다!

---

## 실습 1: 버튼 A 읽기 - 가장 간단한 방법

### 목표

버튼 A를 누르면 "버튼이 눌렸습니다!"라는 메시지를 출력합니다.

### 코드

```python
# 파일명: ch04_button_simple.py
from machine import Pin
import time

# 버튼 A 설정 (GPIO 35, 입력 모드, Pull-down)
button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)

print("버튼 A를 눌러보세요!")
print("종료하려면 Ctrl+C를 누르세요.")
print()

while True:
    # 버튼 상태 읽기
    if button_a.value() == 1:  # 1 = 눌림
        print("버튼 A가 눌렸습니다!")

    time.sleep(0.1)  # 100ms 대기
```

### 코드 설명

```python
button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
```

- `35`: GPIO 35번 핀 (버튼 A)
- `Pin.IN`: 입력 모드로 설정
- `Pin.PULL_DOWN`: 내부 Pull-down 저항 활성화

```python
if button_a.value() == 1:
```

- `button_a.value()`: 현재 버튼 상태 읽기 (0 또는 1 반환)
- `== 1`: 1이면 (버튼이 눌렸으면)

```python
time.sleep(0.1)
```

- 100ms(0.1초) 대기. 너무 빠르게 반복하면 CPU를 낭비합니다.

### 실행하기

1. Thonny에 위 코드를 입력
2. F5 또는 ▶️ 버튼으로 실행
3. 헥사보드의 버튼 A를 눌러보세요
4. Shell 창에 "버튼 A가 눌렸습니다!" 메시지가 나타납니다

### 관찰해보기

버튼을 짧게 눌러보세요. 메시지가 몇 번 출력되나요?

아마 여러 번 출력될 것입니다:

```
버튼 A가 눌렸습니다!
버튼 A가 눌렸습니다!
버튼 A가 눌렸습니다!
```

왜 그럴까요?

우리가 "짧게" 눌렀다고 생각한 시간이, 컴퓨터에게는 **매우 긴 시간**이기 때문입니다. 0.1초마다 체크하는데, 우리가 버튼을 0.3초 동안 눌렀다면, 3번 체크되는 것이죠!

이것은 버그가 아닙니다. 정상 동작입니다. 하지만 때로는 "한 번 눌렀을 때 한 번만 반응"하고 싶을 수 있습니다. 다음 실습에서 해결해봅시다!

---

## 실습 2: 버튼 눌림만 감지하기 (Edge Detection)

### 목표

버튼을 누르고 있어도, **처음 누르는 순간에만** 한 번 반응합니다.

### 핵심 아이디어

**상태 변화를 감지**합니다:

- 이전 상태: 0 (안 눌림)
- 현재 상태: 1 (눌림)
- → 변화 발생! 이때만 반응!

이를 **엣지 감지(Edge Detection)** 또는 **상승 엣지(Rising Edge)** 감지라고 합니다.

### 코드

```python
# 파일명: ch04_button_once.py
from machine import Pin
import time

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)

previous_state = 0  # 이전 상태 저장 변수

print("버튼 A를 눌러보세요!")
print("(한 번 누르면 한 번만 출력됩니다)")
print()

while True:
    current_state = button_a.value()  # 현재 상태

    # 0에서 1로 변했을 때만 (상승 엣지)
    if previous_state == 0 and current_state == 1:
        print("✓ 버튼 A 눌림!")

    previous_state = current_state  # 현재 상태를 이전 상태로 저장
    time.sleep(0.05)  # 50ms 대기
```

### 코드 설명

```python
previous_state = 0
```

→ 이전 버튼 상태를 저장할 변수. 처음에는 0 (안 눌림).

```python
if previous_state == 0 and current_state == 1:
```

→ "이전에는 0이었고, 지금은 1이다" = "방금 눌렀다!"

```python
previous_state = current_state
```

→ 다음 반복을 위해 현재 상태를 저장.

### 실행하기

이제 버튼을 눌러보세요. 아무리 길게 눌러도 메시지가 한 번만 출력됩니다!

```
✓ 버튼 A 눌림!
```

버튼을 뗐다가 다시 누르면, 또 한 번 출력됩니다.

**완벽합니다!** 이제 버튼 카운터, 토글 스위치 등을 만들 수 있습니다.

---

## 실습 3: 두 개의 버튼 사용하기

### 목표

버튼 A와 B를 모두 사용하고, 동시에 누르는 것도 감지합니다.

### 코드

```python
# 파일명: ch04_dual_buttons.py
from machine import Pin
import time

# 두 버튼 설정
button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
button_b = Pin(34, Pin.IN, Pin.PULL_DOWN)

# 이전 상태 저장
prev_a = 0
prev_b = 0

print("=" * 40)
print("  헥사보드 버튼 테스트")
print("=" * 40)
print("버튼 A 또는 B를 눌러보세요!")
print("두 버튼을 동시에 누르면 특별한 메시지가 나옵니다.")
print()

while True:
    # 현재 상태 읽기
    curr_a = button_a.value()
    curr_b = button_b.value()

    # 버튼 A 눌림 감지
    if prev_a == 0 and curr_a == 1:
        print("🔵 버튼 A 눌림")

    # 버튼 B 눌림 감지
    if prev_b == 0 and curr_b == 1:
        print("🟢 버튼 B 눌림")

    # 두 버튼 동시 눌림 감지
    if curr_a == 1 and curr_b == 1:
        # 둘 중 하나라도 방금 눌렸다면
        if prev_a == 0 or prev_b == 0:
            print("🟣 A+B 동시 눌림! (콤보!)")

    # 상태 업데이트
    prev_a = curr_a
    prev_b = curr_b

    time.sleep(0.05)
```

### 실행하기

1. 버튼 A만 누르기 → "🔵 버튼 A 눌림"
2. 버튼 B만 누르기 → "🟢 버튼 B 눌림"
3. 두 버튼을 동시에 누르기 → "🟣 A+B 동시 눌림! (콤보!)"

### 응용 아이디어

이 패턴으로 다양한 것을 만들 수 있습니다:

- **게임 컨트롤러**: A = 점프, B = 공격, A+B = 특수 기술
- **메뉴 시스템**: A = 위로, B = 아래로, A+B = 선택
- **볼륨 조절**: A = 증가, B = 감소, A+B = 음소거

---

## 실습 4: 버튼 카운터 만들기

### 목표

버튼 A를 누를 때마다 숫자를 세고, 버튼 B를 누르면 리셋합니다.

### 코드

```python
# 파일명: ch04_button_counter.py
from machine import Pin
import time

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
button_b = Pin(34, Pin.IN, Pin.PULL_DOWN)

prev_a = 0
prev_b = 0
count = 0  # 카운터 변수

print("=" * 40)
print("  버튼 카운터")
print("=" * 40)
print("버튼 A: 카운트 증가")
print("버튼 B: 리셋")
print()
print(f"현재 카운트: {count}")

while True:
    curr_a = button_a.value()
    curr_b = button_b.value()

    # 버튼 A: 카운트 증가
    if prev_a == 0 and curr_a == 1:
        count += 1
        print(f"현재 카운트: {count}")

    # 버튼 B: 리셋
    if prev_b == 0 and curr_b == 1:
        count = 0
        print("🔄 리셋! 카운트: 0")

    prev_a = curr_a
    prev_b = curr_b
    time.sleep(0.05)
```

### 실행 결과

```
========================================
  버튼 카운터
========================================
버튼 A: 카운트 증가
버튼 B: 리셋

현재 카운트: 0
현재 카운트: 1
현재 카운트: 2
현재 카운트: 3
🔄 리셋! 카운트: 0
현재 카운트: 1
```

**축하합니다!** 여러분은 방금 상태를 가진 인터랙티브 시스템을 만들었습니다. 이것이 모든 복잡한 애플리케이션의 기초입니다!

---

## 버튼 디바운싱 (고급 주제)

### 버튼의 숨겨진 문제

실제 물리적 버튼은 완벽하지 않습니다. 버튼을 누르는 순간, 내부의 금속 접점이 여러 번 붙었다 떨어졌다를 반복합니다. 이를 **채터링(Chattering)** 또는 **바운싱(Bouncing)**이라고 합니다.

사람의 눈에는 한 번 누른 것처럼 보이지만, 마이크로컨트롤러는 수 밀리초 동안 여러 번의 눌림을 감지할 수 있습니다.

### 소프트웨어 디바운싱

우리가 사용한 `time.sleep(0.05)`는 간단한 디바운싱 역할을 합니다. 50ms마다 체크하므로, 그 사이의 채터링은 무시됩니다.

더 정교한 방법도 있습니다:

```python
# 파일명: ch04_debounce.py
from machine import Pin
import time

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)

last_press_time = 0
DEBOUNCE_MS = 200  # 200ms 디바운스 시간

print("디바운싱이 적용된 버튼 테스트")
print()

while True:
    if button_a.value() == 1:
        current_time = time.ticks_ms()  # 현재 시간 (밀리초)

        # 마지막 눌림으로부터 200ms 이상 지났는지 확인
        if time.ticks_diff(current_time, last_press_time) > DEBOUNCE_MS:
            print("✓ 버튼 눌림 (디바운스 적용)")
            last_press_time = current_time

    time.sleep(0.01)  # 10ms 체크
```

이 방법은 버튼을 눌러도 200ms 이내에는 다시 감지하지 않습니다. 실수로 두 번 누르는 것을 방지할 수 있죠!

---

## 문제 해결

### 문제 1: 버튼을 눌러도 반응이 없어요

**체크리스트**:

- [ ] USB 케이블이 제대로 연결되어 있나요?
- [ ] Thonny 하단에 "MicroPython (ESP32)"로 설정되어 있나요?
- [ ] 코드의 핀 번호가 맞나요? (버튼 A = 35, 버튼 B = 34)
- [ ] `Pin.PULL_DOWN`이 제대로 입력되었나요? (대소문자 확인)

**테스트 코드**:

```python
from machine import Pin
button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)

while True:
    print(button_a.value())  # 0 또는 1 출력
    time.sleep(0.5)
```

버튼을 누르면 1, 안 누르면 0이 출력되어야 합니다.

### 문제 2: 한 번 눌렀는데 여러 번 감지돼요

**해결 방법**:

- `time.sleep()` 값을 늘려보세요 (0.1 또는 0.2)
- 디바운싱 코드를 사용하세요 (위 참조)

### 문제 3: 버튼을 누르지 않았는데 계속 눌린 것으로 나와요

**원인**: Pull-down이 제대로 설정되지 않았거나, 버튼이 물리적으로 고장났을 수 있습니다.

**해결 방법**:

- 코드에 `Pin.PULL_DOWN`이 있는지 확인
- 다른 버튼으로 테스트 (버튼 B)
- 헥사보드를 재부팅 (USB 뽑았다가 다시 연결)

### 문제 4: ImportError: no module named 'machine'

**원인**: 일반 Python으로 실행하려고 했습니다.

**해결 방법**:

- Thonny 우측 하단에서 "MicroPython (ESP32)" 선택
- 헥사보드가 USB로 연결되어 있는지 확인

---

## 핵심 요약

### 오늘 배운 개념

1. **디지털 입력**: 0 또는 1, 두 가지 상태만 가짐
2. **GPIO**: 입력/출력을 자유롭게 설정할 수 있는 범용 핀
3. **Pull-down**: 버튼을 누르지 않으면 0, 누르면 1
4. **엣지 감지**: 상태 변화를 감지하여 한 번만 반응
5. **디바운싱**: 버튼의 채터링을 소프트웨어로 제거

### 핵심 코드 패턴

**버튼 설정**:

```python
button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
```

**버튼 읽기**:

```python
if button_a.value() == 1:
    print("눌림")
```

**엣지 감지** (한 번만 반응):

```python
prev = 0
while True:
    curr = button_a.value()
    if prev == 0 and curr == 1:
        print("눌림!")
    prev = curr
    time.sleep(0.05)
```

---

## 도전 과제

### 과제 1: 토글 스위치 ⭐️

버튼 A를 누를 때마다 LED가 켜졌다 꺼졌다 하는 프로그램을 만드세요.

**힌트**:

```python
led_state = False

# 버튼이 눌렸을 때
led_state = not led_state  # True ↔ False 토글
if led_state:
    led.on()
else:
    led.off()
```

### 과제 2: 스톱워치 ⭐️⭐️

- 버튼 A: 스톱워치 시작/정지
- 버튼 B: 리셋

**힌트**: `time.ticks_ms()`로 시간 측정

### 과제 3: 반응 속도 게임 ⭐️⭐️⭐️

1. 프로그램이 "준비..." 출력
2. 랜덤 시간 후 "지금!" 출력
3. 버튼 A를 누르면 반응 시간 측정
4. "당신의 반응 속도: 0.234초" 출력

**힌트**: `import random`, `random.uniform(1, 3)`

---

## 다음 단계

버튼 입력을 마스터했습니다! 🎉

이제 여러분은:

- 버튼 상태를 읽을 수 있습니다
- 눌림 순간을 정확히 감지할 수 있습니다
- 여러 버튼을 동시에 다룰 수 있습니다
- 카운터, 토글 등 상태를 가진 시스템을 만들 수 있습니다

다음 챕터에서는 **출력**의 진수를 보여드립니다: **네오픽셀 LED**!

6개의 RGB LED를 개별적으로 제어하여 무지개 색상, 애니메이션, 상태 표시 등을 만들어봅니다. 화려한 시각 효과의 세계로 들어갑니다!

**준비되셨나요? Let's go!** 🚀

---

**다음 챕터 예고**  
Chapter 5 - 네오픽셀 LED: 6개의 RGB LED로 빛의 마법 만들기

빨강, 초록, 파랑을 섞으면 1,677만 가지 색상을 만들 수 있습니다. 헥사보드의 6개 네오픽셀로 무엇을 표현할 수 있을까요?

---

# Chapter 5. 네오픽셀 기초 – 빛의 마법 시작하기

> **PART 2**: 헥사보드 기본 제어 – 버튼과 네오픽셀

---

## 빛으로 말하기

인간은 시각적 동물입니다. 우리가 받아들이는 정보의 80% 이상이 시각을 통해 들어옵니다. 그래서 LED는 IoT 장치에서 가장 강력한 출력 수단입니다.

신호등의 빨간불, 스마트폰 충전 중의 작은 LED, 게이밍 키보드의 화려한 RGB 조명... 모두 LED로 상태와 정보를 전달합니다.

헥사보드에는 특별한 LED가 있습니다: **네오픽셀(NeoPixel)**. 정식 명칭은 WS2812B이지만, Adafruit사가 만든 "NeoPixel"이라는 이름이 더 유명해졌죠.

네오픽셀의 마법:

- **1,677만 가지 색상**: RGB 각각 256단계 (256 × 256 × 256)
- **개별 제어**: 25개 LED를 각각 다른 색으로
- **간단한 연결**: 단 하나의 GPIO 핀으로 모든 LED 제어
- **체인 연결**: 수백 개를 연결해도 제어 가능

이 챕터에서는 네오픽셀의 기초를 배우고, 색상을 자유자재로 다루며, 간단한 애니메이션까지 만들어봅니다!

**예상 소요 시간**: 40분

---

## RGB: 빛의 3원색

### 가산 혼합의 원리

초등학교 미술 시간에 배운 것을 기억하시나요? 물감을 섞으면:

- 빨강 + 노랑 = 주황
- 빨강 + 파랑 = 보라
- 모든 색을 섞으면 = 검은색 (또는 갈색)

이것은 **감산 혼합**입니다. 물감은 빛을 흡수하기 때문이죠.

하지만 LED는 **빛**을 만듭니다. 빛의 혼합은 정반대입니다:

- 빨강 + 초록 = 노랑 (놀랍죠!)
- 빨강 + 파랑 = 마젠타(자홍)
- 초록 + 파랑 = 시안(청록)
- **모든 색을 섞으면 = 흰색!**

이것이 **가산 혼합**입니다.

### RGB 모델

컴퓨터 화면, TV, 스마트폰, 그리고 네오픽셀은 모두 RGB 모델을 사용합니다:

- **R (Red)**: 빨강, 0~255
- **G (Green)**: 초록, 0~255
- **B (Blue)**: 파랑, 0~255

각 색상을 0(꺼짐)부터 255(최대 밝기)까지 조절할 수 있습니다.

**예시**:

```python
(255, 0, 0)    # 순수한 빨강
(0, 255, 0)    # 순수한 초록
(0, 0, 255)    # 순수한 파랑
(255, 255, 0)  # 빨강 + 초록 = 노랑
(255, 0, 255)  # 빨강 + 파랑 = 마젠타
(0, 255, 255)  # 초록 + 파랑 = 시안
(255, 255, 255)# 모두 = 흰색
(128, 128, 128)# 모두 50% = 회색
(0, 0, 0)      # 모두 꺼짐 = 검정
```

### 왜 255일까?

컴퓨터는 2진수를 사용합니다. 8비트(1바이트)로 표현할 수 있는 숫자의 범위는:

- 0부터 255까지 (총 256개)

RGB 각각 1바이트 = 총 3바이트 = 24비트 컬러 = 16,777,216가지 색상!

---

## 네오픽셀의 작동 원리

### WS2812B 칩

각 네오픽셀 LED 안에는 작은 칩이 들어있습니다. 이 칩이:

- 데이터를 받아서 해석
- 자신의 색상을 설정
- 나머지 데이터를 다음 LED로 전달

### 체인 연결 (Daisy Chain)

헥사보드의 25개 LED는 다음과 같이 연결됩니다:

```
GPIO 23 → LED 0 → LED 1 → LED 2 → ... → LED 24
```

데이터가 한 방향으로 흐릅니다. 첫 번째 LED가 자신의 데이터를 받으면, 나머지를 다음 LED로 전달합니다.

이 방식의 장점:

- **단순함**: 하나의 GPIO 핀으로 수백 개 제어 가능
- **확장성**: LED를 추가하기 쉬움
- **개별 제어**: 각 LED를 독립적으로 제어

### 헥사보드의 네오픽셀 배치

헥사보드에는 **25개**(5×5)의 네오픽셀이 있습니다:

```
네오픽셀 인덱스 (5×5 그리드)
┌─────────────────────┐
│  0   1   2   3   4  │
│  5   6   7   8   9  │
│ 10  11  12  13  14  │
│ 15  16  17  18  19  │
│ 20  21  22  23  24  │
└─────────────────────┘
```

- **GPIO 핀**: 23번
- **인덱스**: 0번부터 24번까지 (프로그래밍은 0부터 시작!)
- **순서**: 왼쪽 위(0)에서 시작, 오른쪽으로, 다음 줄로

---

## 실습 준비

### 필요한 것

- 헥사보드 × 1
- USB 케이블 × 1
- Thonny IDE

### 안전 주의사항

네오픽셀은 밝습니다. 특히 흰색(255, 255, 255)은 **매우 밝습니다**!

- 처음에는 낮은 밝기(50~100)로 시작하세요
- 직접 쳐다보지 마세요
- 어두운 곳에서는 더욱 조심하세요

---

## 실습 1: 첫 번째 네오픽셀 켜기

### 목표

0번 LED를 빨간색으로 켭니다.

### 코드

```python
# 파일명: ch05_neopixel_one.py
from machine import Pin
import neopixel

# 네오픽셀 설정
NUM_LEDS = 25  # 총 LED 개수
PIN = 23       # GPIO 핀 번호

# 네오픽셀 객체 생성
np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

# 0번 LED를 빨간색으로 설정
np[0] = (255, 0, 0)  # (R, G, B)

# 실제로 LED에 전송!
np.write()

print("0번 LED가 빨간색으로 켜졌습니다!")
print("프로그램을 종료해도 LED는 계속 켜져 있습니다.")
```

### 코드 설명

```python
import neopixel
```

→ MicroPython의 네오픽셀 라이브러리를 가져옵니다.

```python
np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)
```

→ 네오픽셀 객체를 생성합니다. `np`라는 변수로 모든 LED를 제어할 수 있습니다.

```python
np[0] = (255, 0, 0)
```

→ 0번 LED의 색상을 설정합니다. 리스트처럼 인덱스로 접근!
→ `(255, 0, 0)` = 빨강 최대, 초록 0, 파랑 0 = 순수한 빨강

```python
np.write()
```

→ **매우 중요!** 설정한 색상을 실제 LED에 전송합니다.
→ 이 명령이 없으면 LED가 켜지지 않습니다!

### 실행하기

1. 코드를 Thonny에 입력
2. F5 또는 ▶️ 실행
3. 헥사보드의 왼쪽 위 LED(0번)가 빨간색으로 켜집니다!

### 실험해보기

색상을 바꿔보세요:

```python
np[0] = (0, 255, 0)  # 초록
np.write()
```

```python
np[0] = (0, 0, 255)  # 파랑
np.write()
```

```python
np[0] = (255, 255, 0)  # 노랑 (빨강 + 초록)
np.write()
```

---

## 실습 2: 색상 변화 애니메이션

### 목표

0번 LED가 여러 색상으로 순환합니다.

### 코드

```python
# 파일명: ch05_neopixel_colors.py
from machine import Pin
import neopixel
import time

NUM_LEDS = 25
PIN = 23

np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

# 색상 목록 정의
colors = [
    (255, 0, 0),      # 빨강
    (255, 128, 0),    # 주황
    (255, 255, 0),    # 노랑
    (0, 255, 0),      # 초록
    (0, 255, 255),    # 시안
    (0, 0, 255),      # 파랑
    (128, 0, 255),    # 보라
    (255, 0, 255),    # 마젠타
    (255, 255, 255),  # 흰색
]

color_names = [
    "빨강", "주황", "노랑", "초록",
    "시안", "파랑", "보라", "마젠타", "흰색"
]

print("색상 변화 시작!")
print("Ctrl+C로 종료하세요")
print()

# 색상 순환
for i, color in enumerate(colors):
    np[0] = color
    np.write()
    print(f"{color_names[i]}: {color}")
    time.sleep(1)

# 끄기
np[0] = (0, 0, 0)
np.write()
print("\n완료!")
```

### 실행 결과

0번 LED가 1초마다 색상이 바뀌며, Shell 창에 색상 이름이 출력됩니다:

```
색상 변화 시작!
Ctrl+C로 종료하세요

빨강: (255, 0, 0)
주황: (255, 128, 0)
노랑: (255, 255, 0)
...
```

**아름답죠?** 이것이 RGB의 힘입니다!

---

## 실습 3: 여러 LED 동시에 켜기

### 목표

첫 줄의 5개 LED를 서로 다른 색으로 켭니다.

### 코드

```python
# 파일명: ch05_neopixel_multiple.py
from machine import Pin
import neopixel
import time

NUM_LEDS = 25
PIN = 23

np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

# 첫 줄 5개 LED를 무지개 색으로
np[0] = (255, 0, 0)      # 빨강
np[1] = (255, 128, 0)    # 주황
np[2] = (255, 255, 0)    # 노랑
np[3] = (0, 255, 0)      # 초록
np[4] = (0, 0, 255)      # 파랑

# 한 번에 전송!
np.write()

print("무지개 첫 줄 완성!")
print("🔴 🟠 🟡 🟢 🔵")
print()
print("프로그램을 종료해도 LED는 계속 켜져 있습니다.")
```

### 결과

```
헥사보드 화면:
┌──────────────────────┐
│ 🔴 🟠 🟡 🟢 🔵 │  ← 무지개!
│ ░  ░  ░  ░  ░  │
│ ░  ░  ░  ░  ░  │
│ ░  ░  ░  ░  ░  │
│ ░  ░  ░  ░  ░  │
└──────────────────────┘
```

**핵심**: 여러 LED를 설정한 후, `np.write()`를 **한 번만** 호출하면 모두 동시에 업데이트됩니다!

---

## 실습 4: 전체 LED 제어하기

### 목표

25개 LED를 모두 같은 색으로 채웁니다.

### 코드

```python
# 파일명: ch05_neopixel_fill.py
from machine import Pin
import neopixel
import time

NUM_LEDS = 25
PIN = 23

np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

def fill(color):
    """모든 LED를 같은 색으로 채우는 함수"""
    for i in range(NUM_LEDS):
        np[i] = color
    np.write()

def clear():
    """모든 LED를 끄는 함수"""
    fill((0, 0, 0))

# 빨간색으로 채우기
print("빨간색 채우기...")
fill((100, 0, 0))  # 밝기 낮춤 (눈 보호)
time.sleep(2)

# 초록색으로 채우기
print("초록색 채우기...")
fill((0, 100, 0))
time.sleep(2)

# 파란색으로 채우기
print("파란색 채우기...")
fill((0, 0, 100))
time.sleep(2)

# 끄기
print("끄기...")
clear()
print("완료!")
```

### 코드 설명

```python
def fill(color):
    for i in range(NUM_LEDS):
        np[i] = color
    np.write()
```

→ 함수로 만들면 재사용하기 쉽습니다!
→ `range(NUM_LEDS)`는 0부터 24까지 반복

**주의**: 밝기를 100으로 낮췄습니다 (255 대신). 전체 LED를 최대 밝기로 켜면 눈이 부실 수 있고, 전력 소모도 큽니다!

---

## 실습 5: 웨이브 애니메이션

### 목표

LED가 순서대로 켜지면서 이동하는 효과를 만듭니다.

### 코드

```python
# 파일명: ch05_neopixel_wave.py
from machine import Pin
import neopixel
import time

NUM_LEDS = 25
PIN = 23

np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

# 모두 끄기
for i in range(NUM_LEDS):
    np[i] = (0, 0, 0)
np.write()

print("웨이브 애니메이션 시작!")
print("Ctrl+C로 종료하세요")
print()

# 무한 반복
while True:
    # 앞으로 이동
    for i in range(NUM_LEDS):
        # 이전 LED 끄기
        if i > 0:
            np[i-1] = (0, 0, 0)

        # 현재 LED 켜기
        np[i] = (0, 100, 0)  # 초록색
        np.write()

        time.sleep(0.05)  # 50ms 대기

    # 마지막 LED 끄기
    np[NUM_LEDS-1] = (0, 0, 0)
    np.write()

    time.sleep(0.3)  # 잠시 대기 후 반복
```

### 실행 결과

초록색 LED가 0번부터 24번까지 순서대로 이동합니다. 마치 물결처럼!

**응용**: `time.sleep(0.05)`를 `0.01`로 바꾸면 더 빠르게, `0.1`로 바꾸면 더 느리게 움직입니다.

---

## 실습 6: 밝기 조절 (페이드 효과)

### 목표

LED가 서서히 밝아졌다가 어두워지는 효과를 만듭니다.

### 코드

```python
# 파일명: ch05_neopixel_fade.py
from machine import Pin
import neopixel
import time

NUM_LEDS = 25
PIN = 23

np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

def set_all(color):
    """모든 LED를 같은 색으로"""
    for i in range(NUM_LEDS):
        np[i] = color
    np.write()

print("페이드 효과 시작!")
print("Ctrl+C로 종료하세요")
print()

while True:
    # 서서히 밝아지기 (0 → 100)
    for brightness in range(0, 101, 5):
        set_all((brightness, 0, brightness))  # 보라색
        time.sleep(0.05)

    # 서서히 어두워지기 (100 → 0)
    for brightness in range(100, -1, -5):
        set_all((brightness, 0, brightness))  # 보라색
        time.sleep(0.05)
```

### 실행 결과

모든 LED가 보라색으로 서서히 밝아졌다가 어두워지는 것을 반복합니다. 마치 숨쉬는 것처럼!

**핵심**: RGB 값을 점진적으로 변경하면 부드러운 애니메이션을 만들 수 있습니다.

---

## 문제 해결

### 문제 1: LED가 전혀 안 켜져요

**체크리스트**:

- [ ] `np.write()`를 호출했나요? (가장 흔한 실수!)
- [ ] 핀 번호가 23번이 맞나요?
- [ ] USB 케이블이 연결되어 있나요?
- [ ] 헥사보드가 MicroPython으로 설정되어 있나요?

**테스트 코드**:

```python
from machine import Pin
import neopixel

np = neopixel.NeoPixel(Pin(23), 25)
np[0] = (100, 0, 0)
np.write()  # 이 줄이 꼭 필요!
```

### 문제 2: 색이 이상해요 (원하는 색이 안 나와요)

**원인**: RGB 순서를 잘못 입력했을 수 있습니다.

**해결**:

- 순서는 항상 **(R, G, B)**
- 각 값은 **0~255** 범위

```python
# 올바른 예
np[0] = (255, 0, 0)    # 빨강 ✅
np[0] = (0, 255, 0)    # 초록 ✅
np[0] = (0, 0, 255)    # 파랑 ✅

# 잘못된 예
np[0] = (0, 0, 255, 0)  # 4개 값 ❌
np[0] = (300, 0, 0)     # 255 초과 ❌
np[0] = 255             # 튜플이 아님 ❌
```

### 문제 3: 너무 밝아서 눈이 아파요

**해결**: 밝기를 낮추세요!

```python
# 최대 밝기 (눈 아픔!)
np[0] = (255, 255, 255)

# 50% 밝기 (적당함)
np[0] = (128, 128, 128)

# 20% 밝기 (편안함)
np[0] = (50, 50, 50)
```

**팁**: 개발할 때는 50~100 정도로 시작하세요. 나중에 필요하면 밝기를 높이면 됩니다.

### 문제 4: 일부 LED만 이상하게 동작해요

**원인**: 이전 코드의 설정이 남아있을 수 있습니다.

**해결**: 프로그램 시작 시 모든 LED를 끄세요.

```python
# 프로그램 시작 시
for i in range(NUM_LEDS):
    np[i] = (0, 0, 0)
np.write()
```

---

## 핵심 요약

### 오늘 배운 개념

1. **RGB 색상 모델**: (R, G, B) 튜플로 1,677만 가지 색상 표현
2. **네오픽셀 초기화**: `neopixel.NeoPixel(Pin(핀번호), LED개수)`
3. **색상 설정**: `np[인덱스] = (R, G, B)`
4. **전송**: `np.write()` - 반드시 호출해야 LED가 켜짐!
5. **밝기 조절**: RGB 값을 낮추면 어두워짐
6. **애니메이션**: 반복문 + 시간 지연으로 움직이는 효과

### 핵심 코드 패턴

**기본 설정**:

```python
from machine import Pin
import neopixel

np = neopixel.NeoPixel(Pin(23), 25)
```

**LED 켜기**:

```python
np[0] = (255, 0, 0)  # 빨간색
np.write()           # 전송!
```

**모두 채우기**:

```python
for i in range(25):
    np[i] = (0, 100, 0)  # 초록색
np.write()
```

**모두 끄기**:

```python
for i in range(25):
    np[i] = (0, 0, 0)
np.write()
```

---

## 색상 참고표

실전에서 자주 사용하는 색상들:

```python
# 기본 색상 (밝기 100)
RED     = (100, 0, 0)
GREEN   = (0, 100, 0)
BLUE    = (0, 0, 100)
YELLOW  = (100, 100, 0)
CYAN    = (0, 100, 100)
MAGENTA = (100, 0, 100)
WHITE   = (100, 100, 100)
OFF     = (0, 0, 0)

# 파스텔 톤
PINK    = (100, 50, 50)
MINT    = (50, 100, 50)
LAVENDER= (50, 50, 100)
PEACH   = (100, 70, 50)

# 어두운 톤 (상태 표시용)
DIM_RED = (20, 0, 0)
DIM_GREEN = (0, 20, 0)
DIM_BLUE = (0, 0, 20)
```

---

## 도전 과제

### 과제 1: 신호등 만들기 ⭐️

0번, 1번, 2번 LED를 사용하여 신호등을 만드세요:

- 0번: 빨강 (2초)
- 1번: 노랑 (1초)
- 2번: 초록 (2초)
- 반복

### 과제 2: 십자가 패턴 ⭐️⭐️

5×5 그리드에서 가운데 십자(+) 모양만 켜세요:

```
░ ░ 🔴 ░ ░
░ ░ 🔴 ░ ░
🔴🔴🔴🔴🔴
░ ░ 🔴 ░ ░
░ ░ 🔴 ░ ░
```

**힌트**:

- 세로 줄: 2, 7, 12, 17, 22번
- 가로 줄: 10, 11, 12, 13, 14번

### 과제 3: 무지개 회전 ⭐️⭐️⭐️

첫 줄 5개 LED에 무지개 색을 표시하고, 1초마다 오른쪽으로 회전시키세요.

```
시작: 🔴 🟠 🟡 🟢 🔵
1초 후: 🔵 🔴 🟠 🟡 🟢
2초 후: 🟢 🔵 🔴 🟠 🟡
...
```

**힌트**: 리스트의 마지막 요소를 맨 앞으로 이동

---

## 다음 단계

네오픽셀 기초를 마스터했습니다! 🎉

이제 여러분은:

- RGB 색상 모델을 이해합니다
- 개별 LED를 제어할 수 있습니다
- 전체 LED를 한 번에 제어할 수 있습니다
- 간단한 애니메이션을 만들 수 있습니다
- 밝기를 조절할 수 있습니다

다음 챕터에서는 **버튼과 네오픽셀을 결합**합니다!

버튼을 누르면 LED 패턴이 바뀌고, 상태에 따라 다른 색상을 표시하는 **상태 머신(State Machine)**을 만들어봅니다. 진짜 인터랙티브 시스템의 시작입니다!

**준비되셨나요? Let's create!** 🚀

---

**다음 챕터 예고**  
Chapter 6 - 상태 머신: 버튼과 LED로 만드는 인터랙티브 시스템

버튼을 누르면 모드가 바뀌고, 각 모드마다 다른 LED 패턴이 표시됩니다. 신호등, 게임, 메뉴 시스템... 모든 것의 기초가 되는 상태 머신을 배웁니다!

---

# Chapter 6. 상태 머신: 인터랙티브 시스템의 핵심

> **PART 2**: 헥사보드 기본 제어 – 버튼과 네오픽셀

---

## 상태를 기억하는 시스템

지금까지 우리는 입력(버튼)과 출력(LED)을 각각 배웠습니다. 이제 이 둘을 결합할 시간입니다!

하지만 단순히 "버튼을 누르면 LED가 켜진다"를 넘어서, **상태를 기억하고 관리하는** 시스템을 만들어야 합니다. 이것이 바로 **상태 머신(State Machine)**입니다.

### 일상 속의 상태 머신

상태 머신은 우리 주변 어디에나 있습니다:

**신호등**:

- 상태: 빨강 → 초록 → 노랑 → 빨강 (순환)
- 전환: 시간 경과

**엘리베이터**:

- 상태: 정지, 상승, 하강, 문 열림, 문 닫힘
- 전환: 버튼 입력, 센서 감지

**게임 캐릭터**:

- 상태: 서있기, 걷기, 뛰기, 점프, 공격
- 전환: 키보드/조이스틱 입력

**스마트폰 화면**:

- 상태: 꺼짐, 잠금 화면, 홈 화면, 앱 실행 중
- 전환: 버튼, 터치, 시간 경과

모든 인터랙티브 시스템의 핵심은 상태 머신입니다!

### 상태 머신의 3요소

1. **상태(State)**: 시스템이 현재 어떤 모드에 있는가?
2. **전환(Transition)**: 어떤 조건에서 상태가 바뀌는가?
3. **동작(Action)**: 각 상태에서 무엇을 하는가?

**예시**: 전등 스위치

```
상태: [꺼짐] ↔ [켜짐]
전환: 버튼 누름
동작:
  - 꺼짐 상태: LED OFF
  - 켜짐 상태: LED ON
```

이 챕터에서는 버튼과 네오픽셀을 사용하여 다양한 상태 머신을 만들어봅니다!

**예상 소요 시간**: 40분

---

## 상태 머신 설계 방법

### 1. 상태 다이어그램 그리기

코드를 작성하기 전에, 상태 다이어그램을 그려보는 것이 좋습니다.

**예시**: 3색 순환 시스템

```
    버튼 A
    ↓
[빨강] → [초록] → [파랑]
  ↑                 ↓
  └─────────────────┘
       버튼 A
```

### 2. 상태 변수 정의

```python
# 방법 1: 문자열
state = "red"

# 방법 2: 숫자
state = 0  # 0=빨강, 1=초록, 2=파랑

# 방법 3: 리스트 인덱스
colors = [(255,0,0), (0,255,0), (0,0,255)]
state_index = 0
```

### 3. 전환 조건 구현

```python
# 버튼이 눌렸을 때
if button_pressed:
    # 상태 전환
    if state == "red":
        state = "green"
    elif state == "green":
        state = "blue"
    elif state == "blue":
        state = "red"
```

### 4. 각 상태의 동작 구현

```python
# 현재 상태에 따라 LED 제어
if state == "red":
    fill((255, 0, 0))
elif state == "green":
    fill((0, 255, 0))
elif state == "blue":
    fill((0, 0, 255))
```

---

## 실습 1: 토글 스위치 (2상태)

### 목표

버튼 A를 누를 때마다 LED가 켜졌다 꺼졌다 합니다.

### 상태 다이어그램

```
[꺼짐] ↔ [켜짐]
  ↑      ↓
  버튼 A
```

### 코드

```python
# 파일명: ch06_toggle.py
from machine import Pin
import neopixel
import time

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
np = neopixel.NeoPixel(Pin(23), 25)

# 상태 변수
is_on = False
prev_button = 0

def fill(color):
    for i in range(25):
        np[i] = color
    np.write()

print("토글 스위치")
print("버튼 A: LED 켜기/끄기")
print()

# 초기 상태: 꺼짐
fill((0, 0, 0))

while True:
    curr_button = button_a.value()

    # 버튼 눌림 감지 (엣지)
    if prev_button == 0 and curr_button == 1:
        # 상태 전환
        is_on = not is_on  # True ↔ False

        # 동작 수행
        if is_on:
            fill((0, 100, 0))  # 초록색
            print("✓ LED ON")
        else:
            fill((0, 0, 0))  # 끄기
            print("✗ LED OFF")

    prev_button = curr_button
    time.sleep(0.05)
```

**핵심**: `is_on = not is_on` - 불리언 값을 반전시키는 간단한 토글!

---

## 실습 2: 3색 순환 (3상태)

### 목표

버튼 A를 누를 때마다 빨강 → 초록 → 파랑 → 빨강... 순환합니다.

### 코드

```python
# 파일명: ch06_color_cycle.py
from machine import Pin
import neopixel
import time

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
np = neopixel.NeoPixel(Pin(23), 25)

# 색상 정의
colors = [
    (100, 0, 0),    # 빨강
    (0, 100, 0),    # 초록
    (0, 0, 100)     # 파랑
]
color_names = ["빨강", "초록", "파랑"]

# 상태 변수
state = 0  # 0, 1, 2
prev_button = 0

def fill(color):
    for i in range(25):
        np[i] = color
    np.write()

print("3색 순환 시스템")
print("버튼 A: 다음 색상")
print()

# 초기 색상
fill(colors[state])
print(f"현재 색상: {color_names[state]}")

while True:
    curr_button = button_a.value()

    if prev_button == 0 and curr_button == 1:
        # 상태 전환 (순환)
        state = (state + 1) % 3  # 0→1→2→0

        # 동작 수행
        fill(colors[state])
        print(f"현재 색상: {color_names[state]}")

    prev_button = curr_button
    time.sleep(0.05)
```

**핵심**: `(state + 1) % 3` - 모듈로 연산으로 순환 구현!

---

## 실습 3: 두 버튼 제어 (복합 상태)

### 목표

- 버튼 A: 색상 변경
- 버튼 B: 밝기 변경

### 코드

```python
# 파일명: ch06_dual_control.py
from machine import Pin
import neopixel
import time

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
button_b = Pin(34, Pin.IN, Pin.PULL_DOWN)
np = neopixel.NeoPixel(Pin(23), 25)

# 색상 상태
colors = [(255, 0, 0), (0, 255, 0), (0, 0, 255)]
color_index = 0

# 밝기 상태
brightness_levels = [0.2, 0.5, 1.0]  # 20%, 50%, 100%
brightness_index = 1  # 기본 50%

prev_a = 0
prev_b = 0

def fill_with_brightness(color, brightness):
    adjusted = tuple(int(c * brightness) for c in color)
    for i in range(25):
        np[i] = adjusted
    np.write()

def update_display():
    fill_with_brightness(colors[color_index], brightness_levels[brightness_index])
    print(f"색상: {color_index}, 밝기: {int(brightness_levels[brightness_index]*100)}%")

print("이중 제어 시스템")
print("버튼 A: 색상 변경")
print("버튼 B: 밝기 변경")
print()

update_display()

while True:
    curr_a = button_a.value()
    curr_b = button_b.value()

    # 버튼 A: 색상 변경
    if prev_a == 0 and curr_a == 1:
        color_index = (color_index + 1) % 3
        update_display()

    # 버튼 B: 밝기 변경
    if prev_b == 0 and curr_b == 1:
        brightness_index = (brightness_index + 1) % 3
        update_display()

    prev_a = curr_a
    prev_b = curr_b
    time.sleep(0.05)
```

**핵심**: 두 개의 독립적인 상태 변수를 관리!

---

## 실습 4: 간단한 게임 - 반응 속도 테스트

### 목표

LED가 랜덤 시간 후에 초록색으로 바뀌면, 최대한 빠르게 버튼을 누릅니다.

### 코드

```python
# 파일명: ch06_reaction_game.py
from machine import Pin
import neopixel
import time
import random

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
np = neopixel.NeoPixel(Pin(23), 25)

def fill(color):
    for i in range(25):
        np[i] = color
    np.write()

def wait_for_button():
    """버튼이 눌릴 때까지 대기"""
    while button_a.value() == 0:
        time.sleep(0.01)

print("=" * 40)
print("  반응 속도 테스트 게임")
print("=" * 40)
print("초록불이 켜지면 최대한 빠르게 버튼 A를 누르세요!")
print()

while True:
    # 준비 상태 (빨간색)
    fill((100, 0, 0))
    print("준비...")
    time.sleep(1)

    # 랜덤 대기 (1~3초)
    wait_time = random.uniform(1, 3)
    time.sleep(wait_time)

    # 시작! (초록색)
    fill((0, 100, 0))
    start_time = time.ticks_ms()
    print("지금!")

    # 버튼 누르기 대기
    wait_for_button()
    end_time = time.ticks_ms()

    # 반응 시간 계산
    reaction_time = time.ticks_diff(end_time, start_time)

    # 결과 표시 (파란색)
    fill((0, 0, 100))
    print(f"반응 시간: {reaction_time}ms")

    # 평가
    if reaction_time < 200:
        print("🏆 대단해요! 매우 빠릅니다!")
    elif reaction_time < 300:
        print("👍 좋아요!")
    elif reaction_time < 500:
        print("😊 괜찮아요!")
    else:
        print("🐢 좀 더 빨리!")

    print()
    time.sleep(2)
```

**재미있죠?** 이것이 상태 머신의 힘입니다!

---

## 고급: 유한 상태 기계 (FSM) 패턴

### 더 복잡한 시스템을 위한 구조화

많은 상태를 다룰 때는 딕셔너리를 사용하면 깔끔합니다:

```python
# 파일명: ch06_fsm_pattern.py
from machine import Pin
import neopixel
import time

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
np = neopixel.NeoPixel(Pin(23), 25)

# 상태 정의
STATES = {
    "OFF": {
        "color": (0, 0, 0),
        "next": "RED",
        "name": "꺼짐"
    },
    "RED": {
        "color": (100, 0, 0),
        "next": "GREEN",
        "name": "빨강"
    },
    "GREEN": {
        "color": (0, 100, 0),
        "next": "BLUE",
        "name": "초록"
    },
    "BLUE": {
        "color": (0, 0, 100),
        "next": "OFF",
        "name": "파랑"
    }
}

current_state = "OFF"
prev_button = 0

def fill(color):
    for i in range(25):
        np[i] = color
    np.write()

def enter_state(state_name):
    """상태 진입 시 실행"""
    global current_state
    current_state = state_name
    state = STATES[state_name]
    fill(state["color"])
    print(f"→ {state['name']}")

print("FSM 패턴 데모")
print("버튼 A: 다음 상태")
print()

enter_state(current_state)

while True:
    curr_button = button_a.value()

    if prev_button == 0 and curr_button == 1:
        # 다음 상태로 전환
        next_state = STATES[current_state]["next"]
        enter_state(next_state)

    prev_button = curr_button
    time.sleep(0.05)
```

**장점**:

- 상태 추가/수정이 쉬움
- 코드가 깔끔하고 읽기 쉬움
- 확장 가능

---

## 핵심 요약

### 상태 머신의 핵심 개념

1. **상태(State)**: 시스템의 현재 모드
2. **전환(Transition)**: 상태 변경 조건
3. **동작(Action)**: 각 상태에서의 행동

### 구현 패턴

**간단한 방법** (2-3개 상태):

```python
state = 0
if button_pressed:
    state = (state + 1) % 3
```

**딕셔너리 방법** (많은 상태):

```python
STATES = {"OFF": {...}, "ON": {...}}
current_state = "OFF"
```

### 중요한 팁

- 상태 다이어그램을 먼저 그리세요
- 각 상태의 진입/퇴출 동작을 명확히 하세요
- 예외 상황(불가능한 전환)을 고려하세요

---

## 도전 과제

### 과제 1: 신호등 시뮬레이터 ⭐️⭐️

자동으로 변하는 신호등을 만드세요:

- 빨강 (5초) → 초록 (5초) → 노랑 (2초) → 빨강
- 버튼 A: 일시정지/재개

### 과제 2: 디지털 주사위 ⭐️⭐️⭐️

버튼을 누르면 LED가 빠르게 변하다가 멈춰서 1~6 중 하나를 표시:

- 1: 중앙 1개
- 2: 대각선 2개
- 3: 대각선 3개
- ...

### 과제 3: 간단한 메뉴 시스템 ⭐️⭐️⭐️

- 버튼 A: 메뉴 이동 (빨강, 초록, 파랑)
- 버튼 B: 선택
- 선택하면 해당 색상으로 전체 LED 깜빡임

---

## 다음 단계

상태 머신을 마스터했습니다! 🎉

이제 여러분은:

- 상태를 관리하는 시스템을 설계할 수 있습니다
- 버튼과 LED를 결합한 인터랙티브 장치를 만들 수 있습니다
- 간단한 게임과 애플리케이션을 구현할 수 있습니다

**Part 2 완료!** 버튼과 네오픽셀의 기초를 모두 배웠습니다.

다음 Part 3에서는 **센서**의 세계로 들어갑니다:

- 온습도 센서로 환경 측정
- 조도 센서로 빛의 밝기 감지
- 센서 데이터 처리와 시각화

실제 세계의 정보를 읽어들이는 법을 배웁니다!

**준비되셨나요? 센서의 세계로!** 🌡️💡

---

**다음 챕터 예고**  
Chapter 7 - DHT11 온습도 센서: 보이지 않는 것을 측정하기

온도와 습도는 어떻게 측정할까요? DHT11 센서의 원리부터 실제 데이터 읽기까지, 센서의 세계를 탐험합니다!

---

# PART 3: 센서로 세상을 읽다 – 온습도와 빛

# Chapter 7. DHT11 온습도 센서: 보이지 않는 것을 측정하기

> **PART 3**: 센서로 세상을 읽다 – 온습도와 빛

---

## 보이지 않는 것을 보는 능력

온도와 습도는 우리 주변 어디에나 있지만, 눈으로 볼 수 없습니다. 하지만 우리는 느낄 수 있죠. "오늘 덥다", "습하다", "쾌적하다"...

IoT의 핵심은 이런 **보이지 않는 정보를 측정하고 수치화**하는 것입니다. 그래야 기록하고, 분석하고, 자동으로 제어할 수 있습니다.

이 챕터에서는 **DHT11 온습도 센서**를 사용하여:

- 온도와 습도를 측정하는 원리 이해
- 센서를 헥사보드에 연결
- 실시간으로 데이터 읽기
- 측정값에 따라 LED 색상 변경

스마트 홈, 날씨 스테이션, 식물 관리 시스템... 모든 것의 시작입니다!

**예상 소요 시간**: 40분

---

## DHT11 센서의 원리

### 온도 측정: NTC 서미스터

DHT11 내부에는 **NTC (Negative Temperature Coefficient) 서미스터**가 있습니다.

**서미스터**는 온도에 따라 저항값이 변하는 특수한 저항입니다:

- 온도가 올라가면 → 저항이 내려감 (NTC)
- 저항 변화를 측정 → 온도 계산

**왜 NTC일까?**

- 저렴하고 안정적
- 0~50°C 범위에서 선형적 변화
- 작은 크기

### 습도 측정: 정전용량식 습도 센서

DHT11 내부에는 **습기에 반응하는 폴리머 필름**이 있습니다.

**작동 원리**:

1. 공기 중의 수분이 폴리머 필름에 흡수됨
2. 필름의 유전 상수가 변함
3. 정전용량이 변함
4. 정전용량 변화를 측정 → 습도 계산

**상대 습도 (RH%)**:

- 현재 공기가 포함한 수분 / 최대로 포함할 수 있는 수분 × 100
- 같은 절대 습도라도 온도에 따라 상대 습도는 달라짐

### DHT11 vs DHT22

| 특성        | DHT11               | DHT22 (AM2302)    |
| ----------- | ------------------- | ----------------- |
| 온도 범위   | 0~50°C              | -40~80°C          |
| 온도 정확도 | ±2°C                | ±0.5°C            |
| 습도 범위   | 20~90%              | 0~100%            |
| 습도 정확도 | ±5%                 | ±2%               |
| 샘플링 주기 | 1Hz (1초)           | 0.5Hz (2초)       |
| 가격        | 저렴                | 약 2-3배          |
| 용도        | 교육, 일반 프로젝트 | 정밀 측정 필요 시 |

**우리는 DHT11을 사용합니다**: 초보자에게 충분히 정확하고, 저렴하며, 사용법이 같습니다!

### 디지털 통신 프로토콜

DHT11은 **단선 양방향 통신(Single-Wire Two-Way)**을 사용합니다.

**통신 과정**:

1. 마이크로컨트롤러가 시작 신호 전송 (LOW 18ms)
2. DHT11이 응답 신호 전송
3. DHT11이 40비트 데이터 전송:
   - 습도 정수부 (8bit)
   - 습도 소수부 (8bit)
   - 온도 정수부 (8bit)
   - 온도 소수부 (8bit)
   - 체크섬 (8bit)
4. 통신 종료

**다행히** MicroPython의 `dht` 모듈이 이 복잡한 과정을 모두 처리해줍니다!

---

## 실습 준비

### 필요한 것

- 헥사보드 × 1
- **DHT11 센서 모듈** × 1 (저항 내장형)
- **3핀 케이블** × 1
- USB 케이블 × 1

### DHT11 센서 모듈 vs 원소자

**원소자** (4핀):

- 센서 칩만 있음
- 10kΩ 풀업 저항 필요
- 브레드보드 필요
- 초보자에게 어려움

**센서 모듈** (3핀) - **우리가 사용**:

- 센서 + 저항 + PCB 보드
- 저항이 이미 내장됨
- 3핀 케이블로 바로 연결
- 초보자 친화적!

### 핀 배치

DHT11 센서 모듈 (앞면):

```
┌─────────────┐
│   DHT11     │
│  [센서칩]    │
│             │
│  1   2   3  │
└──┬───┬───┬──┘
   │   │   │
  VCC DATA GND
```

- **VCC (1번)**: 전원 (+3.3V)
- **DATA (2번)**: 데이터 신호
- **GND (3번)**: 접지 (0V)

### 연결하기

```
DHT11 모듈        헥사보드
────────────────────────────
VCC (빨강)    →  3.3V
DATA (노랑)   →  PIN1 (GPIO 32)
GND (검정)    →  GND
```

**연결 순서** (중요!):

1. 헥사보드의 USB를 뽑아 전원을 끕니다
2. 3핀 케이블을 센서에 연결
3. 케이블의 반대편을 헥사보드의 PIN1 커넥터에 연결
4. 연결을 다시 한 번 확인 (특히 VCC와 GND!)
5. USB를 연결하여 전원을 켭니다

**⚠️ 주의**: VCC와 GND를 반대로 연결하면 센서가 뜨거워지거나 고장날 수 있습니다!

---

## 실습 1: 첫 번째 측정

### 목표

온도와 습도를 한 번 측정하여 출력합니다.

### 코드

```python
# 파일명: ch07_dht_basic.py
from machine import Pin
import dht
import time

# DHT11 센서 설정 (GPIO 32번)
sensor = dht.DHT11(Pin(32))

print("=" * 40)
print("  DHT11 온습도 센서 테스트")
print("=" * 40)
print()

# 측정
sensor.measure()  # 센서에게 측정 명령
temp = sensor.temperature()  # 온도 읽기 (°C)
humid = sensor.humidity()    # 습도 읽기 (%)

# 결과 출력
print(f"온도: {temp}°C")
print(f"습도: {humid}%")
print()
print("측정 완료!")
```

### 코드 설명

```python
import dht
```

→ MicroPython의 DHT 센서 라이브러리 (내장됨)

```python
sensor = dht.DHT11(Pin(32))
```

→ GPIO 32번에 연결된 DHT11 센서 객체 생성

```python
sensor.measure()
```

→ **필수!** 센서에게 측정을 시작하라고 명령
→ 이 함수를 호출하지 않으면 이전 값을 읽게 됨

```python
temp = sensor.temperature()
humid = sensor.humidity()
```

→ 측정된 온도와 습도를 읽어옴

### 실행 결과

```
========================================
  DHT11 온습도 센서 테스트
========================================

온도: 24°C
습도: 65%

측정 완료!
```

**축하합니다!** 첫 번째 센서 데이터를 읽었습니다! 🌡️

---

## 실습 2: 실시간 모니터링

### 목표

2초마다 온습도를 측정하여 실시간으로 출력합니다.

### 코드

```python
# 파일명: ch07_dht_monitor.py
from machine import Pin
import dht
import time

sensor = dht.DHT11(Pin(32))

print("=" * 50)
print("  실시간 온습도 모니터링")
print("=" * 50)
print("Ctrl+C로 종료하세요")
print()
print("번호 | 시간   | 온도   | 습도")
print("-" * 50)

count = 0
start_time = time.time()

while True:
    try:
        # 측정
        sensor.measure()
        temp = sensor.temperature()
        humid = sensor.humidity()

        # 경과 시간 계산
        elapsed = int(time.time() - start_time)
        minutes = elapsed // 60
        seconds = elapsed % 60

        # 출력
        count += 1
        print(f"{count:4d} | {minutes:02d}:{seconds:02d} | {temp:4d}°C | {humid:3d}%")

        # 2초 대기 (DHT11 최소 간격)
        time.sleep(2)

    except OSError as e:
        print(f"오류: 센서 읽기 실패 - {e}")
        time.sleep(2)
    except KeyboardInterrupt:
        print("\n\n모니터링 종료")
        break
```

### 실행 결과

```
==================================================
  실시간 온습도 모니터링
==================================================
Ctrl+C로 종료하세요

번호 | 시간   | 온도   | 습도
--------------------------------------------------
   1 | 00:00 |   24°C |  65%
   2 | 00:02 |   24°C |  66%
   3 | 00:04 |   25°C |  65%
   4 | 00:06 |   25°C |  64%
...
```

**팁**: 센서에 입김을 불어보세요. 온도와 습도가 올라가는 것을 볼 수 있습니다!

---

## 실습 3: LED로 온도 시각화

### 목표

온도에 따라 네오픽셀 색상을 변경합니다:

- 추움 (< 20°C): 파랑
- 쾌적 (20~28°C): 초록
- 더움 (> 28°C): 빨강

### 코드

```python
# 파일명: ch07_temp_led.py
from machine import Pin
import dht
import neopixel
import time

sensor = dht.DHT11(Pin(32))
np = neopixel.NeoPixel(Pin(23), 25)

def fill(color):
    """전체 LED를 같은 색으로"""
    for i in range(25):
        np[i] = color
    np.write()

def get_temp_color(temp):
    """온도에 따른 색상 반환"""
    if temp < 20:
        return (0, 0, 100)  # 파랑 (추움)
    elif temp <= 28:
        return (0, 100, 0)  # 초록 (쾌적)
    else:
        return (100, 0, 0)  # 빨강 (더움)

print("=" * 40)
print("  온도 시각화 시스템")
print("=" * 40)
print("온도에 따라 LED 색상이 바뀝니다")
print("파랑 (<20°C) | 초록 (20-28°C) | 빨강 (>28°C)")
print()

while True:
    try:
        sensor.measure()
        temp = sensor.temperature()
        humid = sensor.humidity()

        # 온도에 따른 색상 설정
        color = get_temp_color(temp)
        fill(color)

        # 상태 출력
        if temp < 20:
            status = "❄️  추움"
        elif temp <= 28:
            status = "😊 쾌적"
        else:
            status = "🔥 더움"

        print(f"{status} | 온도: {temp}°C | 습도: {humid}%")

        time.sleep(2)

    except OSError as e:
        print(f"오류: {e}")
        fill((50, 50, 0))  # 노랑 (오류)
        time.sleep(2)
    except KeyboardInterrupt:
        fill((0, 0, 0))  # LED 끄기
        print("\n종료")
        break
```

### 실행 결과

```
========================================
  온도 시각화 시스템
========================================
온도에 따라 LED 색상이 바뀝니다
파랑 (<20°C) | 초록 (20-28°C) | 빨강 (>28°C)

😊 쾌적 | 온도: 24°C | 습도: 65%
😊 쾌적 | 온도: 25°C | 습도: 66%
🔥 더움 | 온도: 29°C | 습도: 67%
```

**실험**: 센서를 손으로 감싸보세요. 온도가 올라가면서 LED가 초록에서 빨강으로 바뀝니다!

---

## 실습 4: 불쾌지수 계산

### 불쾌지수란?

불쾌지수는 온도와 습도를 결합하여 사람이 느끼는 불쾌함의 정도를 나타냅니다.

**공식**:

```
DI = 0.81 × T + 0.01 × H × (0.99 × T - 14.3) + 46.3
```

- T: 온도 (°C)
- H: 상대습도 (%)

**기준**:

- < 68: 쾌적
- 68~75: 보통
- 75~80: 약간 불쾌
- > 80: 매우 불쾌

### 코드

```python
# 파일명: ch07_discomfort_index.py
from machine import Pin
import dht
import neopixel
import time

sensor = dht.DHT11(Pin(32))
np = neopixel.NeoPixel(Pin(23), 25)

def fill(color):
    for i in range(25):
        np[i] = color
    np.write()

def calc_discomfort_index(temp, humid):
    """불쾌지수 계산"""
    di = 0.81 * temp + 0.01 * humid * (0.99 * temp - 14.3) + 46.3
    return round(di, 1)

def get_di_status(di):
    """불쾌지수에 따른 상태와 색상"""
    if di < 68:
        return "😊 쾌적", (0, 100, 0)
    elif di < 75:
        return "😐 보통", (100, 100, 0)
    elif di < 80:
        return "😰 약간 불쾌", (100, 50, 0)
    else:
        return "🥵 매우 불쾌", (100, 0, 0)

print("=" * 50)
print("  불쾌지수 모니터링 시스템")
print("=" * 50)
print()

while True:
    try:
        sensor.measure()
        temp = sensor.temperature()
        humid = sensor.humidity()

        # 불쾌지수 계산
        di = calc_discomfort_index(temp, humid)
        status, color = get_di_status(di)

        # LED 업데이트
        fill(color)

        # 출력
        print(f"{status}")
        print(f"  온도: {temp}°C | 습도: {humid}% | 불쾌지수: {di}")
        print()

        time.sleep(5)

    except OSError as e:
        print(f"오류: {e}")
        time.sleep(2)
    except KeyboardInterrupt:
        fill((0, 0, 0))
        print("\n종료")
        break
```

---

## 문제 해결

### 문제 1: "OSError: [Errno 116] ETIMEDOUT"

**원인**: 센서와 통신이 안 됨

**해결**:

- 연결을 다시 확인 (VCC, DATA, GND)
- 센서가 제대로 꽂혀 있는지 확인
- 다른 GPIO 핀 시도 (코드에서 `Pin(32)` 부분 변경)
- 센서를 교체 (불량일 수 있음)

### 문제 2: 온도/습도 값이 이상해요 (0 또는 매우 큰 값)

**원인**: 센서 초기화 실패 또는 불량

**해결**:

- 헥사보드 재부팅 (USB 뽑았다가 다시 연결)
- 첫 측정은 무시하고 두 번째부터 사용

```python
sensor.measure()
time.sleep(2)
sensor.measure()  # 이 값부터 사용
```

### 문제 3: 값이 변하지 않아요

**원인**: `sensor.measure()`를 호출하지 않음

**해결**:

- 매번 측정 전에 `sensor.measure()` 호출 확인

### 문제 4: 측정 간격이 너무 짧으면 오류 발생

**원인**: DHT11은 최소 1초 (권장 2초) 간격 필요

**해결**:

- `time.sleep(2)` 이상으로 설정

---

## 핵심 요약

### DHT11 센서

- **온도**: NTC 서미스터 (저항 변화)
- **습도**: 정전용량식 센서 (정전용량 변화)
- **통신**: 단선 양방향 디지털 프로토콜
- **정확도**: ±2°C, ±5% (교육용으로 충분)

### 핵심 코드 패턴

```python
import dht
from machine import Pin

sensor = dht.DHT11(Pin(32))

sensor.measure()  # 측정 명령 (필수!)
temp = sensor.temperature()  # 온도
humid = sensor.humidity()    # 습도
```

### 주의사항

- 최소 2초 간격으로 측정
- `measure()` 호출 후 값 읽기
- 연결 확인 (VCC, DATA, GND)
- 오류 처리 (try-except)

---

## 다음 단계

온습도 센서를 마스터했습니다! 🌡️

이제 여러분은:

- 센서의 작동 원리를 이해합니다
- 온도와 습도를 측정할 수 있습니다
- 측정값을 시각화할 수 있습니다
- 불쾌지수 같은 복합 지표를 계산할 수 있습니다

다음 챕터에서는 **조도 센서**를 배웁니다!

빛의 밝기를 측정하여 자동 조명, 낮/밤 감지, 식물 생장 모니터링 등을 만들어봅니다!

**준비되셨나요? 빛을 측정하러 갑니다!** 💡

---

**다음 챕터 예고**  
Chapter 8 - 조도 센서: 빛의 밝기를 숫자로

포토레지스터는 어떻게 빛을 감지할까요? ADC는 무엇일까요? 아날로그 센서의 세계로 들어갑니다!

---

# Chapter 8. 조도 센서: 빛의 밝기를 숫자로

> **PART 3**: 센서로 세상을 읽다 – 온습도와 빛

---

## 빛을 측정하는 기술

빛은 우리 삶의 필수 요소입니다. 낮과 밤을 구분하고, 식물은 빛으로 광합성을 하며, 우리는 빛으로 세상을 봅니다.

하지만 "밝다"와 "어둡다"는 주관적입니다. 같은 밝기도 사람마다 다르게 느낍니다. IoT에서는 **객관적인 측정**이 필요합니다.

**조도 센서(Light Sensor)**는 빛의 밝기를 숫자로 바꿉니다:
- 자동 가로등: 어두워지면 켜짐
- 스마트폰: 주변 밝기에 따라 화면 밝기 조절
- 식물 재배: 광합성에 필요한 빛의 양 측정
- 보안 시스템: 낮/밤 구분

이 챕터에서는 **포토레지스터(CdS 센서)**를 사용하여 빛을 측정하고, **ADC(아날로그-디지털 변환)**의 원리를 배웁니다!

**예상 소요 시간**: 35분

---

## 포토레지스터의 원리

### CdS 센서 (황화카드뮴 광전도 셀)

포토레지스터는 **빛에 따라 저항값이 변하는** 특수한 저항입니다.

**작동 원리**:
1. 빛이 CdS 물질에 닿으면
2. 전자가 자유로워져서 전류가 잘 흐름
3. 저항이 낮아짐

**빛과 저항의 관계**:
```
밝음 (많은 광자) → 낮은 저항 (수백 Ω)
어두움 (적은 광자) → 높은 저항 (수십 MΩ)
```

### 전압 분배 회로

포토레지스터 단독으로는 저항값만 측정됩니다. 저항을 전압으로 바꿔야 ESP32가 읽을 수 있습니다.

**전압 분배 회로**:
```
VCC (3.3V)
   │
  [R1] 10kΩ 고정 저항
   │
   ├─── OUT (여기서 전압 측정)
   │
  [CdS] 포토레지스터
   │
  GND
```

**수식**:
```
V_out = VCC × (R_CdS / (R1 + R_CdS))
```

- 밝을 때: R_CdS 낮음 → V_out 낮음
- 어두울 때: R_CdS 높음 → V_out 높음

**다행히** 우리가 사용하는 센서 모듈에는 이 회로가 이미 내장되어 있습니다!

---

## ADC: 아날로그를 디지털로

### 아날로그 vs 디지털

**아날로그**:
- 연속적인 값
- 0V ~ 3.3V 사이의 모든 값 가능 (2.5V, 2.51V, 2.512V...)
- 자연 세계는 아날로그

**디지털**:
- 이산적인 값
- 정해진 단계로만 표현 (0, 1, 2, 3...)
- 컴퓨터는 디지털만 이해

### ESP32의 ADC

ESP32에는 **12비트 ADC**가 내장되어 있습니다.

**12비트의 의미**:
- 2^12 = 4096단계
- 0 ~ 4095의 값으로 표현
- 0V → 0
- 3.3V → 4095
- 1.65V → 약 2048

**해상도**:
```
3.3V / 4096 ≈ 0.8mV
```
→ 약 0.8mV 단위로 구분 가능!

**ADC 핀**:
- ESP32의 특정 GPIO만 ADC 기능 지원
- 헥사보드: GPIO 32, 33, 34, 35 등
- 우리는 GPIO 33 (PIN2) 사용

---

## 실습 준비

### 필요한 것

- 헥사보드 × 1
- **조도 센서 모듈** × 1 (저항 내장형)
- **3핀 케이블** × 1
- USB 케이블 × 1

### 센서 모듈 구조

```
┌──────────────┐
│  [CdS 센서]   │
│     🌞        │
│              │
│  VCC OUT GND │
└───┬───┬───┬──┘
    │   │   │
   3.3V 33 GND
```

### 연결하기

```
조도센서 모듈    헥사보드
─────────────────────────
VCC (빨강)   →  3.3V
OUT (노랑)   →  PIN2 (GPIO 33)
GND (검정)   →  GND
```

**연결 순서**:
1. USB 뽑기 (전원 끄기)
2. 3핀 케이블로 센서와 헥사보드 연결
3. 연결 확인
4. USB 연결

---

## 실습 1: ADC 기본 사용

### 목표

조도 센서의 값을 읽어 출력합니다.

### 코드

```python
# 파일명: ch08_light_basic.py
from machine import Pin, ADC
import time

# ADC 설정 (GPIO 33)
light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)  # 0~3.3V 측정 범위

print("=" * 40)
print("  조도 센서 테스트")
print("=" * 40)
print()

# 10번 측정
for i in range(10):
    # ADC 값 읽기 (0~4095)
    value = light_sensor.read()
    
    # 전압으로 변환
    voltage = value * 3.3 / 4095
    
    print(f"[{i+1}] ADC: {value:4d} | 전압: {voltage:.2f}V")
    time.sleep(1)

print("\n완료!")
```

### 코드 설명

```python
light_sensor = ADC(Pin(33))
```
→ GPIO 33번을 ADC로 설정

```python
light_sensor.atten(ADC.ATTN_11DB)
```
→ 감쇠(attenuation) 설정
→ `ATTN_11DB`: 0~3.3V 전체 범위 측정 (권장)

```python
value = light_sensor.read()
```
→ ADC 값 읽기 (0~4095)

```python
voltage = value * 3.3 / 4095
```
→ ADC 값을 실제 전압으로 변환

### 실험해보기

1. 프로그램 실행
2. 센서를 손으로 가려보기 → 값이 증가
3. 손전등을 비춰보기 → 값이 감소

**왜 반대일까?**: 우리 회로에서는 밝을수록 저항이 낮아져서 출력 전압이 낮아지기 때문!

---

## 실습 2: 밝기 백분율로 표시

### 목표

0~100% 스케일로 밝기를 표시합니다.

### 코드

```python
# 파일명: ch08_light_percentage.py
from machine import Pin, ADC
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)

# 보정값 (실제 환경에 맞게 조정)
MIN_VALUE = 100   # 매우 밝을 때
MAX_VALUE = 3000  # 매우 어두울 때

def read_brightness():
    """밝기를 0~100%로 반환"""
    value = light_sensor.read()
    
    # 범위 제한
    value = max(MIN_VALUE, min(MAX_VALUE, value))
    
    # 백분율로 변환 (값이 클수록 어두움이므로 반전)
    brightness = 100 - ((value - MIN_VALUE) * 100 / (MAX_VALUE - MIN_VALUE))
    
    return int(brightness), value

print("=" * 50)
print("  밝기 측정 시스템")
print("=" * 50)
print()

while True:
    brightness, raw = read_brightness()
    
    # 막대 그래프
    bar_length = brightness // 5
    bar = "█" * bar_length + "░" * (20 - bar_length)
    
    print(f"밝기: {brightness:3d}% [{bar}] (Raw: {raw})")
    
    time.sleep(0.5)
```

### 실행 결과

```
==================================================
  밝기 측정 시스템
==================================================

밝기:  85% [█████████████████░░░] (Raw: 534)
밝기:  20% [████░░░░░░░░░░░░░░░░] (Raw: 2420)
밝기:  90% [██████████████████░░] (Raw: 390)
```

---

## 실습 3: 자동 조명 시스템

### 목표

밝기에 따라 LED를 자동으로 켜고 끕니다.

### 코드

```python
# 파일명: ch08_auto_light.py
from machine import Pin, ADC
import neopixel
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)
np = neopixel.NeoPixel(Pin(23), 25)

THRESHOLD = 2000  # 어두움 기준값

def fill(color):
    for i in range(25):
        np[i] = color
    np.write()

print("=" * 40)
print("  자동 조명 시스템")
print("=" * 40)
print(f"기준값: {THRESHOLD}")
print("어두우면 LED가 켜집니다")
print()

led_on = False

while True:
    value = light_sensor.read()
    
    if value > THRESHOLD:  # 어두움
        if not led_on:
            fill((100, 100, 100))  # 흰색
            print(f"💡 조명 ON  (밝기: {value})")
            led_on = True
    else:  # 밝음
        if led_on:
            fill((0, 0, 0))  # 끄기
            print(f"🌙 조명 OFF (밝기: {value})")
            led_on = False
    
    time.sleep(0.5)
```

**실험**: 센서를 손으로 가리면 LED가 켜지고, 손을 치우면 꺼집니다!

---

## 실습 4: 밝기 단계별 LED 색상

### 목표

밝기에 따라 LED 색상이 다단계로 변합니다.

### 코드

```python
# 파일명: ch08_brightness_levels.py
from machine import Pin, ADC
import neopixel
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)
np = neopixel.NeoPixel(Pin(23), 25)

def fill(color):
    for i in range(25):
        np[i] = color
    np.write()

def get_light_level(value):
    """밝기 단계 반환"""
    if value < 500:
        return "매우 밝음", (0, 0, 100)  # 파랑
    elif value < 1000:
        return "밝음", (0, 100, 100)  # 시안
    elif value < 2000:
        return "보통", (0, 100, 0)  # 초록
    elif value < 3000:
        return "어두움", (100, 50, 0)  # 주황
    else:
        return "매우 어두움", (100, 0, 0)  # 빨강

print("밝기 단계별 LED 색상 시스템")
print()

prev_level = None

while True:
    value = light_sensor.read()
    level, color = get_light_level(value)
    
    if level != prev_level:
        fill(color)
        print(f"{level:12s} | ADC: {value:4d}")
        prev_level = level
    
    time.sleep(0.3)
```

---

## 보정(Calibration)의 중요성

### 센서마다 다른 값

같은 밝기라도 센서마다, 환경마다 다른 값을 출력합니다:
- 센서 개체차
- 주변 조명 환경
- 센서 설치 각도

### 보정 방법

**1. 수동 보정**:
```python
# 가장 밝은 곳에서 측정
MIN_VALUE = 100

# 가장 어두운 곳에서 측정
MAX_VALUE = 3000
```

**2. 자동 보정**:
```python
print("보정 시작! 센서를 가장 밝은 곳에 두세요...")
time.sleep(3)
min_val = light_sensor.read()

print("이제 가장 어두운 곳에 두세요...")
time.sleep(3)
max_val = light_sensor.read()

print(f"보정 완료: MIN={min_val}, MAX={max_val}")
```

---

## 조도 단위: Lux

### Lux란?

**Lux (럭스)**: 밝기의 SI 단위
- 1 lux = 1m² 면적에 1루멘의 광속

**참고값**:
- 직사광선: 100,000 lux
- 흐린 날 야외: 10,000 lux
- 사무실 조명: 300~500 lux
- 보름달: 0.2 lux
- 별빛: 0.001 lux

### 간이 Lux 변환

정확한 변환에는 보정이 필요하지만, 간단한 공식:

```python
def adc_to_lux_approx(value):
    """대략적인 Lux 변환"""
    # 밝을수록 값이 낮으므로 반전
    normalized = (4095 - value) / 4095
    lux = normalized * 10000  # 최대 10,000 lux로 가정
    return int(lux)
```

---

## 핵심 요약

### 조도 센서 원리

- **포토레지스터**: 빛에 따라 저항 변화
- **전압 분배**: 저항 변화를 전압 변화로 변환
- **ADC**: 아날로그 전압을 디지털 숫자로 변환

### ADC 사용법

```python
from machine import Pin, ADC

sensor = ADC(Pin(33))
sensor.atten(ADC.ATTN_11DB)  # 0~3.3V 범위
value = sensor.read()  # 0~4095
```

### 보정의 중요성

- 센서마다 다른 값
- 환경에 따라 달라짐
- MIN/MAX 값 보정 필요

---

## 문제 해결

**Q: 값이 변하지 않아요**
A: 연결 확인, 올바른 GPIO 핀 사용 확인

**Q: 값이 너무 작거나 너무 커요**
A: `atten()` 설정 확인, 보정값 조정

**Q: 값이 불안정해요 (흔들림)**
A: 이동 평균 필터 사용:
```python
values = []
for _ in range(10):
    values.append(sensor.read())
    time.sleep(0.01)
avg = sum(values) // len(values)
```

---

## 다음 단계

조도 센서를 마스터했습니다! 💡

이제 온도, 습도, 밝기 세 가지 센서를 모두 다룰 수 있습니다!

다음 챕터에서는 **센서 데이터 처리**를 배웁니다:
- 평균, 최소, 최대값 계산
- 변화율 감지
- 이상치 제거
- 데이터 저장

센서 데이터를 의미 있는 정보로 바꾸는 법을 배웁니다!

**준비되셨나요? 데이터를 처리합니다!** 📊



---

# Chapter 9. 센서 데이터 처리: 원석을 보석으로

> **PART 3**: 센서로 세상을 읽다 – 온습도와 빛

---

## 데이터의 가공

센서에서 얻은 데이터는 **원석**과 같습니다. 그 자체로도 가치가 있지만, 가공하면 훨씬 더 유용해집니다.

**원시 데이터의 문제점**:
- 노이즈: 값이 튐 (24°C, 27°C, 24°C, 25°C...)
- 정밀도: 소수점이 너무 많음 (24.83721°C)
- 단위: 사용자가 이해하기 어려움 (ADC 2847)
- 범위: 특정 범위를 벗어남 (음수 온도, 100% 초과 습도)

이 챕터에서는 센서 데이터를 **의미 있고 신뢰할 수 있는 정보**로 만드는 방법을 배웁니다!

**예상 소요 시간**: 30분

---

## 데이터 정제 기법

### 1. 반올림 (Rounding)

불필요한 소수점을 제거합니다.

```python
temp = 24.83721
temp_rounded = round(temp)  # 25
temp_1digit = round(temp, 1)  # 24.8
```

### 2. 클램핑 (Clamping)

값을 특정 범위로 제한합니다.

```python
def clamp(value, min_val, max_val):
    """값을 범위 내로 제한"""
    return max(min_val, min(max_val, value))

humid = 105  # 비정상적으로 높음
humid = clamp(humid, 0, 100)  # 100
```

### 3. 스케일링 (Scaling)

값의 범위를 변환합니다.

```python
# ADC 0~4095 → 퍼센트 0~100
adc_value = 2048
percent = (adc_value / 4095) * 100  # 50%
```

### 4. 이동 평균 (Moving Average)

여러 측정값의 평균으로 노이즈를 제거합니다.

```python
values = [24, 27, 24, 25, 26]  # 최근 5개 측정값
average = sum(values) / len(values)  # 25.2
```

---

## 실습 1: 반올림과 포맷팅

### 코드

```python
# 파일명: ch09_formatting.py
from machine import Pin
import dht
import time

sensor = dht.DHT11(Pin(32))

print("데이터 포맷팅 예제")
print("=" * 40)

for i in range(5):
    sensor.measure()
    temp = sensor.temperature()
    humid = sensor.humidity()
    
    # 다양한 포맷
    print(f"\n측정 {i+1}:")
    print(f"  원본:        {temp}°C, {humid}%")
    print(f"  반올림:      {round(temp)}°C, {round(humid)}%")
    print(f"  소수점 1자리: {temp:.1f}°C, {humid:.1f}%")
    print(f"  정수(int):    {int(temp)}°C, {int(humid)}%")
    
    time.sleep(2)
```

---

## 실습 2: 단위 변환

### 온도 변환

```python
# 파일명: ch09_unit_conversion.py
from machine import Pin
import dht

sensor = dht.DHT11(Pin(32))

def celsius_to_fahrenheit(c):
    """섭씨 → 화씨"""
    return c * 9/5 + 32

def fahrenheit_to_celsius(f):
    """화씨 → 섭씨"""
    return (f - 32) * 5/9

def celsius_to_kelvin(c):
    """섭씨 → 켈빈"""
    return c + 273.15

sensor.measure()
temp_c = sensor.temperature()

temp_f = celsius_to_fahrenheit(temp_c)
temp_k = celsius_to_kelvin(temp_c)

print("=" * 40)
print("  온도 단위 변환")
print("=" * 40)
print(f"섭씨:   {temp_c:.1f}°C")
print(f"화씨:   {temp_f:.1f}°F")
print(f"켈빈:   {temp_k:.1f}K")
```

**변환 공식**:
- °F = °C × 9/5 + 32
- °C = (°F - 32) × 5/9
- K = °C + 273.15

---

## 실습 3: 이동 평균 필터

### 노이즈 제거

```python
# 파일명: ch09_moving_average.py
from machine import Pin
import dht
import time

sensor = dht.DHT11(Pin(32))

class MovingAverage:
    """이동 평균 필터"""
    def __init__(self, size=5):
        self.size = size
        self.values = []
    
    def add(self, value):
        """새 값 추가"""
        self.values.append(value)
        if len(self.values) > self.size:
            self.values.pop(0)  # 가장 오래된 값 제거
    
    def get_average(self):
        """평균 반환"""
        if not self.values:
            return 0
        return sum(self.values) / len(self.values)

# 온도와 습도용 필터 생성
temp_filter = MovingAverage(size=5)
humid_filter = MovingAverage(size=5)

print("이동 평균 필터 테스트")
print("=" * 50)
print("측정# | 원본 온도 | 평균 온도 | 원본 습도 | 평균 습도")
print("-" * 50)

for i in range(20):
    sensor.measure()
    temp_raw = sensor.temperature()
    humid_raw = sensor.humidity()
    
    # 필터에 추가
    temp_filter.add(temp_raw)
    humid_filter.add(humid_raw)
    
    # 평균 계산
    temp_avg = temp_filter.get_average()
    humid_avg = humid_filter.get_average()
    
    print(f"{i+1:4d}  |  {temp_raw:5.1f}°C  |  {temp_avg:5.1f}°C  |  {humid_raw:5.1f}%  |  {humid_avg:5.1f}%")
    
    time.sleep(2)
```

**효과**: 값이 튀는 현상이 줄어들고 부드러워집니다!

---

## 실습 4: ADC 스케일링

### 0~4095를 의미 있는 값으로

```python
# 파일명: ch09_adc_scaling.py
from machine import Pin, ADC
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)

# 보정값 (실제 환경에 맞게 조정)
DARK_VALUE = 3000   # 어두울 때
BRIGHT_VALUE = 100  # 밝을 때

def scale_brightness(adc_value):
    """ADC 값을 0~100% 밝기로 변환"""
    # 클램핑
    adc_value = max(BRIGHT_VALUE, min(DARK_VALUE, adc_value))
    
    # 스케일링 (반전: 높은 값 = 어두움)
    brightness = 100 - ((adc_value - BRIGHT_VALUE) * 100 / (DARK_VALUE - BRIGHT_VALUE))
    
    return int(brightness)

def get_brightness_level(percent):
    """밝기를 단계로 변환"""
    if percent >= 80:
        return "☀️ 매우 밝음"
    elif percent >= 60:
        return "🌤️ 밝음"
    elif percent >= 40:
        return "⛅ 보통"
    elif percent >= 20:
        return "🌥️ 어두움"
    else:
        return "🌑 매우 어두움"

print("밝기 스케일링 시스템")
print("=" * 50)

while True:
    raw = light_sensor.read()
    percent = scale_brightness(raw)
    level = get_brightness_level(percent)
    
    # 프로그레스 바
    bars = int(percent / 5)
    progress = "█" * bars + "░" * (20 - bars)
    
    print(f"{level} | {percent:3d}% [{progress}] (Raw: {raw})")
    
    time.sleep(0.5)
```

---

## 실습 5: 데이터 검증

### 이상치 감지 및 제거

```python
# 파일명: ch09_data_validation.py
from machine import Pin
import dht
import time

sensor = dht.DHT11(Pin(32))

def is_valid_temperature(temp):
    """온도가 유효한지 확인"""
    return 0 <= temp <= 50  # DHT11 범위

def is_valid_humidity(humid):
    """습도가 유효한지 확인"""
    return 20 <= humid <= 90  # DHT11 범위

def is_reasonable_change(new_val, old_val, max_change=5):
    """변화량이 합리적인지 확인"""
    if old_val is None:
        return True
    return abs(new_val - old_val) <= max_change

# 이전 값 저장
prev_temp = None
prev_humid = None

valid_count = 0
invalid_count = 0

print("데이터 검증 시스템")
print("=" * 50)

for i in range(20):
    try:
        sensor.measure()
        temp = sensor.temperature()
        humid = sensor.humidity()
        
        # 검증
        temp_valid = is_valid_temperature(temp)
        humid_valid = is_valid_humidity(humid)
        temp_reasonable = is_reasonable_change(temp, prev_temp)
        humid_reasonable = is_reasonable_change(humid, prev_humid)
        
        all_valid = temp_valid and humid_valid and temp_reasonable and humid_reasonable
        
        if all_valid:
            print(f"✅ [{i+1}] 온도: {temp}°C, 습도: {humid}%")
            prev_temp = temp
            prev_humid = humid
            valid_count += 1
        else:
            reasons = []
            if not temp_valid:
                reasons.append("온도 범위 초과")
            if not humid_valid:
                reasons.append("습도 범위 초과")
            if not temp_reasonable:
                reasons.append("온도 급변")
            if not humid_reasonable:
                reasons.append("습도 급변")
            
            print(f"❌ [{i+1}] 무효: {', '.join(reasons)}")
            invalid_count += 1
        
        time.sleep(2)
        
    except Exception as e:
        print(f"⚠️  [{i+1}] 측정 실패: {e}")
        invalid_count += 1
        time.sleep(2)

print("\n=" * 50)
print(f"유효: {valid_count}, 무효: {invalid_count}")
print(f"신뢰도: {valid_count/(valid_count+invalid_count)*100:.1f}%")
```

---

## 고급: 칼만 필터 (간단 버전)

### 더 정교한 노이즈 제거

```python
# 파일명: ch09_simple_kalman.py
class SimpleKalmanFilter:
    """간단한 칼만 필터"""
    def __init__(self, process_variance=0.01, measurement_variance=0.25):
        self.process_variance = process_variance
        self.measurement_variance = measurement_variance
        self.estimate = 0
        self.error_estimate = 1
    
    def update(self, measurement):
        """새 측정값으로 업데이트"""
        # 예측
        self.error_estimate += self.process_variance
        
        # 갱신
        kalman_gain = self.error_estimate / (self.error_estimate + self.measurement_variance)
        self.estimate = self.estimate + kalman_gain * (measurement - self.estimate)
        self.error_estimate = (1 - kalman_gain) * self.error_estimate
        
        return self.estimate

# 사용 예
filter = SimpleKalmanFilter()
measurement = 24.8
filtered = filter.update(measurement)
```

---

## 핵심 요약

### 데이터 처리 기법

1. **반올림**: 불필요한 정밀도 제거
2. **클램핑**: 값을 유효 범위로 제한
3. **스케일링**: 범위 변환
4. **이동 평균**: 노이즈 제거
5. **검증**: 이상치 감지

### 핵심 코드

```python
# 반올림
value = round(24.83, 1)  # 24.8

# 클램핑
value = max(0, min(100, value))

# 스케일링
percent = (value / 4095) * 100

# 이동 평균
avg = sum(recent_values) / len(recent_values)
```

---

## 다음 단계

데이터 처리를 마스터했습니다! 📊

다음 챕터에서는 **시각화**를 배웁니다!

처리된 데이터를 네오픽셀 LED로 표현하여:
- 온도 바 그래프
- 습도 게이지
- 밝기 히트맵

숫자를 직관적인 그림으로 바꿔봅니다!

**준비되셨나요? 시각화 시작!** 📊✨



---

# Chapter 10. 데이터 시각화: 숫자를 그림으로

> **PART 3**: 센서로 세상을 읽다 – 온습도와 빛

---

## 눈으로 보는 데이터

"24°C"라는 숫자보다 LED 막대 그래프가 더 직관적입니다. 사람의 뇌는 시각 정보를 훨씬 빠르게 처리합니다.

**데이터 시각화의 장점**:
- 빠른 이해: 한눈에 상태 파악
- 패턴 발견: 변화 추이를 쉽게 인식
- 사용자 친화적: 전문 지식 불필요
- 멀리서도 확인: 대시보드, 모니터링

헥사보드의 5×5 네오픽셀 LED는 작은 디스플레이입니다. 25개 픽셀로 온도, 습도, 밝기를 표현해봅시다!

**예상 소요 시간**: 40분

---

## 시각화 패턴

### 1. 바 그래프 (Bar Graph)

세로 막대로 값을 표현

```
높은 값:    낮은 값:
🟩          ░
🟩          ░
🟩          ░
🟩          🟩
🟩          🟩
```

### 2. 게이지 (Gauge)

원형 또는 반원형으로 표현

```
테두리 LED를 시계방향으로 점등
```

### 3. 히트맵 (Heat Map)

색상으로 값을 표현

```
차가움 ← → 뜨거움
🟦 🟩 🟨 🟧 🟥
```

### 4. 애니메이션

움직임으로 변화 표현

---

## 실습 1: 온도 바 그래프

### 코드

```python
# 파일명: ch10_temp_bar.py
from machine import Pin
import dht
import neopixel
import time

sensor = dht.DHT11(Pin(32))
np = neopixel.NeoPixel(Pin(23), 25)

def show_temp_bar(temp):
    """온도를 중앙 열 바 그래프로 표시"""
    # 초기화
    for i in range(25):
        np[i] = (0, 0, 0)
    
    # 온도를 0~5 단계로 변환 (15~35°C)
    temp = max(15, min(35, temp))
    bars = int((temp - 15) / 4)  # 4°C당 1칸
    
    # 중앙 열 (아래부터 위로)
    column = [22, 17, 12, 7, 2]
    
    # 온도에 따른 색상
    if temp < 20:
        color = (0, 0, 100)  # 파랑
    elif temp < 25:
        color = (0, 100, 0)  # 초록
    elif temp < 30:
        color = (100, 100, 0)  # 노랑
    else:
        color = (100, 0, 0)  # 빨강
    
    # 바 표시
    for i in range(min(bars, 5)):
        np[column[i]] = color
    
    np.write()

print("온도 바 그래프")
print()

while True:
    sensor.measure()
    temp = sensor.temperature()
    
    show_temp_bar(temp)
    print(f"온도: {temp}°C")
    
    time.sleep(2)
```

---

## 실습 2: 습도 테두리 게이지

### 코드

```python
# 파일명: ch10_humidity_gauge.py
from machine import Pin
import dht
import neopixel
import time

sensor = dht.DHT11(Pin(32))
np = neopixel.NeoPixel(Pin(23), 25)

def show_humidity_gauge(humid):
    """습도를 테두리 게이지로 표시"""
    # 초기화
    for i in range(25):
        np[i] = (0, 0, 0)
    
    # 테두리 LED (시계방향)
    border = [0, 1, 2, 3, 4, 9, 14, 19, 24, 23, 22, 21, 20, 15, 10, 5]
    
    # 습도를 0~16 단계로 (테두리 LED 개수)
    humid = max(0, min(100, humid))
    leds_to_light = int(humid / 100 * len(border))
    
    # 습도에 따른 색상
    if humid < 30:
        color = (100, 50, 0)  # 주황 (건조)
    elif humid < 60:
        color = (0, 100, 0)  # 초록 (적당)
    else:
        color = (0, 50, 100)  # 파랑 (습함)
    
    # 게이지 표시
    for i in range(leds_to_light):
        np[border[i]] = color
    
    np.write()

print("습도 게이지")
print()

while True:
    sensor.measure()
    humid = sensor.humidity()
    
    show_humidity_gauge(humid)
    print(f"습도: {humid}%")
    
    time.sleep(2)
```

---

## 실습 3: 밝기 히트맵

### 코드

```python
# 파일명: ch10_brightness_heatmap.py
from machine import Pin, ADC
import neopixel
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)
np = neopixel.NeoPixel(Pin(23), 25)

def value_to_color(value, min_val=0, max_val=4095):
    """값을 색상 그라데이션으로 변환"""
    # 정규화 (0~1)
    normalized = (value - min_val) / (max_val - min_val)
    normalized = max(0, min(1, normalized))
    
    # 색상 그라데이션: 파랑 → 초록 → 빨강
    if normalized < 0.5:
        # 파랑 → 초록
        ratio = normalized * 2
        r = 0
        g = int(100 * ratio)
        b = int(100 * (1 - ratio))
    else:
        # 초록 → 빨강
        ratio = (normalized - 0.5) * 2
        r = int(100 * ratio)
        g = int(100 * (1 - ratio))
        b = 0
    
    return (r, g, b)

def show_heatmap(value):
    """전체 LED를 히트맵 색상으로"""
    color = value_to_color(value)
    for i in range(25):
        np[i] = color
    np.write()

print("밝기 히트맵")
print()

while True:
    value = light_sensor.read()
    show_heatmap(value)
    
    print(f"밝기: {value:4d} (0=어두움, 4095=밝음)")
    
    time.sleep(0.3)
```

---

## 실습 4: 복합 대시보드

### 3개 센서를 한 화면에

```python
# 파일명: ch10_dashboard.py
from machine import Pin, ADC
import dht
import neopixel
import time

# 센서 설정
temp_sensor = dht.DHT11(Pin(32))
light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)
np = neopixel.NeoPixel(Pin(23), 25)

def show_dashboard(temp, humid, light):
    """
    대시보드 레이아웃:
    - 왼쪽 열 (0,5,10,15,20): 온도
    - 중앙 열 (2,7,12,17,22): 습도
    - 오른쪽 열 (4,9,14,19,24): 밝기
    """
    # 초기화
    for i in range(25):
        np[i] = (0, 0, 0)
    
    # 온도 (왼쪽, 0~5단계)
    temp_bars = min(5, int((temp - 15) / 4))
    temp_leds = [20, 15, 10, 5, 0]
    temp_color = (100, 0, 0) if temp > 28 else (0, 100, 0)
    for i in range(temp_bars):
        np[temp_leds[i]] = temp_color
    
    # 습도 (중앙, 0~5단계)
    humid_bars = min(5, int(humid / 20))
    humid_leds = [22, 17, 12, 7, 2]
    humid_color = (0, 50, 100)
    for i in range(humid_bars):
        np[humid_leds[i]] = humid_color
    
    # 밝기 (오른쪽, 0~5단계)
    light_bars = min(5, int(light / 800))
    light_leds = [24, 19, 14, 9, 4]
    light_color = (100, 100, 0)
    for i in range(light_bars):
        np[light_leds[i]] = light_color
    
    np.write()

print("=" * 50)
print("  종합 대시보드")
print("=" * 50)
print("왼쪽: 온도 | 중앙: 습도 | 오른쪽: 밝기")
print()

while True:
    try:
        temp_sensor.measure()
        temp = temp_sensor.temperature()
        humid = temp_sensor.humidity()
        light = light_sensor.read()
        
        show_dashboard(temp, humid, light)
        
        print(f"온도:{temp:3d}°C | 습도:{humid:3d}% | 밝기:{light:4d}")
        
        time.sleep(2)
        
    except Exception as e:
        print(f"오류: {e}")
        time.sleep(2)
```

---

## 실습 5: 애니메이션 - 로딩 효과

### 데이터 측정 중 표시

```python
# 파일명: ch10_loading_animation.py
from machine import Pin
import neopixel
import time

np = neopixel.NeoPixel(Pin(23), 25)

def loading_animation(duration=2):
    """로딩 애니메이션 (원형 회전)"""
    border = [0, 1, 2, 3, 4, 9, 14, 19, 24, 23, 22, 21, 20, 15, 10, 5]
    
    start_time = time.time()
    idx = 0
    
    while time.time() - start_time < duration:
        # 초기화
        for i in range(25):
            np[i] = (0, 0, 0)
        
        # 현재 위치와 꼬리 표시
        for i in range(4):
            led_idx = (idx - i) % len(border)
            brightness = 100 - (i * 25)
            np[border[led_idx]] = (0, brightness, brightness)
        
        np.write()
        
        idx = (idx + 1) % len(border)
        time.sleep(0.05)
    
    # 완료 표시
    for i in range(25):
        np[i] = (0, 100, 0)
    np.write()
    time.sleep(0.3)
    
    for i in range(25):
        np[i] = (0, 0, 0)
    np.write()

print("로딩 애니메이션 테스트")

for i in range(5):
    print(f"\n측정 {i+1}...")
    loading_animation(2)
    print("완료!")
    time.sleep(1)
```

---

## 핵심 요약

### 시각화 패턴

1. **바 그래프**: 값을 막대 길이로
2. **게이지**: 테두리 LED로 백분율
3. **히트맵**: 색상 그라데이션
4. **대시보드**: 여러 데이터를 한 화면에
5. **애니메이션**: 움직임으로 상태 표시

### 5×5 LED 활용

- 중앙 열: 단일 바 그래프
- 테두리 16개: 원형 게이지
- 전체 25개: 히트맵, 패턴
- 3개 열: 복합 대시보드

---

## Part 3 완료! 🎉

축하합니다! 센서 파트를 완료했습니다!

**배운 것**:
- DHT11 온습도 센서
- 조도 센서 (포토레지스터)
- 데이터 처리 (필터링, 변환, 검증)
- 데이터 시각화 (LED 그래프, 게이지)

**다음 Part 4**에서는 **MQTT 통신**을 배웁니다!

헥사보드의 센서 데이터를 인터넷으로 전송하고, 다른 장치와 통신하는 방법을 배웁니다. IoT의 진짜 시작입니다!

**준비되셨나요? MQTT의 세계로!** 📡🌐



---


# PART 4: MQTT를 통한 센서 데이터 전송

# Chapter 11. MQTT: IoT의 언어

> **PART 4**: MQTT를 통한 센서 데이터 전송

---

## 기기들의 대화

헥사보드가 측정한 온도를 어떻게 멀리 있는 컴퓨터에 전달할까요? HTTP? 웹소켓? FTP?

IoT에는 특별한 통신 방식이 있습니다: **MQTT (Message Queuing Telemetry Transport)**.

1999년 IBM이 개발한 MQTT는 이제 IoT의 표준 프로토콜이 되었습니다. 스마트홈, 자동차, 공장, 농장... 수백만 개의 IoT 기기가 MQTT로 대화합니다.

**왜 MQTT일까?**
- 극도로 가벼움 (2바이트 헤더)
- 불안정한 네트워크에서도 동작
- 배터리 효율적
- 수백만 기기 동시 연결 가능

이 챕터에서는 MQTT의 핵심 개념을 배웁니다!

**예상 소요 시간**: 30분

---

## Publish/Subscribe 패턴

### 기존 방식의 문제

**Client-Server 모델** (HTTP 등):
```
헥사보드 A → Python 서버
헥사보드 B → Python 서버
헥사보드 C → Python 서버
```

문제:
- 서버 주소를 모든 헥사보드가 알아야 함
- 서버가 다운되면 모두 멈춤
- 1:1 연결만 가능

### Pub/Sub 모델의 해결책

**MQTT Broker 중심**:
```
                    ┌─────────────┐
헥사보드 A ─Publish→ │             │
헥사보드 B ─Publish→ │   Broker    │ ─Subscribe→ Python 서버
헥사보드 C ─Publish→ │  (중개자)   │ ─Subscribe→ 웹 대시보드
                    └─────────────┘
```

장점:
- 발행자와 구독자가 서로를 몰라도 됨
- 중개자만 알면 됨
- N:M 연결 가능
- 느슨한 결합 (Loose Coupling)

---

## MQTT의 3가지 주체

### 1. Broker (중개자)

**역할**: 모든 메시지를 중개하는 서버

**인기 있는 Broker**:
- **HiveMQ Cloud**: 무료 클라우드 (우리가 사용)
- **Mosquitto**: 오픈소스, 자체 호스팅
- **AWS IoT Core**: 아마존 클라우드
- **Azure IoT Hub**: 마이크로소프트 클라우드

### 2. Publisher (발행자)

**역할**: 데이터를 보내는 기기

**예시**:
- 센서 데이터를 보내는 헥사보드
- 알림을 보내는 서버
- 로그를 보내는 애플리케이션

### 3. Subscriber (구독자)

**역할**: 데이터를 받는 기기

**예시**:
- 센서 데이터를 분석하는 AI 서버
- 데이터를 시각화하는 웹 페이지
- 알림을 받는 스마트폰 앱

**중요**: 한 기기가 Publisher이면서 동시에 Subscriber일 수 있습니다!

---

## Topic: 메시지의 주소

### Topic의 개념

**Topic**은 메시지의 카테고리입니다. 우편 주소처럼 작동합니다.

**구조**:
```
<레벨1>/<레벨2>/<레벨3>/...
```

**예시**:
```
home/livingroom/temperature
home/bedroom/humidity
factory/machine1/status
car/tesla/model3/battery
```

### Topic 설계 원칙

**1. 계층 구조 사용**:
```
❌ 나쁨: hexaboard_A_temperature
✅ 좋음: hexaboard/A/sensor/temperature
```

**2. 명확하고 일관성 있게**:
```
✅ 일관성 있음:
   device/A/sensor/temp
   device/A/sensor/humid
   device/B/sensor/temp

❌ 일관성 없음:
   deviceA_temp
   B-humidity
   sensor_deviceC_light
```

**3. 와일드카드 활용**:
- `+`: 한 레벨 와일드카드
  - `home/+/temperature` → `home/livingroom/temperature`, `home/bedroom/temperature`
- `#`: 다중 레벨 와일드카드
  - `home/#` → `home`으로 시작하는 모든 토픽

---

## QoS: 메시지 전달 보장

### QoS 레벨

MQTT는 3가지 품질 수준을 제공합니다:

**QoS 0 - At most once (최대 1회)**:
- 보내고 잊음 (Fire and Forget)
- 빠르지만 유실 가능
- 용도: 실시간 센서 데이터 (약간 유실되어도 괜찮음)

**QoS 1 - At least once (최소 1회)**:
- 받았다는 확인(ACK) 필요
- 중복 가능
- 용도: 중요한 데이터

**QoS 2 - Exactly once (정확히 1회)**:
- 4-way handshake
- 느리지만 확실함
- 용도: 결제, 제어 명령 등

**우리는 QoS 0을 주로 사용합니다** (센서 데이터는 계속 업데이트되므로)

---

## Retained Message

### 마지막 메시지 저장

**Retained** 플래그를 true로 설정하면:
- Broker가 마지막 메시지를 저장
- 새로운 구독자가 즉시 최신 값을 받음

**예시**:
```python
# Retained 메시지 발행
client.publish("hexaboard/status", "online", retain=True)

# 나중에 구독자가 연결되면...
# 즉시 "online"을 받음!
```

**용도**:
- 기기 상태 (online/offline)
- 마지막 설정 값
- 현재 모드

---

## Last Will and Testament (유언)

### 갑작스러운 연결 끊김 처리

헥사보드가 갑자기 전원이 꺼지면? 구독자들에게 어떻게 알릴까?

**LWT (Last Will and Testament)**:
```python
# 연결 시 유언 설정
client.will_set(
    topic="hexaboard/status",
    payload="offline",
    qos=1,
    retain=True
)
```

**동작**:
1. 헥사보드가 정상 연결
2. 갑자기 연결 끊김 (비정상)
3. Broker가 자동으로 "offline" 메시지 발행
4. 구독자들이 헥사보드가 오프라인임을 알게 됨

**Keep Alive**:
- 주기적으로 "나 살아있어!" 신호 전송
- 신호가 없으면 Broker가 LWT 발행
- 기본: 60초

---

## 실제 시나리오

### 스마트홈 예제

**기기들**:
- 거실 온도 센서
- 침실 온도 센서
- 보일러 제어기
- 스마트폰 앱

**Topic 설계**:
```
home/livingroom/temperature
home/bedroom/temperature
home/boiler/control
home/boiler/status
```

**흐름**:
1. 온도 센서들이 데이터 발행:
   ```
   home/livingroom/temperature → "22.5"
   home/bedroom/temperature → "20.1"
   ```

2. 스마트폰 앱이 모든 온도 구독:
   ```
   Subscribe: home/+/temperature
   ```

3. AI 서버가 분석 후 보일러 제어:
   ```
   Publish: home/boiler/control → {"mode": "heat", "target": 23}
   ```

4. 보일러가 상태 보고:
   ```
   Publish: home/boiler/status → {"current": 22.5, "heating": true}
   ```

---

## 핵심 요약

### MQTT의 장점

1. **가벼움**: 2바이트 헤더
2. **효율적**: 배터리 절약
3. **확장 가능**: 수백만 기기
4. **신뢰성**: QoS, LWT
5. **유연함**: Pub/Sub 패턴

### 핵심 개념

- **Broker**: 중개자
- **Publish**: 메시지 보내기
- **Subscribe**: 메시지 받기
- **Topic**: 메시지 주소
- **QoS**: 전달 품질
- **Retain**: 마지막 메시지 저장
- **LWT**: 연결 끊김 알림

---

## 다음 단계

MQTT의 개념을 이해했습니다! 📡

다음 챕터에서는 **HiveMQ Cloud**에 실제 Broker를 설정하고, 헥사보드와 연결해봅니다!

무료 클라우드 MQTT 서비스를 사용하여 전 세계 어디서나 접근 가능한 IoT 시스템을 만듭니다!

**준비되셨나요? 실전으로!** 🚀



---

# Chapter 12. HiveMQ Cloud: 무료 클라우드 Broker 설정

> **PART 4**: MQTT를 통한 센서 데이터 전송

---

## 클라우드의 힘

자체 서버를 운영하는 것은 복잡합니다. 전기세, 관리, 보안... 

다행히 **HiveMQ Cloud**는 무료로 MQTT Broker를 제공합니다. 평생 무료이며, 교육과 프로토타입에 충분합니다!

**HiveMQ Cloud의 장점**:
- 무료 플랜 (100개 연결, 월 10GB)
- 설치 불필요
- TLS 암호화 자동
- 전 세계 어디서나 접속
- 웹 관리 콘솔

5분이면 준비 완료입니다!

**예상 소요 시간**: 20분

---

## 실습: HiveMQ Cloud 설정

### Step 1: 계정 생성

1. https://www.hivemq.com/mqtt-cloud-broker/ 접속
2. "Sign Up" 또는 "Start Free" 클릭
3. 정보 입력:
   - 이메일
   - 비밀번호 (안전하게!)
   - 이름
4. 이메일 인증 (받은 이메일의 링크 클릭)

### Step 2: Cluster 생성

1. 로그인 후 "Create new cluster"
2. **Serverless** 플랜 선택 (무료!)
3. 설정:
   - Name: `hexaboard-lab` (원하는 이름)
   - Cloud: AWS
   - Region: `ap-northeast-2` (서울) - 가장 가까운 곳
4. "Create" → 1-2분 대기

### Step 3: 접속 정보 저장

Cluster가 생성되면:

1. Cluster 이름 클릭 → "Overview" 탭
2. **연결 정보 복사**:
   ```
   Host: xxx.s1.eu.hivemq.cloud
   Port: 8883 (TLS)
   ```
3. **자격 증명 생성**:
   - "Access Management" 탭
   - "Add Credentials"
   - Username: `hexaboard`
   - Password: 안전한 비밀번호 (저장!)

**메모장에 저장하세요**:
```
MQTT_BROKER = "xxx.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
```

---

## 테스트: MQTT.fx로 연결 확인

### MQTT.fx 다운로드

1. https://mqttfx.jensd.de/index.php/download
2. 본인 OS에 맞게 다운로드
3. 설치

### 연결 테스트

1. MQTT.fx 실행
2. 톱니바퀴(Settings) 클릭
3. "New"로 프로필 생성:
   - Profile Name: `HiveMQ Cloud`
   - Broker Address: 복사한 Host
   - Port: `8883`
   - Client ID: `test-client` (아무거나)
   - SSL/TLS: 체크
   - TLS Version: TLSv1.2
   - User Credentials:
     - Username: `hexaboard`
     - Password: 저장한 비밀번호
4. "OK" → 연결 버튼 클릭

**성공**: 초록불! 🟢

---

## Publish/Subscribe 테스트

### Subscribe (받기) 준비

1. "Subscribe" 탭
2. Topic 입력: `test/message`
3. "Subscribe" 버튼 클릭

### Publish (보내기)

1. "Publish" 탭
2. Topic: `test/message`
3. Message: `Hello MQTT!`
4. "Publish" 클릭

**결과**: Subscribe 탭에 메시지 도착! ✅

---

## 핵심 요약

### 준비 완료!

- HiveMQ Cloud 계정 생성
- 무료 Broker Cluster 생성
- 연결 정보 저장
- MQTT.fx로 테스트 완료

### 다음 단계

헥사보드를 Wi-Fi에 연결하고, MQTT로 센서 데이터를 전송합니다!

**준비되셨나요? 헥사보드 연결!** 📡



---

# Chapter 13. 헥사보드 MQTT 구현

> **PART 4**: MQTT를 통한 센서 데이터 전송

---

## 헥사보드를 인터넷에 연결

지금까지 헥사보드는 USB 케이블로만 통신했습니다. 이제 **Wi-Fi와 MQTT**로 전 세계와 연결합니다!

**이 챕터에서 배울 것**:
1. Wi-Fi 연결
2. MQTT Broker 연결
3. 센서 데이터 Publish
4. 제어 명령 Subscribe

**예상 소요 시간**: 40분

---

## 실습 1: Wi-Fi 연결

### 코드

```python
# 파일명: wifi_connect.py
import network
import time

WIFI_SSID = "Your_WiFi_Name"
WIFI_PASSWORD = "Your_Password"

def connect_wifi():
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    
    if not wlan.isconnected():
        print("Wi-Fi 연결 중...")
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)
        
        timeout = 10
        while not wlan.isconnected() and timeout > 0:
            print(".", end="")
            time.sleep(1)
            timeout -= 1
        print()
    
    if wlan.isconnected():
        print(f"✅ 연결 성공! IP: {wlan.ifconfig()[0]}")
        return True
    else:
        print("❌ 연결 실패")
        return False

connect_wifi()
```

---

## 실습 2: MQTT Publish (센서 데이터 전송)

### 코드

```python
# 파일명: mqtt_publish.py
from umqtt.simple import MQTTClient
import network
import dht
import time
import json
from machine import Pin

# Wi-Fi
WIFI_SSID = "Your_WiFi"
WIFI_PASSWORD = "Your_Password"

# MQTT (HiveMQ Cloud)
MQTT_BROKER = "xxx.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
TOPIC = "hexaboard/sensor/data"

# 센서
sensor = dht.DHT11(Pin(32))

def connect_wifi():
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    wlan.connect(WIFI_SSID, WIFI_PASSWORD)
    
    while not wlan.isconnected():
        time.sleep(1)
    print(f"Wi-Fi 연결: {wlan.ifconfig()[0]}")

def connect_mqtt():
    client = MQTTClient(
        client_id="hexaboard",
        server=MQTT_BROKER,
        port=MQTT_PORT,
        user=MQTT_USER,
        password=MQTT_PASSWORD,
        ssl=True
    )
    client.connect()
    print("MQTT 연결 성공")
    return client

# 연결
connect_wifi()
client = connect_mqtt()

# 데이터 전송
while True:
    try:
        sensor.measure()
        temp = sensor.temperature()
        humid = sensor.humidity()
        
        # JSON 생성
        data = {
            "temperature": temp,
            "humidity": humid,
            "timestamp": time.time()
        }
        
        # Publish
        client.publish(TOPIC, json.dumps(data))
        print(f"전송: {data}")
        
        time.sleep(5)
    
    except Exception as e:
        print(f"오류: {e}")
        time.sleep(5)
```

---

## 실습 3: MQTT Subscribe (제어 명령 받기)

### 코드

```python
# 파일명: mqtt_subscribe.py
from umqtt.simple import MQTTClient
import network
import neopixel
import json
from machine import Pin

# 설정 (위와 동일)
TOPIC_CONTROL = "hexaboard/control/led"

np = neopixel.NeoPixel(Pin(23), 25)

def callback(topic, msg):
    """메시지 수신 시 호출"""
    print(f"받음: {msg}")
    
    try:
        cmd = json.loads(msg)
        action = cmd.get("action")
        
        if action == "on":
            color = cmd.get("color", [100, 100, 100])
            for i in range(25):
                np[i] = tuple(color)
            np.write()
            print("LED ON")
        
        elif action == "off":
            for i in range(25):
                np[i] = (0, 0, 0)
            np.write()
            print("LED OFF")
    
    except Exception as e:
        print(f"처리 오류: {e}")

# 연결 (위와 동일)
client = connect_mqtt()
client.set_callback(callback)
client.subscribe(TOPIC_CONTROL)

print(f"구독 중: {TOPIC_CONTROL}")

# 메시지 대기
while True:
    client.check_msg()  # 메시지 확인
    time.sleep(0.1)
```

**테스트**: MQTT.fx에서 `hexaboard/control/led`로 메시지 전송:
```json
{"action": "on", "color": [255, 0, 0]}
```

---

## 핵심 요약

### 배운 것

1. Wi-Fi 연결: `network.WLAN`
2. MQTT Publish: `client.publish()`
3. MQTT Subscribe: `client.subscribe()` + `callback`
4. JSON 데이터 포맷

### 다음 단계

여러 헥사보드를 동시에 연결! 🚀



---

# Chapter 14. 멀티 헥사보드 시스템

> **PART 4**: MQTT를 통한 센서 데이터 전송

---

## 여러 기기의 협업

실제 IoT는 하나의 기기가 아닙니다. 집의 각 방, 공장의 각 기계, 도시의 각 센서... 수십, 수백 개가 동시에 동작합니다.

MQTT의 진가는 **멀티 디바이스**에서 드러납니다!

**이 챕터의 시나리오**:
- 헥사보드 A: 거실 센서
- 헥사보드 B: 침실 센서
- Python 서버: 모든 데이터 수집 및 분석

**예상 소요 시간**: 40분

---

## Topic 설계

### 보드별 구분

```
hexaboard/A/sensor/data
hexaboard/A/control/led
hexaboard/A/status

hexaboard/B/sensor/data
hexaboard/B/control/led
hexaboard/B/status
```

### 와일드카드 구독

```
hexaboard/+/sensor/data  → 모든 보드의 센서 데이터
hexaboard/#              → 모든 헥사보드 메시지
```

---

## 실습: 2개 보드 시스템

### 헥사보드 A 코드

```python
# board_A.py
BOARD_ID = "A"
TOPIC_SENSOR = f"hexaboard/{BOARD_ID}/sensor/data"
TOPIC_CONTROL = f"hexaboard/{BOARD_ID}/control/led"

# 센서 데이터 전송
while True:
    sensor.measure()
    data = {
        "board": BOARD_ID,
        "temp": sensor.temperature(),
        "humid": sensor.humidity()
    }
    client.publish(TOPIC_SENSOR, json.dumps(data))
    time.sleep(5)
```

### 헥사보드 B 코드

```python
# board_B.py
BOARD_ID = "B"
TOPIC_SENSOR = f"hexaboard/{BOARD_ID}/sensor/data"
TOPIC_CONTROL = f"hexaboard/{BOARD_ID}/control/led"

# 센서 데이터 전송 (동일)
```

### Python 모니터링 서버

```python
# monitor.py
import paho.mqtt.client as mqtt

def on_message(client, userdata, msg):
    data = json.loads(msg.payload)
    board = data['board']
    temp = data['temp']
    humid = data['humid']
    print(f"[{board}] 온도:{temp}°C 습도:{humid}%")

client = mqtt.Client()
client.on_message = on_message
client.connect("xxx.s1.eu.hivemq.cloud", 8883)
client.subscribe("hexaboard/+/sensor/data")  # 모든 보드
client.loop_forever()
```

---

## Part 4 완료! 🎉

**배운 것**:
- MQTT 개념
- HiveMQ Cloud 설정
- 헥사보드 MQTT 구현
- 멀티 보드 시스템

**다음 Part 5**: Python & AI! 🤖

센서 데이터를 AI로 분석하고, 자연어로 제어합니다!



---


# PART 5: Python + AI로 센서 데이터 분석 및 자동 제어

# Chapter 15. Python으로 MQTT 데이터 받기

> **PART 5**: Python + AI로 센서 데이터 분석 및 자동 제어

---

## PC에서 센서 데이터 받기

헥사보드가 MQTT로 센서 데이터를 전송하면, Python에서 받아서 처리합니다!

**이 챕터의 목표**:
- Python에서 MQTT 클라이언트 구현
- 센서 데이터 수신 및 파싱
- 데이터베이스 저장 (간단 버전)

**예상 소요 시간**: 30분

---

## 실습: Python MQTT 클라이언트

### 라이브러리 설치

```bash
pip install paho-mqtt
```

### 코드

```python
# mqtt_receiver.py
import paho.mqtt.client as mqtt
import json
from datetime import datetime

MQTT_BROKER = "xxx.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
TOPIC = "hexaboard/+/sensor/data"

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("✅ MQTT 연결 성공")
        client.subscribe(TOPIC)
        print(f"구독: {TOPIC}")
    else:
        print(f"❌ 연결 실패: {rc}")

def on_message(client, userdata, msg):
    try:
        data = json.loads(msg.payload.decode())
        board = data.get('board', 'unknown')
        temp = data.get('temperature')
        humid = data.get('humidity')
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        print(f"[{timestamp}] {board} | 온도: {temp}°C, 습도: {humid}%")
        
        # 여기에 데이터 저장/분석 로직 추가
        
    except Exception as e:
        print(f"오류: {e}")

# 클라이언트 생성
client = mqtt.Client()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)
client.tls_set()  # TLS 활성화
client.on_connect = on_connect
client.on_message = on_message

# 연결 및 루프
print("MQTT 수신 서버 시작...")
client.connect(MQTT_BROKER, MQTT_PORT, 60)
client.loop_forever()
```

**실행**: `python mqtt_receiver.py`

---

## 데이터 저장 (CSV)

```python
import csv

def save_to_csv(data):
    with open('sensor_data.csv', 'a', newline='') as f:
        writer = csv.writer(f)
        writer.writerow([
            datetime.now(),
            data['board'],
            data['temperature'],
            data['humidity']
        ])

# on_message 함수에서 호출
save_to_csv(data)
```

---

## 핵심 요약

Python에서 MQTT 데이터를 받아 처리할 수 있습니다!

**다음**: OpenAI API로 데이터 분석! 🤖


---

# Chapter 16. 센서 데이터 요약 및 해석

> **PART 5**: Python + AI로 센서 데이터 분석 및 자동 제어

---

## 데이터에서 인사이트로

단순히 "24°C, 65%"를 저장하는 것을 넘어서, **의미 있는 정보**를 추출합니다!

**이 챕터에서 배울 것**:
- 통계 분석 (평균, 최소, 최대)
- 추세 분석 (상승, 하강)
- 이상치 감지
- 상태 판단

**예상 소요 시간**: 30분

---

## 데이터 요약

```python
class SensorAnalyzer:
    def __init__(self):
        self.data = []
    
    def add(self, temp, humid):
        self.data.append({'temp': temp, 'humid': humid})
        if len(self.data) > 100:  # 최근 100개만 유지
            self.data.pop(0)
    
    def get_stats(self):
        if not self.data:
            return None
        
        temps = [d['temp'] for d in self.data]
        humids = [d['humid'] for d in self.data]
        
        return {
            'temp_avg': sum(temps) / len(temps),
            'temp_min': min(temps),
            'temp_max': max(temps),
            'humid_avg': sum(humids) / len(humids),
            'humid_min': min(humids),
            'humid_max': max(humids),
        }
    
    def get_trend(self):
        if len(self.data) < 10:
            return "insufficient_data"
        
        recent = [d['temp'] for d in self.data[-10:]]
        old = [d['temp'] for d in self.data[-20:-10]]
        
        if sum(recent) > sum(old) * 1.05:
            return "rising"
        elif sum(recent) < sum(old) * 0.95:
            return "falling"
        else:
            return "stable"
```

---

## 상태 판단

```python
def get_environment_status(temp, humid):
    """환경 상태 판단"""
    
    # 온도 평가
    if temp < 18:
        temp_status = "too_cold"
    elif temp > 28:
        temp_status = "too_hot"
    else:
        temp_status = "comfortable"
    
    # 습도 평가
    if humid < 30:
        humid_status = "too_dry"
    elif humid > 70:
        humid_status = "too_humid"
    else:
        humid_status = "comfortable"
    
    # 종합 평가
    if temp_status == "comfortable" and humid_status == "comfortable":
        return "쾌적합니다"
    else:
        issues = []
        if temp_status != "comfortable":
            issues.append(f"온도가 {temp_status}")
        if humid_status != "comfortable":
            issues.append(f"습도가 {humid_status}")
        return ", ".join(issues)
```

---

## 핵심 요약

데이터를 분석하여 의미 있는 정보로 변환했습니다!

**다음**: OpenAI API로 자연어 분석! 🤖


---

# Chapter 17. OpenAI API 연동: AI의 힘 빌리기

> **PART 5**: Python + AI로 센서 데이터 분석 및 자동 제어

---

## AI가 센서 데이터를 이해하게 만들기

ChatGPT의 힘을 IoT에 적용합니다!

**OpenAI API로 할 수 있는 것**:
- 센서 데이터를 자연어로 해석
- 사용자 명령을 이해하고 실행
- 상황에 맞는 조언 제공

**예상 소요 시간**: 40분

---

## 준비: API 키 발급

1. https://platform.openai.com 접속
2. 회원가입/로그인
3. API Keys → "Create new secret key"
4. 키 저장 (다시 볼 수 없음!)

### 비용
- 첫 $5 무료 크레딧
- GPT-3.5-turbo: 매우 저렴 ($0.002/1K tokens)

---

## 실습: 센서 데이터 해석

```python
from openai import OpenAI
import os

client = OpenAI(api_key="your-api-key-here")

def analyze_sensor_data(temp, humid):
    prompt = f"""
    현재 센서 데이터:
    - 온도: {temp}°C
    - 습도: {humid}%
    
    이 환경 상태를 평가하고, 사용자에게 조언을 한 문장으로 제공해주세요.
    """
    
    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": "당신은 IoT 환경 모니터링 AI 어시스턴트입니다."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=100
    )
    
    return response.choices[0].message.content

# 사용
advice = analyze_sensor_data(28, 75)
print(advice)
# 출력 예: "온도가 약간 높고 습도도 높아 불쾌지수가 높습니다. 제습기를 사용하시는 것을 추천드립니다."
```

---

## 자연어 명령 처리

```python
def process_natural_command(command):
    prompt = f"""
    사용자 명령: "{command}"
    
    이 명령을 분석하여 다음 JSON 형식으로 반환하세요:
    {{
        "action": "led_on" 또는 "led_off" 또는 "unknown",
        "color": [R, G, B] (0-255),
        "brightness": 0-100
    }}
    
    예시:
    "빨간불 켜줘" → {{"action": "led_on", "color": [255,0,0], "brightness": 100}}
    "조명 끄기" → {{"action": "led_off"}}
    """
    
    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}],
        max_tokens=100
    )
    
    return json.loads(response.choices[0].message.content)

# 사용
cmd = process_natural_command("따뜻한 노란색으로 밝게 켜줘")
print(cmd)
# {"action": "led_on", "color": [255, 200, 0], "brightness": 90}
```

---

## 핵심 요약

OpenAI API로 AI의 자연어 이해 능력을 활용했습니다!

**다음**: AI 응답을 헥사보드 제어 명령으로 변환! 🎮


---

# Chapter 18. AI 응답을 제어 명령으로 변환

> **PART 5**: Python + AI로 센서 데이터 분석 및 자동 제어

---

## AI의 판단을 행동으로

AI가 "온도가 높으니 조명을 파란색으로 바꾸세요"라고 말하면, 실제로 헥사보드를 제어해야 합니다!

**이 챕터의 흐름**:
1. AI가 상황 분석
2. 적절한 제어 명령 생성
3. MQTT로 헥사보드에 전송
4. 헥사보드가 실행

**예상 소요 시간**: 30분

---

## AI → MQTT 제어

```python
def ai_control_system(temp, humid):
    # 1. AI에게 상황 판단 요청
    prompt = f"""
    온도: {temp}°C, 습도: {humid}%
    
    이 환경에 적합한 LED 색상을 추천하고, 다음 JSON으로 반환:
    {{
        "color": [R, G, B],
        "reason": "이유 설명"
    }}
    
    규칙:
    - 더우면 시원한 파란색
    - 추우면 따뜻한 빨간색
    - 쾌적하면 부드러운 초록색
    """
    
    response = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}]
    )
    
    ai_decision = json.loads(response.choices[0].message.content)
    
    # 2. MQTT 명령 생성
    command = {
        "action": "led_on",
        "color": ai_decision["color"],
        "brightness": 80
    }
    
    # 3. 헥사보드에 전송
    mqtt_client.publish("hexaboard/A/control/led", json.dumps(command))
    
    print(f"AI 판단: {ai_decision['reason']}")
    print(f"명령 전송: {command}")
    
    return ai_decision

# 실행
ai_control_system(29, 70)
# AI 판단: 온도가 높고 습도도 높아 시원한 파란색을 추천합니다
# 명령 전송: {"action": "led_on", "color": [0, 100, 200], "brightness": 80}
```

---

## 자동 제어 루프

```python
import time

def auto_control_loop():
    print("AI 자동 제어 시작...")
    
    while True:
        # 1. 최신 센서 데이터 가져오기 (전역 변수 or DB)
        latest = get_latest_sensor_data()
        
        if latest:
            temp = latest['temperature']
            humid = latest['humidity']
            
            # 2. AI 판단 및 제어
            result = ai_control_system(temp, humid)
            
            print(f"[{datetime.now()}] 제어 완료")
        
        # 3. 30초 대기
        time.sleep(30)

# 시작
auto_control_loop()
```

---

## 핵심 요약

AI의 판단이 실제 하드웨어 제어로 연결되었습니다!

**다음**: 전체 시스템 통합! 🎯


---

# Chapter 19. 전체 시스템 통합: AI 기반 자동 제어

> **PART 5**: Python + AI로 센서 데이터 분석 및 자동 제어

---

## 모든 것을 하나로

지금까지 배운 모든 것을 통합합니다!

**완전한 시스템**:
1. 헥사보드: 센서 데이터 → MQTT Publish
2. Python: MQTT Subscribe → 데이터 수집
3. AI: 데이터 분석 → 제어 판단
4. Python: MQTT Publish → 제어 명령
5. 헥사보드: MQTT Subscribe → LED 제어

**무한 루프로 자동 동작!**

---

## 통합 코드

```python
# full_system.py
import paho.mqtt.client as mqtt
from openai import OpenAI
import json
import time
from datetime import datetime

# 설정
MQTT_BROKER = "xxx.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"

openai_client = OpenAI(api_key="your-openai-key")

# 전역 변수
latest_data = {}

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("✅ MQTT 연결")
        client.subscribe("hexaboard/+/sensor/data")

def on_message(client, userdata, msg):
    global latest_data
    data = json.loads(msg.payload.decode())
    latest_data = data
    print(f"📊 데이터 수신: {data}")
    
    # AI 자동 제어 트리거
    if data:
        ai_auto_control(client, data)

def ai_auto_control(mqtt_client, data):
    temp = data['temperature']
    humid = data['humidity']
    board = data.get('board', 'A')
    
    # AI 판단
    prompt = f"""
    센서 데이터: 온도 {temp}°C, 습도 {humid}%
    
    LED 색상 추천 (JSON):
    {{"color": [R,G,B], "reason": "이유"}}
    
    규칙: 더우면 파랑, 추우면 빨강, 쾌적하면 초록
    """
    
    response = openai_client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}],
        max_tokens=100
    )
    
    ai_result = json.loads(response.choices[0].message.content)
    
    # 제어 명령 전송
    command = {
        "action": "led_on",
        "color": ai_result["color"],
        "brightness": 70
    }
    
    topic = f"hexaboard/{board}/control/led"
    mqtt_client.publish(topic, json.dumps(command))
    
    print(f"🤖 AI: {ai_result['reason']}")
    print(f"📤 제어: {command}")

# MQTT 클라이언트
client = mqtt.Client()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)
client.tls_set()
client.on_connect = on_connect
client.on_message = on_message

# 시작
print("=" * 50)
print("  AI 기반 자동 제어 시스템")
print("=" * 50)
print("시작 시간:", datetime.now())
print()

client.connect(MQTT_BROKER, MQTT_PORT, 60)
client.loop_forever()
```

---

## Part 5 완료! 🎉

**배운 것**:
- Python MQTT 클라이언트
- 데이터 분석 및 통계
- OpenAI API 연동
- AI → 제어 명령 변환
- 전체 시스템 통합

**다음 Part 6**: 실전 프로젝트! 🚀

AI 환경 무드 컨트롤러를 만듭니다!


---


# PART 6: 실전 프로젝트 – AI 환경 무드 컨트롤러 만들기

# Chapter 20. 프로젝트: AI 환경 무드 컨트롤러

> **PART 6**: 실전 프로젝트 – AI 환경 무드 컨트롤러 만들기

---

## 실전 프로젝트의 시작

지금까지 배운 모든 것을 하나의 완성된 프로젝트로 만듭니다!

**AI 환경 무드 컨트롤러**:
- 센서로 온도/습도/밝기 측정
- AI가 환경 상태 분석
- 자동으로 LED 색상/밝기 조절
- 사용자의 기분에 맞는 분위기 연출

**실생활 활용**:
- 스마트 홈 분위기 조명
- 공부방 집중 모드
- 수면 환경 최적화
- 식물 생장 환경 모니터링

**예상 소요 시간**: 1시간

---

## 프로젝트 개요

### 시스템 구성

```
[헥사보드]
  ├─ DHT11 (온습도)
  ├─ 조도센서
  ├─ NeoPixel LED
  └─ MQTT Client
       ↓
[MQTT Broker]
  (HiveMQ Cloud)
       ↓
[Python AI Server]
  ├─ 데이터 수집
  ├─ OpenAI 분석
  └─ 자동 제어
```

### 주요 기능

1. **자동 모드**: AI가 센서 데이터 기반으로 최적 분위기 설정
2. **수동 모드**: 사용자가 원하는 색상 직접 선택
3. **시간대별 모드**: 아침/낮/저녁/밤 자동 전환
4. **기분 모드**: "집중", "휴식", "파티" 등 프리셋

---

## 핵심 요약

완성된 프로젝트의 청사진을 그렸습니다!

**다음**: 시스템 아키텍처 설계! 🏗️


---

# Chapter 21. 시스템 아키텍처 설계

> **PART 6**: 실전 프로젝트 – AI 환경 무드 컨트롤러 만들기

---

## 설계의 중요성

코드를 작성하기 전에 전체 구조를 설계합니다!

**아키텍처 설계**:
- 데이터 흐름 정의
- Topic 구조 설계
- 상태 관리 방식
- 오류 처리 전략

---

## Topic 설계

```
hexaboard/sensor/temperature
hexaboard/sensor/humidity  
hexaboard/sensor/light
hexaboard/control/led
hexaboard/control/mode
hexaboard/status
```

## 데이터 구조

**센서 데이터** (JSON):
```json
{
  "temperature": 24,
  "humidity": 60,
  "light": 2500,
  "timestamp": 1234567890
}
```

**제어 명령** (JSON):
```json
{
  "action": "led_on",
  "color": [255, 100, 50],
  "brightness": 80,
  "mode": "auto"
}
```

---

## 상태 머신

```
[INIT] → [MEASURING] → [AI_ANALYSIS] → [CONTROL] → [MEASURING]
                           ↓
                       [ERROR] → [RETRY]
```

**다음**: 실제 구현! 💻


---

# Chapter 22. 단계별 구현

> **PART 6**: 실전 프로젝트 – AI 환경 무드 컨트롤러 만들기

---

## 구현 시작!

설계한 시스템을 실제 코드로 만듭니다!

### 헥사보드 코드

```python
# mood_controller_hexaboard.py
from machine import Pin, ADC
import dht
import neopixel
from umqtt.simple import MQTTClient
import json
import time

# 센서 설정
temp_sensor = dht.DHT11(Pin(32))
light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)
np = neopixel.NeoPixel(Pin(23), 25)

# MQTT
client = MQTTClient("hexaboard", "broker.hivemq.cloud", 8883, 
                    user="user", password="pass", ssl=True)

def measure_and_send():
    temp_sensor.measure()
    data = {
        "temperature": temp_sensor.temperature(),
        "humidity": temp_sensor.humidity(),
        "light": light_sensor.read()
    }
    client.publish("hexaboard/sensor/data", json.dumps(data))
    return data

def on_control(topic, msg):
    cmd = json.loads(msg)
    if cmd['action'] == 'led_on':
        color = cmd['color']
        for i in range(25):
            np[i] = tuple(color)
        np.write()

client.set_callback(on_control)
client.subscribe("hexaboard/control/led")
client.connect()

while True:
    measure_and_send()
    client.check_msg()
    time.sleep(5)
```

### Python AI 서버

```python
# mood_controller_server.py
import paho.mqtt.client as mqtt
from openai import OpenAI
import json

openai_client = OpenAI(api_key="your-key")

def on_message(client, userdata, msg):
    data = json.loads(msg.payload)
    
    # AI 분석
    prompt = f"""
    센서: 온도 {data['temperature']}°C, 습도 {data['humidity']}%, 밝기 {data['light']}
    
    최적의 LED 색상을 JSON으로 추천:
    {{"color": [R,G,B], "reason": "이유"}}
    """
    
    response = openai_client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}]
    )
    
    ai_result = json.loads(response.choices[0].message.content)
    
    # 제어 명령 전송
    command = {"action": "led_on", "color": ai_result["color"]}
    client.publish("hexaboard/control/led", json.dumps(command))
    
    print(f"AI: {ai_result['reason']}")

client = mqtt.Client()
client.tls_set()
client.username_pw_set("user", "pass")
client.on_message = on_message
client.connect("broker.hivemq.cloud", 8883)
client.subscribe("hexaboard/sensor/data")
client.loop_forever()
```

**완성!** 🎉

**다음**: AI 프롬프트 튜닝! 🎯


---

# Chapter 23. AI 프롬프트 튜닝 및 실험

> **PART 6**: 실전 프로젝트 – AI 환경 무드 컨트롤러 만들기

---

## AI를 더 똑똑하게

프롬프트를 개선하여 AI의 판단을 정교하게 만듭니다!

### 기본 프롬프트

```python
"온도 24°C, 습도 60%. LED 색상 추천해줘"
```

### 개선된 프롬프트

```python
"""
당신은 전문 조명 디자이너입니다.

현재 환경:
- 온도: 24°C
- 습도: 60%
- 시간: 22:00 (저녁)

요구사항:
1. 편안한 수면 환경 조성
2. 눈의 피로 최소화
3. 은은한 분위기

다음 JSON 형식으로 답변:
{
  "color": [R, G, B],
  "brightness": 0-100,
  "reason": "선택 이유"
}

규칙:
- 온도 > 26°C: 시원한 파란색 계열
- 온도 < 20°C: 따뜻한 빨간색 계열
- 저녁: 밝기 30% 이하
"""
```

### 결과 비교

**기본**: `[100, 100, 100]` (평범한 흰색)
**개선**: `[255, 140, 100]` (따뜻한 주황빛, 밝기 25%)

---

## 실험 아이디어

1. **시간대별 색온도** 조정
2. **날씨 API** 연동
3. **사용자 피드백** 학습
4. **다양한 프리셋** 구현

**Part 6 완료!** 🎉

**다음 Part 7**: 웹 대시보드! 🌐


---


# PART 7: 웹 대시보드로 모니터링과 제어

# Chapter 24. 웹 기반 센서 모니터링

> **PART 7**: 웹 대시보드로 모니터링과 제어

---

## 웹으로 보는 센서 데이터

스마트폰이나 PC 브라우저로 실시간 센서 데이터를 확인합니다!

**Tailwind CSS**로 깔끔한 UI를 빠르게 만듭니다!

---

## HTML + Tailwind CSS

```html
<!DOCTYPE html>
<html>
<head>
    <title>헥사보드 모니터링</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold mb-8">🌡️ 헥사보드 센서 모니터링</h1>
        
        <div class="grid grid-cols-3 gap-4">
            <div class="bg-white p-6 rounded-lg shadow">
                <h2 class="text-gray-600 mb-2">온도</h2>
                <p class="text-4xl font-bold text-red-500" id="temp">--°C</p>
            </div>
            
            <div class="bg-white p-6 rounded-lg shadow">
                <h2 class="text-gray-600 mb-2">습도</h2>
                <p class="text-4xl font-bold text-blue-500" id="humid">--%</p>
            </div>
            
            <div class="bg-white p-6 rounded-lg shadow">
                <h2 class="text-gray-600 mb-2">밝기</h2>
                <p class="text-4xl font-bold text-yellow-500" id="light">--</p>
            </div>
        </div>
        
        <div class="mt-4 bg-white p-4 rounded-lg shadow">
            <h3 class="font-bold mb-2">최근 데이터</h3>
            <ul id="log" class="text-sm text-gray-600 space-y-1"></ul>
        </div>
    </div>
    
    <script>
        const client = mqtt.connect('wss://broker.hivemq.cloud:8884/mqtt', {
            username: 'user',
            password: 'pass'
        });
        
        client.on('connect', () => {
            console.log('연결됨');
            client.subscribe('hexaboard/sensor/data');
        });
        
        client.on('message', (topic, message) => {
            const data = JSON.parse(message);
            document.getElementById('temp').textContent = data.temperature + '°C';
            document.getElementById('humid').textContent = data.humidity + '%';
            document.getElementById('light').textContent = data.light;
            
            const log = document.getElementById('log');
            const entry = document.createElement('li');
            entry.textContent = `${new Date().toLocaleTimeString()} - 온도: ${data.temperature}°C`;
            log.insertBefore(entry, log.firstChild);
            if (log.children.length > 10) log.lastChild.remove();
        });
    </script>
</body>
</html>
```

**웹 브라우저로 실시간 모니터링 완성!** 📊

**다음**: 웹에서 LED 제어! 🎮


---

# Chapter 25. 웹 기반 수동 LED 제어

> **PART 7**: 웹 대시보드로 모니터링과 제어

---

## 웹에서 LED 제어하기

브라우저에서 버튼 클릭으로 헥사보드 LED를 제어합니다!

---

## HTML + JavaScript

```html
<!DOCTYPE html>
<html>
<head>
    <title>헥사보드 제어</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-2xl mx-auto">
        <h1 class="text-3xl font-bold mb-8">🎮 LED 제어판</h1>
        
        <div class="bg-white p-8 rounded-lg shadow">
            <h2 class="text-xl font-bold mb-4">색상 선택</h2>
            <div class="grid grid-cols-4 gap-4">
                <button onclick="setColor([255,0,0])" class="p-4 rounded-lg bg-red-500">빨강</button>
                <button onclick="setColor([0,255,0])" class="p-4 rounded-lg bg-green-500">초록</button>
                <button onclick="setColor([0,0,255])" class="p-4 rounded-lg bg-blue-500">파랑</button>
                <button onclick="setColor([255,255,0])" class="p-4 rounded-lg bg-yellow-500">노랑</button>
            </div>
            
            <button onclick="setColor([0,0,0])" class="mt-4 w-full p-4 rounded-lg bg-gray-800 text-white">
                끄기
            </button>
        </div>
    </div>
    
    <script>
        const client = mqtt.connect('wss://broker.hivemq.cloud:8884/mqtt', {
            username: 'user',
            password: 'pass'
        });
        
        client.on('connect', () => console.log('연결됨'));
        
        function setColor(rgb) {
            const command = {
                action: rgb[0] === 0 && rgb[1] === 0 && rgb[2] === 0 ? 'led_off' : 'led_on',
                color: rgb
            };
            client.publish('hexaboard/control/led', JSON.stringify(command));
        }
    </script>
</body>
</html>
```

**웹에서 LED 제어 완성!** 🎨

**다음**: 웹에서 자연어 AI 제어! 🤖


---

# Chapter 26. 웹 기반 자연어 AI 제어

> **PART 7**: 웹 대시보드로 모니터링과 제어

---

## 말로 제어하기

"따뜻한 분위기로 해줘", "집중 모드", "파티!"
자연어로 헥사보드를 제어합니다!

---

## Flask API 서버

```python
# ai_control_server.py
from flask import Flask, request, jsonify
from flask_cors import CORS
from openai import OpenAI
import paho.mqtt.client as mqtt

app = Flask(__name__)
CORS(app)

openai_client = OpenAI(api_key="your-key")
mqtt_client = mqtt.Client()
mqtt_client.connect("broker.hivemq.cloud", 8883)

@app.route('/ai-control', methods=['POST'])
def ai_control():
    command = request.json['command']
    
    prompt = f"""
    사용자 명령: "{command}"
    
    LED 제어 JSON:
    {{"action": "led_on", "color": [R,G,B], "reason": "이유"}}
    """
    
    response = openai_client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}]
    )
    
    result = json.loads(response.choices[0].message.content)
    mqtt_client.publish("hexaboard/control/led", json.dumps(result))
    
    return jsonify(result)

app.run(port=5000)
```

## HTML 프론트엔드

```html
<div class="bg-white p-8 rounded-lg shadow">
    <h2 class="text-xl font-bold mb-4">🗣️ 자연어 제어</h2>
    <input id="command" type="text" placeholder="예: 따뜻한 분위기로 해줘"
           class="w-full p-3 border rounded-lg mb-4">
    <button onclick="sendAICommand()"
            class="w-full p-4 bg-blue-500 text-white rounded-lg">
        실행
    </button>
    <p id="ai-response" class="mt-4 text-gray-600"></p>
</div>

<script>
    async function sendAICommand() {
        const command = document.getElementById('command').value;
        const response = await fetch('http://localhost:5000/ai-control', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({command})
        });
        const result = await response.json();
        document.getElementById('ai-response').textContent = `AI: ${result.reason}`;
    }
</script>
```

**Part 7 완료!** 🎉

**다음 Part 8**: 교육 활용! 📚


---


# PART 8: 교육 현장에서 활용하기

# Chapter 27. 교육 커리큘럼 설계 가이드

> **PART 8**: 교육 현장에서 활용하기

---

## AIoT 교육 과정 설계

이 교재를 활용한 교육 커리큘럼을 설계합니다!

### 초급 과정 (4주, 주 2회)

**Week 1-2: 기초**
- 헥사보드 구조 이해
- 버튼, LED 제어
- 센서 데이터 읽기

**Week 3: 통신**
- MQTT 개념
- 데이터 전송

**Week 4: 프로젝트**
- 간단한 IoT 시스템 구축

### 중급 과정 (6주)

**Week 1-2: 센서 심화**
- 데이터 처리
- 시각화

**Week 3-4: Python 연동**
- MQTT 클라이언트
- 데이터 분석

**Week 5-6: AI 연동**
- OpenAI API
- 자동 제어

### 고급 과정 (8주)

**Week 1-4: 프로젝트**
- AI 무드 컨트롤러
- 웹 대시보드

**Week 5-8: 확장**
- 멀티 보드 시스템
- 고급 AI 튜닝
- 실전 프로젝트

---

## 평가 방법

1. **실습 과제** (50%)
2. **프로젝트** (30%)
3. **발표** (20%)

**다음**: 미션 기반 평가! 🎯


---

# Chapter 28. 미션 기반 실습 과제 및 평가

> **PART 8**: 교육 현장에서 활용하기

---

## 실전 미션으로 학습하기

단순 암기가 아닌 문제 해결로 배웁니다!

### 미션 1: 스마트 알람 ⭐️

**목표**: 조도 센서로 아침 햇빛을 감지하여 LED가 서서히 밝아지는 알람 만들기

**요구사항**:
- 밝기가 특정 값 이상이면 LED 시작
- 5분 동안 서서히 밝아짐
- 음악 대신 LED로 기상 유도

**평가 기준**:
- 센서 활용 (30%)
- LED 제어 정확도 (40%)
- 코드 품질 (30%)

### 미션 2: 원격 환경 모니터링 ⭐️⭐️

**목표**: MQTT로 센서 데이터를 전송하고 Python으로 수집하여 CSV 저장

**요구사항**:
- 5초마다 데이터 전송
- CSV 파일로 저장
- 그래프로 시각화

**평가 기준**:
- MQTT 통신 (30%)
- 데이터 저장 (30%)
- 시각화 (40%)

### 미션 3: AI 홈 어시스턴트 ⭐️⭐️⭐️

**목표**: 자연어 명령으로 헥사보드 제어

**요구사항**:
- OpenAI API 연동
- 다양한 명령어 지원
- 웹 인터페이스

**평가 기준**:
- AI 통합 (40%)
- 명령 처리 (30%)
- UI/UX (30%)

---

## 프로젝트 루브릭

| 항목 | 미흡(1) | 보통(2) | 우수(3) | 탁월(4) |
|------|---------|---------|---------|---------|
| 기능 완성도 | 작동 안 함 | 부분 작동 | 대부분 작동 | 완벽 작동 |
| 코드 품질 | 읽기 어려움 | 보통 | 깔끔함 | 모범적 |
| 창의성 | 없음 | 기본 | 좋음 | 혁신적 |

**다음**: 확장 아이디어! 🚀


---

# Chapter 29. 확장 아이디어 및 다음 단계

> **PART 8**: 교육 현장에서 활용하기

---

## 여정의 끝, 새로운 시작

축하합니다! 29개 챕터를 모두 완료했습니다! 🎉

이제 배운 것을 바탕으로 더 큰 프로젝트로 나아갑니다!

---

## 확장 아이디어

### 1. 스마트 홈 시스템 🏠

**추가 센서**:
- 동작 감지 (PIR 센서)
- 문/창문 감지 (자석 센서)
- 공기질 센서 (MQ-135)

**기능**:
- 자동 조명 제어
- 침입 감지 알림
- 에너지 절약 모드

### 2. 식물 케어 시스템 🌱

**센서**:
- 토양 습도
- 수위 센서
- 일조량 측정

**기능**:
- 자동 물주기
- 생장 환경 최적화
- 성장 일지 기록

### 3. 스마트 팜 모니터링 🌾

**멀티 센서**:
- 온실 각 구역별 센서
- CO2 농도
- 토양 pH

**AI 분석**:
- 수확 시기 예측
- 병충해 조기 감지
- 최적 재배 조건 추천

### 4. 공부방 집중도 향상 📚

**센서**:
- 책상 조도
- 실내 CO2
- 소음 측정

**AI 기능**:
- 집중 모드 자동 전환
- 휴식 시간 추천
- 학습 환경 최적화

### 5. IoT 애완동물 케어 🐱

**기능**:
- 원격 급식기
- 활동량 모니터링
- 온도/습도 관리
- 카메라 연동

---

## 다음 학습 방향

### 하드웨어 확장

- **ESP32-CAM**: 카메라 모듈
- **LoRa**: 장거리 통신
- **BLE**: 블루투스 저전력
- **태양광 패널**: 독립 전원

### 소프트웨어 심화

- **데이터베이스**: InfluxDB, MongoDB
- **시각화**: Grafana, Plotly
- **음성 인식**: Whisper API
- **엣지 AI**: TinyML

### 클라우드 서비스

- **AWS IoT Core**: 엔터프라이즈급
- **Azure IoT Hub**: 마이크로소프트 생태계
- **Google Cloud IoT**: 빅데이터 분석

---

## 커뮤니티 및 리소스

### 온라인 커뮤니티

- **MicroPython Forum**: https://forum.micropython.org
- **Adafruit Learn**: https://learn.adafruit.com
- **Hackster.io**: 프로젝트 공유

### 추천 도서

- "Programming ESP32 with MicroPython"
- "IoT Projects with MQTT"
- "Practical AI on the Edge"

### 공개 프로젝트

- GitHub에서 "ESP32 IoT" 검색
- Arduino Project Hub
- Instructables IoT

---

## 마지막 메시지

**여러분은 이제**:
- IoT 시스템을 설계하고 구현할 수 있습니다
- 센서 데이터를 수집하고 분석할 수 있습니다
- AI를 IoT에 통합할 수 있습니다
- MQTT로 기기들을 연결할 수 있습니다
- 웹 대시보드를 만들 수 있습니다

**무한한 가능성이 열렸습니다!**

이 책은 끝이지만, 여러분의 IoT 여정은 이제 시작입니다.

배운 것을 바탕으로:
- 자신만의 프로젝트를 만들어보세요
- 커뮤니티에 공유하세요
- 다른 사람들을 도와주세요
- 계속 학습하고 실험하세요

**The future is connected. Make it yours!** 🚀🌟

---

## 감사의 말

이 여정을 함께해주셔서 감사합니다.

질문이나 피드백이 있다면 언제든 연락주세요!

**Happy Making!** 🎉

---

**부록**:
- A. 센서 핀아웃 참고표
- B. MQTT Topic 설계 베스트 프랙티스
- C. OpenAI API 요금 최적화 팁
- D. 문제 해결 FAQ
- E. 참고 자료 및 링크

---

**전자책 끝**

HexaBoard AI Sensor Lab  
Version 1.0  
2025



---


---

# 에필로그

## 여정을 마치며

29개의 챕터, 8개의 파트를 모두 완료하신 것을 축하합니다! 🎉

여러분은 이제:
- IoT 하드웨어를 자유자재로 다룰 수 있습니다
- 센서 데이터를 수집하고 분석할 수 있습니다
- MQTT로 무선 통신 시스템을 구축할 수 있습니다
- AI를 IoT에 통합할 수 있습니다
- 웹 대시보드로 시각화할 수 있습니다

## 이제 무엇을 할까요?

**1. 자신만의 프로젝트**
- 배운 것을 조합하여 독창적인 프로젝트 만들기
- 실생활 문제를 IoT로 해결하기

**2. 커뮤니티 참여**
- 프로젝트를 GitHub에 공유
- 다른 메이커들과 협업
- 오픈소스에 기여

**3. 계속 학습**
- 더 많은 센서 실험
- 다양한 통신 프로토콜 (LoRa, BLE)
- 엣지 AI (TinyML)
- 클라우드 서비스 (AWS IoT, Azure)

## 감사의 말

이 여정을 함께해주셔서 감사합니다.

IoT와 AI는 빠르게 발전하는 분야입니다. 이 책은 시작점일 뿐입니다. 계속해서 새로운 것을 시도하고, 실패하고, 배우세요.

**"The best way to predict the future is to create it."**
— Alan Kay

여러분의 창작물이 세상을 더 나은 곳으로 만들기를 바랍니다.

**Happy Making! 🚀✨**

---

## 부록

### A. 센서 핀아웃 참고표

**헥사보드 GPIO 맵**:
- GPIO 23: NeoPixel LED
- GPIO 32: DHT11 (PIN1)
- GPIO 33: Light Sensor (PIN2)
- GPIO 34: Button B
- GPIO 35: Button A

### B. MQTT Topic 설계 베스트 프랙티스

1. 명확한 계층 구조 사용
2. 소문자 사용 권장
3. 와일드카드 활용 (`+`, `#`)
4. 버전 관리 고려

### C. OpenAI API 요금 최적화 팁

1. 토큰 수 제한 (`max_tokens`)
2. 프롬프트 최적화
3. 캐싱 활용
4. 배치 처리

### D. 문제 해결 FAQ

**Q: Wi-Fi 연결이 안 돼요**
A: 2.4GHz 확인, SSID/비밀번호 재확인

**Q: MQTT 연결 실패**
A: TLS 설정, 포트 번호(8883), 자격 증명 확인

**Q: AI API 오류**
A: API 키 확인, 크레딧 잔액 확인

### E. 참고 자료

**공식 문서**:
- MicroPython: https://docs.micropython.org
- MQTT: https://mqtt.org
- OpenAI API: https://platform.openai.com/docs

**커뮤니티**:
- MicroPython Forum
- Reddit: r/esp32, r/IoT
- Discord: IoT Makers

---

**HexaBoard AI Sensor Lab**  
Version 2.0 (Rewrite Edition)  
2025-12-15

**End of Book**

