# Chapter 2. 헥사보드 구조 한눈에 보기

> **PART 1**: AI 센서랩과 헥사보드 이해하기

---

## 여러분의 새로운 파트너를 만나보세요

컴퓨터나 스마트폰은 강력하지만, 주변 세계와 직접 소통하기는 어렵습니다. 온도를 느끼지 못하고, LED를 켜지 못하고, 버튼을 누르는 것도 감지하지 못하죠. 그래서 우리에게는 **헥사보드**가 필요합니다.

헥사보드는 단순한 전자 보드가 아닙니다. 이것은 여러분의 아이디어를 현실로 만들어줄 든든한 파트너이자, 센서로 세상을 감지하고 LED로 표현하며, Wi-Fi로 인터넷과 소통하는 작은 컴퓨터입니다.

이 챕터에서는 헥사보드의 모든 부품을 하나하나 살펴보고, 각각이 어떤 마법을 부릴 수 있는지 알아보겠습니다. 부품들의 이름과 핀 번호를 외울 필요는 없습니다. 이 챕터는 여러분의 파트너를 처음 만나는 시간입니다. 천천히, 편하게 알아가면 됩니다.

**이 챕터를 마치면**:

- 헥사보드의 모든 주요 부품과 그 역할을 이해하게 됩니다
- GPIO 핀 번호가 무엇이고 왜 중요한지 알게 됩니다
- 헥사보드를 컴퓨터에 연결하고 인식시킬 수 있습니다

**예상 소요 시간**: 편안히 읽으면서 20분

---

## ESP32: 헥사보드의 두뇌

### 작지만 강력한 마이크로컨트롤러

헥사보드의 심장부에는 **ESP32**라는 마이크로컨트롤러가 있습니다. 마이크로컨트롤러라는 이름이 어렵게 들리지만, 쉽게 말해 "아주 작은 컴퓨터"라고 생각하면 됩니다.

컴퓨터나 스마트폰처럼 복잡한 프로그램을 실행하거나 유튜브를 보는 건 불가능하지만, 대신 센서를 읽고, LED를 제어하고, 네트워크로 데이터를 주고받는 일에는 완벽합니다. 그리고 전력도 매우 적게 사용하죠.

### ESP32가 특별한 이유

ESP32는 2016년 중국의 Espressif Systems라는 회사에서 만들었습니다. 이 작은 칩이 IoT 세계에 혁명을 일으켰는데요, 그 이유는:

**1. Wi-Fi와 블루투스가 내장되어 있습니다**

아두이노 같은 전통적인 보드는 Wi-Fi를 사용하려면 별도의 모듈을 추가로 사야 했습니다. 비용도 더 들고, 연결도 복잡하죠. 하지만 ESP32는 처음부터 Wi-Fi가 들어있습니다. 그냥 코드만 작성하면 바로 인터넷에 연결할 수 있어요!

블루투스도 마찬가지입니다. 스마트폰과 직접 통신하거나, 블루투스 이어폰을 제어하는 것도 가능합니다.

**2. 강력한 성능**

- **듀얼 코어**: 두 개의 프로세서가 동시에 작동합니다. 하나는 센서를 읽고, 다른 하나는 네트워크 통신을 하는 식으로 멀티태스킹이 가능합니다.
- **240 MHz 클럭**: 아두이노의 16 MHz와 비교하면 무려 15배 빠릅니다!
- **520 KB RAM**: 복잡한 데이터 처리도 거뜬합니다.

**3. 저전력 설계**

배터리로 몇 주 동안 작동할 수 있을 만큼 전력 소비가 적습니다. 센서 노드를 멀리 떨어진 곳에 설치하는 IoT 프로젝트에 완벽하죠.

**4. 가격이 저렴합니다**

이 모든 기능을 가진 ESP32가 단돈 몇 천원입니다. 이 때문에 전 세계 메이커들이 ESP32를 사랑합니다.

**5. MicroPython 지원**

C/C++로만 프로그래밍해야 하는 다른 보드와 달리, ESP32는 **MicroPython**을 지원합니다. Python처럼 쉬운 언어로 하드웨어를 제어할 수 있다는 뜻이죠. 초보자에게는 엄청난 장점입니다.

### 헥사보드 = ESP32 + α

헥사보드는 ESP32를 기반으로, 여기에 우리가 바로 사용할 수 있는 부품들을 추가한 "올인원" 보드입니다:

- 5×5 네오픽셀 LED (화려한 출력)
- 2개의 버튼 (간단한 입력)
- 자이로 센서 (움직임 감지)
- 컬러 센서 (색상 인식)
- 외부 센서 연결 핀 (확장성)

ESP32 칩을 직접 사용하려면 브레드보드에 복잡하게 연결해야 하지만, 헥사보드는 USB만 꽂으면 바로 사용할 수 있습니다. 교육용으로 완벽하게 설계된 것이죠.

---

## 네오픽셀: 25개의 작은 캔버스

### 빛으로 그리는 그림

헥사보드의 중앙을 차지하는 5×5 그리드의 LED, 이것이 바로 **네오픽셀(NeoPixel)**입니다. 단순한 LED가 아닙니다. 각각이 독립적인 RGB LED로, 1,600만 가지 색상을 표현할 수 있습니다.

### 왜 네오픽셀이라고 부를까요?

네오픽셀은 사실 Adafruit라는 회사의 상표명입니다. 정식 이름은 **WS2812B**라는 스마트 LED 칩인데, 네오픽셀이라는 이름이 더 유명해졌죠.

일반 LED와의 결정적 차이는 이겁니다: **각 LED 안에 작은 컨트롤러가 들어있습니다**.

일반 LED를 25개 제어하려면 25개의 선이 필요하지만, 네오픽셀은 단 하나의 선으로 25개를 모두 제어할 수 있습니다. 마법 같죠? 이게 가능한 이유는 LED들이 체인처럼 연결되어 있고, 각자 자신의 순서를 알고 있기 때문입니다.

### 헥사보드의 네오픽셀 배치

```
LED 번호 (0부터 시작):

행 0:  [0]  [1]  [2]  [3]  [4]
행 1:  [5]  [6]  [7]  [8]  [9]
행 2:  [10] [11] [12] [13] [14]
행 3:  [15] [16] [17] [18] [19]
행 4:  [20] [21] [22] [23] [24]
```

0번이 첫 번째 LED이고, 24번이 마지막입니다. 데이터는 0번부터 시작해서 순서대로 전달됩니다.

### 네오픽셀로 할 수 있는 것들

**1. 센서 데이터 시각화**

온도가 올라가면 LED가 파란색에서 빨간색으로 변하는 온도계를 만들 수 있습니다. 숫자로 보는 것보다 훨씬 직관적이죠.

```python
# 온도에 따른 색상 예시
temp = 25  # 섭씨 온도

if temp < 20:
    color = (0, 0, 255)  # 파란색 (추움)
elif temp < 30:
    color = (0, 255, 0)  # 초록색 (쾌적)
else:
    color = (255, 0, 0)  # 빨간색 (더움)
```

**2. 상태 표시**

시스템의 상태를 색깔로 알려줄 수 있습니다:

- 초록색: 정상 작동
- 노란색: 주의 필요
- 빨간색: 오류 발생
- 파란색: 데이터 수신 중
- 보라색: AI가 분석 중

**3. 애니메이션과 패턴**

무지개 효과, 흐르는 물결, 깜빡이는 별, 회전하는 패턴... 상상하는 모든 것을 표현할 수 있습니다.

**4. 게임**

간단한 게임을 만들 수도 있습니다. LED가 무작위로 켜지면 빠르게 버튼을 누르는 반응속도 게임, 또는 뱀 게임, 테트리스까지!

**5. 알림**

새로운 이메일이 왔을 때, 날씨가 변할 때, 약 먹을 시간이 됐을 때... LED가 깜빡이며 알려줄 수 있습니다.

### 네오픽셀의 연결: GPIO 23번

헥사보드에서 네오픽셀은 **GPIO 23번** 핀에 연결되어 있습니다. GPIO는 "General Purpose Input/Output"의 약자로, "범용 입출력 핀"이라는 뜻입니다.

핀 번호 23은 ESP32의 디지털 핀 중 하나입니다. 우리가 코드에서 이 번호를 사용하면, ESP32는 "아, GPIO 23번으로 데이터를 보내야 하는구나" 하고 알아듣습니다.

```python
import neopixel
from machine import Pin

# GPIO 23번에 연결된 25개의 네오픽셀
np = neopixel.NeoPixel(Pin(23), 25)

# 첫 번째 LED를 빨간색으로
np[0] = (255, 0, 0)
np.write()  # 변경사항 적용
```

---

## 버튼: 가장 기본적인 입력

### 두 개면 충분합니다

헥사보드에는 **버튼 A**와 **버튼 B**, 두 개의 버튼이 있습니다. "고작 두 개?"라고 생각할 수 있지만, 이 두 개로도 놀라울 만큼 많은 것을 할 수 있습니다.

생각해보세요. 게임보이도 버튼이 몇 개 없었지만, 수백 개의 게임을 즐길 수 있었죠. 중요한 건 개수가 아니라 어떻게 사용하느냐입니다.

### 버튼의 위치와 연결

**버튼 A**

- 위치: 일반적으로 왼쪽 버튼
- GPIO: **35번**
- 역할: 주 버튼, 선택, 확인

**버튼 B**

- 위치: 일반적으로 오른쪽 버튼
- GPIO: **34번**
- 역할: 보조 버튼, 취소, 모드 변경

### Pull-down 방식 이해하기

버튼의 작동 방식을 이해하려면 "Pull-down"이라는 개념을 알아야 합니다.

전자 회로에서 버튼은 간단합니다: 누르면 연결되고, 안 누르면 끊어집니다. 하지만 문제가 있습니다. 버튼을 안 누를 때, 핀이 공중에 떠 있는 상태(floating)가 됩니다. 이 상태에서는 값이 불안정해서 0일 수도, 1일 수도, 중간일 수도 있습니다.

Pull-down 방식은 이 문제를 해결합니다:

- **버튼을 안 눌렀을 때**: 핀을 0V (GND)로 "끌어내립니다" (pull down) → 값은 0 (False)
- **버튼을 눌렀을 때**: 핀을 3.3V에 연결합니다 → 값은 1 (True)

코드에서는 이렇게 읽습니다:

```python
from machine import Pin

button_a = Pin(35, Pin.IN)  # 입력 모드

if button_a.value() == 1:
    print("버튼 A가 눌렸습니다!")
else:
    print("버튼 A가 안 눌렸습니다")
```

### 버튼 두 개로 할 수 있는 것들

**1. 기본 제어**

- A: 다음으로 이동
- B: 선택

**2. 모드 전환**

- A: 모드 1 (모니터링)
- B: 모드 2 (제어)

**3. 카운터**

- A: 숫자 증가
- B: 숫자 감소

**4. 동시 입력**

- A만: 기능 1
- B만: 기능 2
- A+B 동시: 기능 3 (특별한 조합!)

**5. 길게 누르기**

- 짧게: 일반 동작
- 길게 (2초 이상): 특수 동작 (리셋, 설정 진입 등)

**6. 더블 클릭**

- 한 번: 선택
- 빠르게 두 번: 실행

### 디바운싱: 버튼의 숨겨진 문제

버튼을 누르면 순간적으로 한 번만 신호가 가는 것 같지만, 실제로는 물리적 접점이 여러 번 붙었다 떨어지기를 반복합니다. 이것을 "바운싱(bouncing)"이라고 합니다.

```
이상적:  누름 ────┐
               └──────

실제:    누름 ─┐┌┐┌┐
            └┘└┘└───
            (여러 번 튐)
```

이 때문에 한 번 눌렀는데 여러 번 눌린 것으로 감지될 수 있습니다. 이 문제를 해결하는 것을 "디바운싱(debouncing)"이라고 하며, 나중에 코드로 처리하는 방법을 배우게 됩니다.

---

## 확장 핀: 무한한 가능성

### PIN1과 PIN2: 여러분의 센서를 위한 공간

헥사보드에는 **PIN1(GPIO 32)**과 **PIN2(GPIO 33)**라는 확장 핀이 있습니다. 여기에 외부 센서나 장치를 연결할 수 있습니다.

우리는 이 책에서:

- **PIN1 (GPIO 32)**: DHT11 온습도 센서 연결
- **PIN2 (GPIO 33)**: 조도 센서 (CdS) 연결

하지만 여기서 끝이 아닙니다. 나중에는 다른 센서들도 연결할 수 있습니다:

- 초음파 거리 센서
- 적외선 센서
- 토양 습도 센서
- 가스 센서
- 사운드 센서

### 아날로그 vs 디지털

**PIN1 (GPIO 32)**: 디지털 전용

- 0 아니면 1
- DHT11처럼 디지털 프로토콜을 사용하는 센서에 적합

**PIN2 (GPIO 33)**: 아날로그 입력 가능 (ADC)

- 0~4095 범위의 값
- 조도 센서처럼 연속적인 값을 측정하는 센서에 적합

ADC는 "Analog-to-Digital Converter"의 약자로, 아날로그 전압을 디지털 숫자로 변환해줍니다. 예를 들어:

- 0V → 0
- 1.65V → 2047
- 3.3V → 4095

### 전원 핀: 생명의 원천

센서들은 전력이 필요합니다. 헥사보드는 센서를 위한 전원 핀을 제공합니다:

**3.3V (VCC)**

- 센서에 전력을 공급
- ESP32는 3.3V 시스템 (5V 아님!)

**GND (Ground)**

- 접지, 0V
- 전류의 귀환 경로
- 모든 장치가 공통으로 연결해야 하는 기준점

전원 연결은 매우 중요합니다. 잘못 연결하면 센서나 보드가 고장날 수 있으니 항상 주의해야 합니다:

- ✅ 3.3V → VCC
- ✅ GND → GND
- ❌ 3.3V → GND (절대 안 됨! 단락)

---

## I2C: 똑똑한 통신 방식

### 두 선으로 여러 장치와 대화하기

헥사보드에는 **자이로 센서**와 **컬러 센서**가 내장되어 있습니다. 이 두 센서는 **I2C(Inter-Integrated Circuit)**라는 통신 방식을 사용합니다.

I2C의 마법은 이겁니다: **두 개의 선만으로 여러 장치와 동시에 통신할 수 있다**는 것입니다.

### I2C의 두 선

**SDA (Serial Data)** - GPIO 21

- 데이터가 오가는 선
- 양방향 통신

**SCL (Serial Clock)** - GPIO 22

- 타이밍을 맞추는 시계 신호
- 마스터(ESP32)가 제어

### 주소로 구분하기

"어떻게 같은 선에 연결된 여러 센서를 구별할까?" 궁금할 것입니다.

비밀은 **주소**입니다. 각 I2C 장치는 고유한 주소를 가지고 있습니다. 마치 집 주소처럼요.

```
헥사보드의 I2C 버스:

ESP32 (마스터)
  │
  ├── SDA (21번) ─┬─── 자이로 센서 (주소: 0x68)
  │               └─── 컬러 센서 (주소: 0x29)
  │
  └── SCL (22번) ─┴─── (같은 선에 연결)
```

ESP32가 "주소 0x68번, 데이터 주세요"라고 하면, 자이로 센서만 응답합니다. 컬러 센서는 자기 주소가 아니니까 무시하죠.

### 이 책에서의 I2C 센서

자이로 센서와 컬러 센서는 재미있는 센서이지만, 이 책의 핵심 주제가 아닙니다. AI 환경 모니터링에는 온도, 습도, 밝기가 더 중요하니까요.

그래서 이 두 센서는 부록에서만 간단히 다룹니다. 관심 있는 분들은 나중에 도전해보세요!

---

## 헥사보드 핀맵: 한눈에 보기

### 전체 구성도

```
┌──────────────────────────────────────────┐
│           헥사보드 핀맵 (ESP32)           │
├──────────────────────────────────────────┤
│                                          │
│  🔘 버튼 입력                             │
│    • 버튼 A  : GPIO 35 (왼쪽)            │
│    • 버튼 B  : GPIO 34 (오른쪽)          │
│                                          │
│  💡 네오픽셀 출력                         │
│    • LED 5×5 : GPIO 23 (25개)           │
│                                          │
│  📡 I2C 통신                              │
│    • SDA     : GPIO 21                   │
│    • SCL     : GPIO 22                   │
│    연결 장치:                             │
│      - 자이로 센서 (0x68)                │
│      - 컬러 센서   (0x29)                │
│                                          │
│  🔌 확장 핀                               │
│    • PIN1    : GPIO 32 (디지털)          │
│                → DHT11 온습도 센서       │
│    • PIN2    : GPIO 33 (ADC 가능)       │
│                → 조도 센서 (CdS)         │
│                                          │
│  ⚡ 전원                                  │
│    • 3.3V    : 센서 전원 공급            │
│    • GND     : 접지 (공통 그라운드)      │
│                                          │
│  🔌 USB                                  │
│    • 전원 + 프로그래밍 + 시리얼 통신     │
│                                          │
└──────────────────────────────────────────┘
```

### 자주 사용할 핀 번호 암기 팁

모든 핀 번호를 외울 필요는 없습니다. 자주 쓰는 것만 기억하고, 나머지는 필요할 때 찾아보면 됩니다.

**필수 암기** (자주 사용):

- 버튼 A: 35
- 버튼 B: 34
- 네오픽셀: 23
- PIN1: 32 (온습도)
- PIN2: 33 (조도)

**참고용** (가끔 사용):

- I2C SDA: 21
- I2C SCL: 22

**팁**: 코드에서는 상수로 정의해서 사용하므로 실제로 숫자를 외울 필요가 없습니다!

```python
# 이렇게 정의하면 숫자를 외울 필요 없음
BUTTON_A = 35
BUTTON_B = 34
NEOPIXEL_PIN = 23
TEMP_SENSOR_PIN = 32
LIGHT_SENSOR_PIN = 33
```

---

## 헥사보드 연결하고 인식하기

### 1단계: 물리적 연결

**필요한 것**:

- 헥사보드
- USB 케이블 (Micro USB 또는 USB-C)
- 컴퓨터 (Windows, Mac, Linux 모두 가능)

**연결 방법**:

1. USB 케이블의 한쪽을 헥사보드에 연결
2. 다른 쪽을 컴퓨터의 USB 포트에 연결
3. 헥사보드의 전원 LED가 켜지는지 확인 (보통 빨간색)

LED가 켜지면 성공입니다! 헥사보드가 전원을 받고 있다는 뜻이죠.

### 2단계: 컴퓨터에서 인식 확인

컴퓨터가 헥사보드를 "시리얼 포트"로 인식합니다. 이 포트를 통해 프로그램을 업로드하고 데이터를 주고받습니다.

**Windows에서 확인**:

1. 장치 관리자 열기 (Win + X → 장치 관리자)
2. "포트 (COM & LPT)" 항목 찾기
3. "USB-SERIAL CH340" 또는 "CP210x" 같은 이름 확인
4. 포트 번호 기억 (예: COM3, COM4)

**Mac에서 확인**:

1. 터미널 열기 (Cmd + Space → "터미널")
2. 명령 입력:
   ```bash
   ls /dev/tty.*
   ```
3. 결과에서 `/dev/tty.usbserial-XXX` 같은 것 찾기
4. 이 경로가 헥사보드의 포트입니다

**Linux에서 확인**:

1. 터미널 열기
2. 명령 입력:
   ```bash
   ls /dev/ttyUSB*
   ```
3. 보통 `/dev/ttyUSB0` 또는 `/dev/ttyUSB1`로 나타남

### 3단계: 드라이버 설치 (필요한 경우)

대부분의 경우 자동으로 드라이버가 설치되지만, Windows에서 인식이 안 된다면:

- **CH340 드라이버**: 대부분의 저가 보드가 사용
- **CP210x 드라이버**: Silicon Labs 칩 사용 시

해당 드라이버를 인터넷에서 검색해서 설치하면 됩니다.

### 문제 해결

**Q: LED는 켜지는데 포트가 안 보여요**
A: 드라이버 설치가 필요할 수 있습니다. 또는 USB 케이블이 충전 전용(데이터 불가)일 수 있으니 다른 케이블로 시도해보세요.

**Q: 포트가 여러 개 보여요**
A: 헥사보드를 연결했다 뺐다 해보면서 사라졌다 나타나는 포트를 찾으세요.

**Q: Mac에서 권한 오류가 나요**
A: 터미널에서 `sudo chmod 666 /dev/tty.usbserial-XXX` 명령 실행 (비밀번호 입력 필요)

---

## 헥사보드 둘러보기: 실제 확인하기

이제 헥사보드를 손에 들고 직접 확인해봅시다.

### 체크리스트

**외관 확인**:

- [ ] 5×5 네오픽셀 LED가 보이나요? (보통 가운데에 격자 형태)
- [ ] 버튼 2개가 있나요? (누르면 딸깍 소리)
- [ ] PIN1, PIN2 라벨이나 핀이 있나요?
- [ ] USB 포트가 있나요?

**연결 확인**:

- [ ] USB 케이블을 연결했나요?
- [ ] 전원 LED가 켜졌나요?
- [ ] 컴퓨터가 포트를 인식했나요?

**버튼 테스트**:

- [ ] 버튼 A를 눌러보세요. 클릭감이 느껴지나요?
- [ ] 버튼 B를 눌러보세요. 클릭감이 느껴지나요?

모두 체크되었나요? 축하합니다! 헥사보드가 정상입니다.

### 첫 만남의 설렘

지금 여러분 손에 들린 이 작은 보드가 앞으로 놀라운 일들을 해낼 것입니다:

- 방의 온도와 습도를 측정하고
- 화려한 LED로 데이터를 표현하고
- Wi-Fi로 클라우드에 데이터를 전송하고
- 인공지능의 명령을 받아 스스로 제어하고
- 웹 브라우저에서 실시간으로 상태를 보여주고...

이 모든 것이 여러분이 작성할 코드로 가능해집니다.

---

## 헥사보드와 다른 보드 비교

궁금할 것입니다. "왜 하필 헥사보드일까? 아두이노나 라즈베리파이는 어때?"

### 아두이노 vs 헥사보드

**아두이노**:

- ✅ 엄청난 커뮤니티와 자료
- ✅ 매우 안정적
- ❌ Wi-Fi 없음 (별도 모듈 필요)
- ❌ 성능이 약함 (16 MHz, 2KB RAM)
- ❌ Python 미지원

**헥사보드 (ESP32)**:

- ✅ Wi-Fi/블루투스 내장
- ✅ 강력한 성능 (240 MHz, 520KB RAM)
- ✅ MicroPython 지원
- ✅ LED, 센서 등 기본 장착
- ⚠️ 아두이노보다 자료가 적음 (하지만 빠르게 증가 중)

### 라즈베리파이 vs 헥사보드

**라즈베리파이**:

- ✅ 완전한 컴퓨터 (Linux 실행)
- ✅ 복잡한 프로그램 가능
- ❌ 비쌈 (7만원 이상)
- ❌ 전력 소비 많음
- ❌ 실시간 제어에는 부적합
- ❌ GPIO 전압이 3.3V로 제한적

**헥사보드**:

- ✅ 저렴함 (3~5만원)
- ✅ 저전력
- ✅ 실시간 제어 완벽
- ✅ 교육용으로 최적화
- ❌ 복잡한 프로그램 불가 (브라우저, 동영상 등)

### 결론: 적재적소

- **웹 서버, AI 처리, 복잡한 계산**: 라즈베리파이
- **센서 제어, 실시간 반응, IoT**: 헥사보드/ESP32
- **전통적인 로봇, 안정성 중시**: 아두이노

우리의 AIoT 프로젝트에는 헥사보드가 완벽한 선택입니다!

---

## 핵심 요약

### 헥사보드의 정체

- **ESP32 기반**: 듀얼 코어 240MHz, Wi-Fi/블루투스 내장
- **올인원 설계**: LED, 버튼, 센서가 기본 장착
- **MicroPython 지원**: 쉬운 프로그래밍
- **교육용 최적화**: 바로 사용 가능

### 주요 부품과 핀 번호

| 부품     | GPIO | 용도               |
| -------- | ---- | ------------------ |
| 버튼 A   | 35   | 입력 (메인)        |
| 버튼 B   | 34   | 입력 (서브)        |
| 네오픽셀 | 23   | 출력 (5×5 LED)     |
| PIN1     | 32   | 확장 (온습도 센서) |
| PIN2     | 33   | 확장 (조도 센서)   |
| I2C SDA  | 21   | 통신 (자이로/컬러) |
| I2C SCL  | 22   | 통신 (자이로/컬러) |

### 기억해야 할 개념

1. **GPIO**: 범용 입출력 핀, 번호로 구분
2. **네오픽셀**: 25개의 스마트 RGB LED, 한 선으로 제어
3. **Pull-down**: 버튼 방식, 안 누름=0, 누름=1
4. **I2C**: 두 선으로 여러 장치 통신
5. **ADC**: 아날로그를 디지털로 변환 (0~4095)

---

## 다음 단계

헥사보드의 구조를 완전히 이해했습니다! 이제 각 부품이 무엇인지, 어디에 연결되어 있는지, 무엇을 할 수 있는지 알게 되었죠.

다음 챕터에서는 이 멋진 보드를 실제로 프로그래밍할 환경을 구축합니다. Thonny IDE를 설치하고, MicroPython 펌웨어를 업로드하고, 첫 번째 코드 "Hello World"를 작성해볼 것입니다.

**드디어 LED가 켜집니다!** 🎉

---

**💡 작은 팁**

헥사보드의 핀맵을 스마트폰으로 사진 찍어두거나, 종이에 인쇄해서 책상에 붙여두세요. 코딩할 때 "PIN1이 몇 번이었지?" 하고 매번 찾아보는 것보다 훨씬 편합니다!

---

**다음 챕터 예고**  
Chapter 3 - 개발 환경 준비하기

Thonny IDE 설치부터 첫 LED 켜기까지, 드디어 실습이 시작됩니다!
