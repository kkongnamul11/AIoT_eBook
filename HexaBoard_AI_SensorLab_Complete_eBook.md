# 📘 헥사보드 AI 센서랩

## OpenAI와 함께하는 스마트 환경 실험실

---

> 헥사보드 버튼 · 네오픽셀 · 온습도 · 조도 센서 기반  
> MQTT + Python + Web으로 구현하는 AI 제어 IoT 시스템

**저자**: MakeItNow Team  
**버전**: v1.0  
**발행일**: 2025년 1월  
**전체 분량**: 29개 챕터 / 약 20시간 학습

---

## 📚 이 책에 대하여

**헥사보드 AI 센서랩**은 ESP32 기반 헥사보드를 활용하여 AIoT(AI + IoT) 시스템을 구축하는 방법을 단계별로 학습하는 실습 중심 전자책입니다.

### 이 책의 특징

- 🎯 **실무 중심**: 실제 동작하는 AIoT 시스템 구축
- 🤖 **AI 통합**: OpenAI GPT를 활용한 자연어 제어
- 📊 **전체 파이프라인**: 센서 → MQTT → AI → 제어의 완전한 데이터 흐름
- 🌐 **웹 확장**: 브라우저 기반 모니터링 및 제어 대시보드
- 📚 **교육 친화적**: 20시간 완성, 초보자부터 고급까지

### 대상 독자

- IoT 시스템에 관심 있는 초급~중급 개발자
- 교육용 AIoT 프로젝트를 찾는 교육자
- 스마트홈, 환경 모니터링에 관심 있는 메이커
- Python과 AI를 실제 하드웨어와 연동하고 싶은 분

### 필요한 준비물

**하드웨어**:

- 헥사보드 (ESP32 기반) × 1
- DHT11 온습도 센서 모듈 × 1
- 조도 센서 모듈 × 1
- 3핀 케이블 × 2
- USB 케이블 × 1

**소프트웨어**:

- MicroPython 1.24
- Python 3.10+
- Thonny IDE
- 웹 브라우저

**클라우드/API**:

- HiveMQ Cloud (무료)
- OpenAI API (선택)

---

## 📑 목차

### PART 1. AI 센서랩과 헥사보드 이해하기

- **Chapter 1.** AI 센서랩이란 무엇인가
- **Chapter 2.** 헥사보드 구조 한눈에 보기
- **Chapter 3.** 개발 환경 준비하기

### PART 2. 헥사보드 기본 제어 – 버튼과 네오픽셀

- **Chapter 4.** 디지털 입력의 기본 – 버튼 2개 다루기
- **Chapter 5.** 네오픽셀 기초 – 한 칸에서 5x5까지
- **Chapter 6.** 버튼 + 네오픽셀로 만드는 상태 머신

### PART 3. 온습도 센서 & 조도 센서 연결하기

- **Chapter 7.** 온습도 센서 이해와 연결
- **Chapter 8.** 조도 센서 이해와 연결
- **Chapter 9.** 센서 데이터 정리 및 단위 변환
- **Chapter 10.** 센서 데이터를 시각적으로 표현하기

### PART 4. MQTT를 통한 센서 데이터 전송

- **Chapter 11.** MQTT 개념과 데이터 흐름 이해
- **Chapter 12.** MQTT 브로커 준비 (HiveMQ)
- **Chapter 13.** 헥사보드에서 MQTT Publish / Subscribe 구현
- **Chapter 14.** 멀티 헥사보드 확장 실험

### PART 5. Python + OpenAI로 AI 명령 엔진 만들기

- **Chapter 15.** Python에서 MQTT 데이터 수신
- **Chapter 16.** 센서 데이터 요약과 상태 해석
- **Chapter 17.** OpenAI API 연동 및 프롬프트 설계
- **Chapter 18.** AI 응답을 제어 명령으로 변환하기
- **Chapter 19.** 헥사보드로 제어 명령 되돌려 보내기

### PART 6. 종합 프로젝트 – AI 환경 무드 컨트롤러

- **Chapter 20.** 프로젝트 개요
- **Chapter 21.** 시스템 아키텍처 설계
- **Chapter 22.** 단계별 구현 실습
- **Chapter 23.** AI 실험과 튜닝

### PART 7. 웹 기반 AI 제어 대시보드

- **Chapter 24.** 웹에서 센서 상태 모니터링하기
- **Chapter 25.** 웹에서 헥사보드 수동 제어
- **Chapter 26.** 웹에서 자연어 기반 AI 제어

### PART 8. 수업 설계와 확장 아이디어

- **Chapter 27.** 교육 커리큘럼 설계 가이드
- **Chapter 28.** 미션 기반 실습 및 평가 설계
- **Chapter 29.** 확장 아이디어 및 후속 프로젝트 방향

---

## 📖 학습 가이드

### 추천 학습 순서

1. **PART 1-2 (4시간)**: 하드웨어 이해 및 기본 제어
2. **PART 3 (3시간)**: 외부 센서 연결 및 데이터 수집
3. **PART 4 (3.5시간)**: MQTT 통신 구조 이해
4. **PART 5 (4시간)**: Python 서버 및 OpenAI 연동
5. **PART 6 (3.5시간)**: 종합 프로젝트 실습
6. **PART 7 (1.5시간)**: 웹 인터페이스 구축
7. **PART 8 (0.5시간)**: 교육 활용 및 확장

**총 예상 시간**: 20시간

### 난이도

- ⭐ = 초급
- ⭐⭐ = 중급
- ⭐⭐⭐ = 고급

---

## 🚀 빠른 시작

### 1. 하드웨어 준비

- 헥사보드 연결 (USB 케이블)
- MicroPython 펌웨어 설치
- Thonny IDE 설치

### 2. 첫 번째 프로그램

```python
# LED 깜빡이기
from machine import Pin
import neopixel
import time

np = neopixel.NeoPixel(Pin(23), 25)
np[0] = (255, 0, 0)  # 빨간색
np.write()
```

### 3. 챕터별 학습

- 각 챕터를 순서대로 따라하기
- 예제 코드 직접 실행해보기
- 도전 과제로 실력 향상

---

## 💡 학습 팁

### 성공적인 학습을 위해

1. **실습 중심으로**: 코드를 직접 작성하고 실행하세요
2. **오류를 두려워하지 마세요**: 디버깅 과정에서 더 많이 배웁니다
3. **작은 성공 경험 쌓기**: LED 하나 켜는 것부터 시작하세요
4. **커뮤니티 활용**: 막힐 때 질문하고 공유하세요
5. **프로젝트로 완성**: 배운 것을 응용한 나만의 프로젝트 만들기

---

## ⚠️ 주의사항

### 안전하게 사용하기

- USB 케이블을 갑자기 뽑지 마세요 (데이터 손실 가능)
- 센서와 보드를 정전기로부터 보호하세요
- 전원 극성(+/-)을 확인하세요
- 높은 전압을 직접 연결하지 마세요

### API 키 보안

- OpenAI API 키는 절대 공개 저장소에 올리지 마세요
- `.env` 파일을 사용하고 `.gitignore`에 추가하세요
- 정기적으로 키를 변경하세요

---

## 📞 지원 및 문의

### 문제가 발생하면

1. **공식 문서 확인**: MicroPython, OpenAI, MQTT 공식 문서
2. **예제 코드 다시 확인**: GitHub 저장소의 예제 코드
3. **커뮤니티 질문**: GitHub Issues, 포럼
4. **이메일 문의**: support@example.com

---

## 📄 라이선스

- **예제 코드**: MIT License (자유롭게 사용 가능)
- **전자책 콘텐츠**: CC BY-NC-SA 4.0 (교육 목적 자유 사용, 상업적 출판 제한)

---

## 🎓 이제 시작합니다!

> "작은 LED 하나를 켜는 것부터 시작하여  
> 완전한 AIoT 시스템을 만들어보세요.  
> 계속 도전하고, 실패하고, 배우세요.  
> 가장 중요한 것은 멈추지 않는 것입니다!"

**즐거운 학습 되세요! 🚀**

---

<div style="page-break-after: always;"></div>

# Chapter 1. AI 센서랩이란 무엇인가

> **PART 1**: AI 센서랩과 헥사보드 이해하기

---

## 📚 이 챕터에서 배울 내용

- [ ] AI 센서랩이 무엇인지 이해할 수 있다
- [ ] IoT와 AIoT의 차이를 알 수 있다
- [ ] 이 책에서 만들 프로젝트를 이해할 수 있다

**예상 소요 시간**: 20분

---

## 🎯 학습 목표

### 핵심 개념

- **IoT**: 사물인터넷, 센서와 네트워크로 연결된 장치들
- **AI**: 인공지능, 데이터를 학습하고 판단하는 기술
- **AIoT**: AI + IoT, 똑똑한 사물인터넷

---

## 📖 AI 센서랩이란?

### IoT에서 AIoT로

**IoT (사물인터넷)**는 센서와 네트워크로 주변 환경을 감지하고 제어합니다.

```
센서 → 데이터 수집 → 서버 전송 → 규칙 기반 제어
```

예시: "온도가 30도 이상이면 에어컨 켜기"

**문제점**:

- 모든 상황을 미리 규칙으로 만들어야 함
- 복잡한 상황 대응이 어려움
- 사용자의 자연스러운 명령 불가

**AIoT (AI + IoT)**는 여기에 인공지능을 더합니다!

```
센서 → 데이터 수집 → AI 분석 → 똑똑한 제어
```

예시: "너무 덥네요" → AI가 상황 파악 → 적절한 온도로 조절

**장점**:

- ✅ 자연어로 명령 가능
- ✅ 상황에 맞게 알아서 판단
- ✅ 사용자 패턴 학습 가능

### AI 센서랩이란?

**AI 센서랩**은 헥사보드와 센서를 사용해서 AIoT 시스템을 직접 만들어보는 실험실입니다.

우리가 만들 시스템:

```
헥사보드 (센서 + LED)
    ↓
MQTT (데이터 전송)
    ↓
Python AI 서버 (OpenAI)
    ↓
웹 대시보드 (모니터링 + 제어)
```

---

## 🚀 무엇을 만들게 되나요?

### 최종 프로젝트: AI 환경 무드 컨트롤러

**기능**:

1. **센서로 환경 감지**
   - 온도, 습도, 밝기를 실시간 측정
2. **AI가 상황 판단**
   - "지금 온도가 높고 습도가 낮네요"
   - OpenAI가 데이터를 분석
3. **자동 또는 음성 제어**
   - "시원하게 해줘" → AI가 이해하고 LED 제어
   - 버튼으로도 제어 가능
4. **웹에서 모니터링**
   - 실시간 센서 값 확인
   - 그래프로 변화 추이 확인

### 단계별 학습 과정

**PART 1-2**: 헥사보드 기본 (버튼, LED)

```
버튼 누르기 → LED 켜기
```

**PART 3**: 센서 연결

```
온도 센서 → 데이터 읽기 → 화면 출력
```

**PART 4**: MQTT 통신

```
헥사보드 → MQTT → 서버
```

**PART 5**: AI 통합

```
센서 데이터 → OpenAI → 제어 명령
```

**PART 6-7**: 종합 프로젝트 + 웹

```
전체 시스템 완성!
```

---

## 🎓 이 책의 특징

### 1. 초보자 친화적

- 어려운 용어는 쉽게 설명
- 모든 코드는 복사해서 바로 실행 가능
- 단계별로 천천히 진행

### 2. 실습 중심

- 이론은 최소한으로
- 직접 해보면서 배우기
- 바로 결과 확인

### 3. 완성된 프로젝트

- 책 한 권으로 실제 동작하는 AIoT 시스템 완성
- 포트폴리오로 활용 가능
- 취업이나 프로젝트에 응용 가능

---

## 📋 준비물

### 필수 하드웨어

- **헥사보드** × 1
  - ESP32 기반
  - 5×5 네오픽셀 LED
  - 버튼 2개 내장
- **온습도 센서** (DHT11 또는 DHT22) × 1
- **조도 센서** (포토레지스터) × 1
- **USB 케이블** × 1
- **점퍼 케이블** 약간

### 필수 소프트웨어

- **Thonny IDE** (MicroPython 개발)
- **Python 3.10+** (AI 서버)
- **OpenAI API 키** (무료 체험 가능)
- **웹 브라우저** (Chrome 권장)

### 선택 사항

- MQTT 브로커 계정 (HiveMQ 무료 사용)

> 💡 **팁**: 모든 소프트웨어는 무료이거나 무료 체험이 가능합니다!

---

## 🗺️ 학습 로드맵

```
PART 1: 이해하기 (1.5시간)
  └─ 헥사보드와 개념 이해

PART 2: 기본 제어 (2.5시간)
  └─ 버튼과 LED 제어

PART 3: 센서 연결 (3시간)
  └─ 온습도, 조도 센서

PART 4: 통신 (3.5시간)
  └─ MQTT로 데이터 주고받기

PART 5: AI 통합 (4시간)
  └─ OpenAI로 똑똑하게

PART 6-7: 프로젝트 (5시간)
  └─ 전체 시스템 + 웹

PART 8: 확장 (0.5시간)
  └─ 더 나아가기

총 20시간 = 완성된 AIoT 시스템!
```

---

## 🎓 핵심 요약

### 오늘 배운 것

1. **IoT**: 센서와 네트워크로 연결된 장치
2. **AIoT**: IoT에 인공지능을 더해 똑똑하게
3. **AI 센서랩**: 헥사보드로 AIoT를 직접 만들어보는 과정

### 우리가 만들 것

```
센서 → MQTT → AI → 웹 대시보드
```

자연어로 명령하고, AI가 판단하고, 자동으로 제어하는 똑똑한 환경 컨트롤러!

---

## 🤔 자주 묻는 질문

**Q1: 프로그래밍을 처음인데 따라갈 수 있나요?**  
A: 네! 모든 코드를 복사해서 실행할 수 있습니다. 단계별로 천천히 설명합니다.

**Q2: 헥사보드가 꼭 필요한가요?**  
A: 네, 이 책은 헥사보드 전용입니다. 하지만 다른 ESP32 보드로 응용 가능합니다.

**Q3: OpenAI API 비용이 많이 드나요?**  
A: 실습 수준에서는 거의 무료입니다. 무료 크레딧으로 충분히 가능합니다.

**Q4: 완성된 프로젝트를 실제로 사용할 수 있나요?**  
A: 네! 방이나 사무실에서 실제로 사용 가능합니다. 확장도 가능합니다.

**Q5: 책을 끝까지 완료하면 무엇을 할 수 있나요?**  
A:

- AIoT 시스템을 처음부터 설계하고 구현
- 센서 데이터를 AI로 분석하고 제어
- 웹 기반 IoT 대시보드 제작
- 포트폴리오용 프로젝트 완성

---

## 🚀 준비되셨나요?

이제 AIoT의 세계로 들어갈 준비가 되었습니다!

다음 챕터에서는 우리의 파트너 **헥사보드**를 자세히 알아보겠습니다.

**다음 챕터**: Chapter 2 - 헥사보드 구조 한눈에 보기

---

## 📝 학습 체크

- [ ] AI 센서랩이 무엇인지 이해했나요?
- [ ] IoT와 AIoT의 차이를 알겠나요?
- [ ] 준비물을 확인했나요?
- [ ] 20시간 학습 계획을 세웠나요?

**완료 시간**: \_\_\_시 \_\_\_분

---

> **💡 TIP**: 이 책은 순서대로 진행하는 것이 좋습니다. 각 챕터가 이전 챕터를 기반으로 합니다!

---

**챕터 작성**: 2025-11-25  
**작성자**: AIoT eBook Team

# Chapter 2. 헥사보드 구조 한눈에 보기

> **PART 1**: AI 센서랩과 헥사보드 이해하기

---

## 📚 이 챕터에서 배울 내용

- [ ] 헥사보드의 주요 부품을 알 수 있다
- [ ] 각 부품의 역할을 이해할 수 있다
- [ ] GPIO 핀 번호를 확인할 수 있다

**예상 소요 시간**: 20분

---

## 🎯 학습 목표

### 핵심 개념

- **헥사보드**: ESP32 기반의 IoT 학습용 보드
- **GPIO**: 입출력을 위한 핀 (센서, LED 연결)
- **네오픽셀**: 개별 제어 가능한 RGB LED

---

## 📖 헥사보드란?

### ESP32 기반 학습 보드

헥사보드는 **ESP32** 마이크로컨트롤러를 기반으로 만든 IoT 학습 보드입니다.

**ESP32의 특징**:

- Wi-Fi 내장 (무선 통신 가능)
- 블루투스 지원
- 저전력 설계
- 많은 GPIO 핀 (센서 연결 가능)
- MicroPython 지원

> 💡 **팁**: ESP32는 아두이노보다 강력하고, 라즈베리파이보다 간단합니다!

---

## 🔧 헥사보드 주요 부품

### 1. 네오픽셀 LED (5×5)

**위치**: 보드 중앙  
**개수**: 25개 (5행 × 5열)  
**GPIO**: 23번

**할 수 있는 것**:

- 각 LED의 색상 개별 제어
- 1,600만 가지 색상 표현
- 밝기 조절
- 애니메이션 효과

**용도**:

- 센서 데이터 시각화 (온도 높으면 빨간색)
- 상태 표시 (연결 중, 오류 등)
- 게임이나 패턴 표현

### 2. 버튼 2개

**버튼 A**:

- GPIO: 35번
- Pull-down 방식 (누름 = 1)

**버튼 B**:

- GPIO: 34번
- Pull-down 방식 (누름 = 1)

**할 수 있는 것**:

- 모드 전환
- 카운터
- 게임 컨트롤
- 수동 제어

### 3. 자이로 센서 (I2C)

**연결**: I2C (SDA=21, SCL=22)  
**기능**: 기울기, 회전, 흔들림 감지

> 📌 **참고**: 이 책에서는 부록에서만 다룹니다

### 4. 컬러 센서 (I2C)

**연결**: I2C (SDA=21, SCL=22)  
**기능**: 색상 인식 (RGB 값)

> 📌 **참고**: 이 책에서는 부록에서만 다룹니다

### 5. 외부 연결 핀

**PIN1** (GPIO 32):

- 온습도 센서 연결 예정

**PIN2** (GPIO 33):

- 조도 센서 연결 예정

**전원 핀**:

- 3.3V: 센서 전원 공급
- GND: 접지 (공통 그라운드)

---

## 📌 헥사보드 핀맵

### 주요 GPIO 핀 정리

```
┌─────────────────────────────┐
│      헥사보드 핀맵          │
├─────────────────────────────┤
│ 버튼 A        : GPIO 35     │
│ 버튼 B        : GPIO 34     │
│ 네오픽셀      : GPIO 23     │
├─────────────────────────────┤
│ I2C SDA       : GPIO 21     │
│ I2C SCL       : GPIO 22     │
│ (자이로/컬러센서 공용)      │
├─────────────────────────────┤
│ PIN1 (확장)   : GPIO 32     │
│ PIN2 (확장)   : GPIO 33     │
├─────────────────────────────┤
│ 전원                         │
│ - 3.3V: 센서 전원           │
│ - GND: 접지                 │
└─────────────────────────────┘
```

### 중요 사항

**버튼은 Pull-down 방식**:

- 안 누름: 0 (LOW)
- 누름: 1 (HIGH)

**네오픽셀은 체인 연결**:

- 25개가 순서대로 연결
- 번호: 0번부터 24번까지

**I2C는 공유**:

- 여러 센서가 같은 선 사용
- 주소로 구분

---

## 💻 헥사보드 연결하기

### USB 연결

1. **USB 케이블 준비**
   - Micro USB 또는 USB-C (보드에 따라 다름)
2. **컴퓨터에 연결**
   - 헥사보드의 USB 포트에 연결
   - PC/Mac USB 포트에 연결
3. **전원 LED 확인**
   - 빨간색 LED가 켜지면 정상

### 포트 확인

**Windows**:

```
장치 관리자 → 포트 (COM & LPT)
예: COM3, COM4
```

**Mac**:

```
터미널에서:
ls /dev/tty.*
예: /dev/tty.usbserial-0001
```

**Linux**:

```
터미널에서:
ls /dev/ttyUSB*
예: /dev/ttyUSB0
```

---

## 🎓 핵심 요약

### 헥사보드의 구성

1. **ESP32**: Wi-Fi 내장 마이크로컨트롤러
2. **네오픽셀**: 5×5 RGB LED (GPIO 23)
3. **버튼**: A(GPIO 35), B(GPIO 34)
4. **확장 핀**: PIN1(GPIO 32), PIN2(GPIO 33)
5. **I2C 센서**: 자이로, 컬러 (부록)

### 기억할 핀 번호

```python
# 자주 사용할 핀
BUTTON_A = 35
BUTTON_B = 34
NEOPIXEL = 23
PIN1 = 32  # 온습도 센서
PIN2 = 33  # 조도 센서
```

---

## 🔍 실습: 헥사보드 확인하기

### 준비물

- [x] 헥사보드
- [x] USB 케이블
- [x] 컴퓨터

### 확인 항목

1. **외관 확인**

   - [ ] 네오픽셀 25개가 보이나요?
   - [ ] 버튼 2개가 보이나요?
   - [ ] PIN1, PIN2 라벨이 있나요?

2. **연결 확인**

   - [ ] USB 케이블 연결
   - [ ] 전원 LED가 켜지나요?
   - [ ] 포트가 인식되나요?

3. **버튼 테스트**
   - [ ] 버튼 A를 누르면 클릭감이 있나요?
   - [ ] 버튼 B를 누르면 클릭감이 있나요?

---

## 🤔 자주 묻는 질문

**Q1: 헥사보드와 아두이노의 차이는?**  
A: 헥사보드는 ESP32 기반으로 Wi-Fi가 내장되어 있고, 네오픽셀과 센서가 이미 장착되어 있어 편리합니다.

**Q2: 네오픽셀이 왜 5×5인가요?**  
A: 시각적으로 데이터를 표현하기 좋은 크기입니다. 게임이나 애니메이션도 가능합니다.

**Q3: 버튼이 2개만 있는데 부족하지 않나요?**  
A: 2개로도 많은 것을 할 수 있습니다! 동시 입력, 길게 누르기 등 조합이 가능합니다.

**Q4: I2C가 뭔가요?**  
A: 센서와 통신하는 방식입니다. 2개의 선(SDA, SCL)으로 여러 센서를 연결할 수 있습니다.

**Q5: GPIO 번호는 외워야 하나요?**  
A: 자주 쓰는 것만 기억하면 됩니다. 코드에 상수로 정의해서 사용합니다.

---

## 🎨 헥사보드로 할 수 있는 것

### 기본 프로젝트

- LED 패턴 만들기
- 버튼 게임
- 센서 데이터 표시

### 중급 프로젝트

- Wi-Fi로 데이터 전송
- 웹에서 제어
- MQTT 통신

### 고급 프로젝트

- AI 기반 제어
- 여러 헥사보드 연동
- 클라우드 연동

> 💡 **팁**: 이 책을 다 보면 고급 프로젝트까지 가능합니다!

---

## 📝 학습 체크

- [ ] 헥사보드의 주요 부품을 말할 수 있나요?
- [ ] GPIO 핀 번호를 확인했나요?
- [ ] USB로 연결하고 포트를 확인했나요?

**완료 시간**: \_\_\_시 \_\_\_분

---

**다음 챕터**: Chapter 3 - 개발 환경 준비하기

이제 헥사보드를 프로그래밍할 준비를 하겠습니다!

---

> **💡 TIP**: 헥사보드 핀맵을 캡처하거나 메모해두면 나중에 유용합니다!

---

**챕터 작성**: 2025-11-25  
**작성자**: AIoT eBook Team

# Chapter 3. 개발 환경 준비하기

> **PART 1**: AI 센서랩과 헥사보드 이해하기

---

## 📚 이 챕터에서 배울 내용

- [ ] Thonny IDE를 설치하고 설정할 수 있다
- [ ] 헥사보드에 MicroPython을 확인할 수 있다
- [ ] 첫 번째 코드를 실행할 수 있다

**예상 소요 시간**: 30분

---

## 🎯 학습 목표

### 핵심 개념

- **Thonny**: MicroPython 개발을 위한 간단한 IDE
- **MicroPython**: 마이크로컨트롤러용 Python
- **REPL**: 코드를 한 줄씩 실행하는 대화형 환경

---

## 📖 필요한 소프트웨어

### 1. Thonny IDE

**Thonny란?**

- 초보자를 위한 Python IDE
- MicroPython 지원
- 헥사보드와 쉽게 연결
- 무료!

**특징**:

- 설치 간단
- 사용하기 쉬움
- 디버깅 편리
- 파일 관리 쉬움

---

## 💻 Thonny 설치하기

### Windows

1. **다운로드**

   - https://thonny.org 접속
   - "Windows" 버튼 클릭
   - `thonny-X.X.X.exe` 다운로드

2. **설치**

   - 다운로드한 파일 실행
   - "Install for me only" 선택 권장
   - "Next" 계속 클릭
   - "Install" 클릭
   - 완료!

3. **실행**
   - 바탕화면 또는 시작 메뉴에서 Thonny 실행

### Mac

1. **다운로드**

   - https://thonny.org 접속
   - "Mac" 버튼 클릭
   - `thonny-X.X.X.pkg` 다운로드

2. **설치**

   - 다운로드한 파일 실행
   - 설치 지시 따르기
   - 보안 경고가 나오면:
     - 시스템 환경설정 → 보안 및 개인정보 보호
     - "확인 없이 열기" 클릭

3. **실행**
   - Applications 폴더에서 Thonny 실행

### Linux (Ubuntu/Debian)

터미널에서 실행:

```bash
sudo apt update
sudo apt install thonny
```

실행:

```bash
thonny
```

---

## 🔧 Thonny 설정하기

### 1. 헥사보드 연결

1. **USB 연결**

   - 헥사보드를 USB로 컴퓨터에 연결
   - 전원 LED 확인

2. **포트 선택**

   - Thonny 실행
   - 우측 하단 "Python X.X.X" 클릭
   - "MicroPython (ESP32)" 선택
   - 또는 "Configure interpreter..." 선택

3. **인터프리터 설정**

   ```
   Tools → Options → Interpreter

   Which kind of interpreter:
   → MicroPython (ESP32)

   Port or WebREPL:
   → <자동으로 찾음>
   또는 수동 선택 (COM3, /dev/ttyUSB0 등)
   ```

4. **OK** 클릭

### 2. 연결 확인

Thonny 하단의 **Shell** 창에서:

```
>>>
MicroPython v1.24.0 on 2024-XX-XX; ESP32 module with ESP32
Type "help()" for more information.
>>>
```

이렇게 보이면 성공! 🎉

---

## ✅ 첫 번째 코드 실행

### Hello World!

1. **코드 입력**
   - 상단 빈 공간에 입력:

```python
print("Hello, HexaBoard!")
```

2. **실행**

   - ▶️ (초록색 실행 버튼) 클릭
   - 또는 F5 키

3. **결과 확인**
   - 하단 Shell에 출력:

```
Hello, HexaBoard!
```

**축하합니다! 첫 번째 프로그램이 실행되었습니다!** 🎉

---

## 💡 LED 깜빡이기 (선택)

### 내장 LED 테스트

헥사보드에 연결이 잘 되었는지 확인해봅시다!

**코드**:

```python
from machine import Pin
import time

# 내장 LED (보통 GPIO 2번)
led = Pin(2, Pin.OUT)

# 5번 깜빡이기
for i in range(5):
    led.on()   # LED 켜기
    print("LED ON")
    time.sleep(0.5)

    led.off()  # LED 끄기
    print("LED OFF")
    time.sleep(0.5)

print("완료!")
```

**실행하기**:

1. 코드를 입력하세요
2. ▶️ 실행 버튼 클릭
3. LED가 5번 깜빡이는지 확인

> 💡 **팁**: LED가 안 보이면 정상입니다. 일부 헥사보드는 내장 LED가 보이지 않을 수 있습니다.

---

## 🎓 Thonny 화면 구성

```
┌─────────────────────────────────────┐
│  파일 편집기 (코드 작성)            │
│                                     │
│  print("Hello!")                    │
│                                     │
├─────────────────────────────────────┤
│  Shell (결과 출력, REPL)            │
│                                     │
│  >>> print("Hello!")                │
│  Hello!                             │
│  >>>                                │
└─────────────────────────────────────┘
```

**주요 영역**:

1. **편집기** (상단)
   - 코드 작성
   - 파일 저장/열기
2. **Shell** (하단)
   - 실행 결과 출력
   - REPL로 즉석 테스트
3. **도구 모음**
   - ▶️ 실행
   - 🛑 정지
   - 💾 저장

---

## 🎓 핵심 요약

### 설치한 것

1. **Thonny IDE** - MicroPython 개발 도구
2. **헥사보드 연결** - USB 연결 및 포트 설정

### 확인한 것

- MicroPython 연결 ✅
- 첫 프로그램 실행 ✅
- LED 테스트 (선택) ✅

### 다음 챕터 준비

이제 버튼과 LED를 제어할 준비가 완료되었습니다!

---

## 🐛 문제 해결

### 문제 1: 포트가 안 보여요

**해결 방법**:

1. **드라이버 설치 (Windows)**

   - CP210x USB to UART Driver 검색
   - Silicon Labs 사이트에서 다운로드
   - 설치 후 재시작

2. **연결 확인**

   - USB 케이블 다시 연결
   - 다른 USB 포트 시도
   - Thonny 재시작

3. **권한 문제 (Linux)**
   ```bash
   sudo usermod -a -G dialout $USER
   # 로그아웃 후 다시 로그인
   ```

### 문제 2: "Device is busy" 에러

**해결 방법**:

- 다른 프로그램이 포트를 사용 중
- 시리얼 모니터 종료
- Thonny 재시작
- 헥사보드 재연결

### 문제 3: 코드가 실행되지 않아요

**확인 사항**:

- [ ] 헥사보드가 연결되어 있나요?
- [ ] Shell에 ">>>" 프롬프트가 보이나요?
- [ ] 인터프리터가 "MicroPython (ESP32)"인가요?
- [ ] 코드에 오타가 없나요?

---

## 📝 실습: REPL 사용해보기

**REPL**이란? Read-Eval-Print Loop의 약자로, 코드를 한 줄씩 실행해볼 수 있습니다.

### Shell에서 직접 입력

```python
>>> print("Hello!")
Hello!

>>> 1 + 1
2

>>> import machine
>>> machine.freq()
240000000

>>> # 계산기처럼 사용!
>>> 10 * 5
50
```

> 💡 **팁**: REPL은 빠르게 테스트할 때 유용합니다!

---

## 🚀 다음 단계

환경 설정이 완료되었습니다! 이제 실제로 헥사보드를 제어해봅시다.

**다음 챕터**: Chapter 4 - 디지털 입력의 기본 – 버튼 2개 다루기

---

## 📝 학습 체크

- [ ] Thonny IDE를 설치했나요?
- [ ] 헥사보드와 연결했나요?
- [ ] 첫 번째 코드를 실행했나요?
- [ ] REPL을 사용해봤나요?

**완료 시간**: \_\_\_시 \_\_\_분

---

> **💡 TIP**: Thonny의 View 메뉴에서 "Files"를 활성화하면 헥사보드의 파일을 쉽게 관리할 수 있습니다!

---

## 🎉 PART 1 완료!

축하합니다! PART 1을 모두 마쳤습니다.

이제 알게 된 것:

- ✅ AI 센서랩이 무엇인지
- ✅ 헥사보드의 구조
- ✅ 개발 환경 설정

**PART 2**에서는 본격적으로 헥사보드를 제어합니다!

---

**챕터 작성**: 2025-11-25  
**작성자**: AIoT eBook Team

# Chapter 4. 디지털 입력의 기본 – 버튼 2개 다루기

> **PART 2**: 헥사보드 기본 제어 – 버튼과 네오픽셀

---

## 📚 이 챕터에서 배울 내용

- [ ] 버튼으로 디지털 입력을 읽을 수 있다
- [ ] 헥사보드의 버튼 A와 B를 사용할 수 있다
- [ ] 버튼을 눌렀을 때 메시지를 출력할 수 있다

**예상 소요 시간**: 30분

---

## 🎯 학습 목표

### 핵심 개념

- **디지털 입력**: 버튼의 상태를 읽어오는 것 (눌림/안 눌림)
- **GPIO**: 헥사보드의 입출력 핀

### 실습 목표

1. 버튼 A를 눌렀을 때 감지하기
2. 버튼 A와 B를 함께 사용하기

---

## 📖 이론 설명

### 버튼은 어떻게 동작할까요?

버튼은 가장 간단한 입력 장치입니다. 두 가지 상태만 가집니다:

- **0 (LOW)**: 버튼을 누르지 않은 상태
- **1 (HIGH)**: 버튼을 누른 상태

헥사보드의 버튼은 **Pull-down 방식**으로 연결되어 있습니다:

```
버튼을 누르지 않았을 때 → 0 (LOW)
버튼을 눌렀을 때     → 1 (HIGH)
```

**헥사보드 버튼 위치**:

- 버튼 A: GPIO 35
- 버튼 B: GPIO 34

> 💡 **팁**: Pull-down 방식은 버튼을 누르면 1이 됩니다. 간단하죠?

---

## 🔧 실습 준비

### 필요한 것

- [x] 헥사보드 × 1
- [x] USB 케이블 × 1
- [x] Thonny IDE

---

## 💻 실습 1: 버튼 A 눌러보기

### 가장 간단한 버튼 읽기

**코드**:

```python
# 파일명: ch04_button_simple.py
# 버튼 A 읽기

from machine import Pin
import time

# 버튼 A 설정
button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)

print("버튼 A를 눌러보세요!")

while True:
    # 버튼 상태 읽기
    if button_a.value() == 1:  # 1 = 눌림
        print("버튼 A가 눌렸습니다!")

    time.sleep(0.1)
```

**코드 설명**:

- `Pin(35, Pin.IN, Pin.PULL_DOWN)`: GPIO 35번을 입력으로 설정, Pull-down 방식
- `button_a.value()`: 버튼 상태 읽기 (0 또는 1)
- `if button_a.value() == 1`: 1이면 눌린 상태

### 실행하기

1. Thonny에서 위 코드를 입력하세요
2. ▶️ 실행 버튼을 누르세요
3. 헥사보드의 버튼 A를 눌러보세요
4. "버튼 A가 눌렸습니다!" 메시지가 나타납니다

---

## 💻 실습 2: 버튼 눌림만 감지하기

위 코드는 버튼을 누르고 있으면 메시지가 계속 나옵니다.  
**한 번만 출력**되도록 개선해봅시다!

**코드**:

```python
# 파일명: ch04_button_once.py
# 버튼을 눌렀을 때 한 번만 출력

from machine import Pin
import time

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)

previous_state = 0  # 이전 상태 저장

print("버튼 A를 눌러보세요!")

while True:
    current_state = button_a.value()

    # 0 → 1로 바뀔 때만 (눌렀을 때만)
    if previous_state == 0 and current_state == 1:
        print("✓ 버튼 A 눌림!")

    previous_state = current_state
    time.sleep(0.05)
```

**핵심 아이디어**:

- 이전 상태를 기억해두고
- 0에서 1로 바뀌는 순간만 감지!

---

## 💻 실습 3: 두 개의 버튼 사용하기

이제 버튼 A와 B를 함께 사용해봅시다!

**코드**:

```python
# 파일명: ch04_dual_buttons.py
# 버튼 A와 B 함께 사용하기

from machine import Pin
import time

# 두 버튼 설정
button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
button_b = Pin(34, Pin.IN, Pin.PULL_DOWN)

prev_a = 0
prev_b = 0

print("=" * 30)
print("버튼 테스트")
print("=" * 30)
print("버튼 A 또는 B를 눌러보세요!")
print()

while True:
    curr_a = button_a.value()
    curr_b = button_b.value()

    # 버튼 A 눌림
    if prev_a == 0 and curr_a == 1:
        print("🔵 버튼 A")

    # 버튼 B 눌림
    if prev_b == 0 and curr_b == 1:
        print("🟢 버튼 B")

    # 두 버튼 동시 눌림
    if curr_a == 1 and curr_b == 1:
        if prev_a == 0 or prev_b == 0:
            print("🟣 A+B 동시!")

    prev_a = curr_a
    prev_b = curr_b
    time.sleep(0.05)
```

---

## ✅ 동작 확인

**정상 동작하면**:

- ✅ 버튼 A를 누르면 "🔵 버튼 A" 출력
- ✅ 버튼 B를 누르면 "🟢 버튼 B" 출력
- ✅ 두 버튼을 동시에 누르면 "🟣 A+B 동시!" 출력

**결과 화면**:

```
==============================
버튼 테스트
==============================
버튼 A 또는 B를 눌러보세요!

🔵 버튼 A
🟢 버튼 B
🟣 A+B 동시!
```

---

## 🐛 문제가 생겼나요?

### 문제 1: 버튼을 눌러도 반응이 없어요

**해결 방법**:

1. 헥사보드가 USB로 연결되어 있나요?
2. 코드에서 핀 번호가 맞나요? (버튼 A = 35, 버튼 B = 34)
3. `Pin.PULL_DOWN`이 제대로 입력되었나요?

### 문제 2: 한 번 눌렀는데 여러 번 감지돼요

**해결 방법**:

- `time.sleep(0.05)` 값을 `0.1`이나 `0.2`로 늘려보세요

```python
time.sleep(0.1)  # 100ms로 변경
```

### 문제 3: 에러 메시지가 나와요

**ImportError: no module named 'machine'**

- 일반 Python이 아닌 MicroPython으로 실행해야 합니다
- Thonny 하단에서 "MicroPython (ESP32)"를 선택하세요

---

## 🎓 핵심 요약

### 오늘 배운 것

1. **버튼 읽기**: `button.value()`로 버튼 상태 확인 (0 또는 1)
2. **Pull-down**: 버튼을 누르면 1, 안 누르면 0
3. **상태 변화 감지**: 이전 상태와 비교해서 눌림 감지

### 핵심 코드

```python
# 버튼 설정 (Pull-down)
button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)

# 버튼 읽기
if button_a.value() == 1:  # 1 = 눌림
    print("버튼 눌림!")
```

---

## 🚀 도전 과제

### 과제 1: 버튼 카운터 ⭐️

버튼 A를 누를 때마다 숫자를 세는 프로그램을 만들어보세요.

```
버튼 A를 1번 눌렀습니다!
버튼 A를 2번 눌렀습니다!
버튼 A를 3번 눌렀습니다!
```

**힌트**: `count = 0` 변수를 만들고 버튼을 누를 때마다 `count += 1`

### 과제 2: 리셋 버튼 ⭐️⭐️

- 버튼 A: 카운트 증가
- 버튼 B: 카운트를 0으로 리셋

**힌트**: 버튼 B를 눌렀을 때 `count = 0`

---

## 🔗 참고 자료

- [MicroPython Pin 문서](https://docs.micropython.org/en/latest/library/machine.Pin.html)

**다음 챕터**: Chapter 5 - 네오픽셀 LED 제어하기

---

## 📝 학습 체크

- [ ] 버튼 A를 눌러서 메시지를 출력할 수 있나요?
- [ ] 버튼 A와 B를 함께 사용할 수 있나요?
- [ ] 코드가 정상적으로 동작하나요?

**완료 시간**: \_\_\_시 \_\_\_분  
**실제 소요 시간**: \_\_\_분

---

> **💡 TIP**: 버튼은 모든 IoT 프로젝트의 기본입니다. 간단하지만 매우 중요해요!

---

**챕터 작성**: 2025-11-25  
**작성자**: AIoT eBook Team

# Chapter 5. 네오픽셀 기초 – 한 칸에서 5x5까지

> **PART 2**: 헥사보드 기본 제어 – 버튼과 네오픽셀

---

## 📚 이 챕터에서 배울 내용

- [ ] 네오픽셀 1개를 켜고 끌 수 있다
- [ ] 네오픽셀의 색상을 바꿀 수 있다
- [ ] 5×5 네오픽셀 전체를 제어할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **네오픽셀**: 개별 제어 가능한 RGB LED
- **RGB**: Red(빨강), Green(초록), Blue(파랑)의 조합으로 색상 표현
- **인덱스**: LED의 위치 번호 (0번부터 시작)

---

## 📖 네오픽셀이란?

### RGB LED의 마법

네오픽셀은 **WS2812B** 칩이 내장된 LED입니다.

**특징**:

- 빨강, 초록, 파랑을 섞어서 1,600만 가지 색상 표현
- 각 LED를 개별적으로 제어 가능
- 한 줄로 연결 (체인 방식)

**색상 조합**:

```
빨강(255, 0, 0)
초록(0, 255, 0)
파랑(0, 0, 255)
흰색(255, 255, 255)
보라(255, 0, 255)
노랑(255, 255, 0)
꺼짐(0, 0, 0)
```

> 💡 **팁**: 숫자가 클수록 밝아집니다! (0~255)

### 헥사보드의 네오픽셀

- **개수**: 25개 (5행 × 5열)
- **GPIO**: 23번
- **번호**: 0번부터 24번까지

```
네오픽셀 배치 (5×5)
┌─────────────┐
│ 0  1  2  3  4 │
│ 5  6  7  8  9 │
│10 11 12 13 14│
│15 16 17 18 19│
│20 21 22 23 24│
└─────────────┘
```

---

## 🔧 실습 준비

### 필요한 것

- [x] 헥사보드 × 1
- [x] USB 케이블 × 1
- [x] Thonny IDE

---

## 💻 실습 1: 첫 번째 LED 켜기

### LED 1개 켜기

**코드**:

```python
# 파일명: ch05_neopixel_one.py
# 네오픽셀 1개 켜기

from machine import Pin
import neopixel
import time

# 네오픽셀 설정
NUM_LEDS = 25  # LED 개수
PIN = 23       # GPIO 핀

# 네오픽셀 초기화
np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

# 0번 LED를 빨간색으로
np[0] = (255, 0, 0)  # (R, G, B)
np.write()  # 실제로 켜기!

print("0번 LED가 빨간색으로 켜졌습니다!")
```

**코드 설명**:

- `neopixel.NeoPixel()`: 네오픽셀 객체 생성
- `np[0] = (255, 0, 0)`: 0번 LED를 빨간색으로 설정
- `np.write()`: 설정을 LED에 전송 (꼭 필요!)

### 실행하기

1. 코드를 입력하세요
2. ▶️ 실행
3. 왼쪽 위 LED가 빨간색으로 켜집니다!

---

## 💻 실습 2: 색상 바꾸기

### 여러 색상 표현하기

**코드**:

```python
# 파일명: ch05_neopixel_colors.py
# 여러 색상 표현하기

from machine import Pin
import neopixel
import time

NUM_LEDS = 25
PIN = 23

np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

# 색상 리스트
colors = [
    (255, 0, 0),    # 빨강
    (0, 255, 0),    # 초록
    (0, 0, 255),    # 파랑
    (255, 255, 0),  # 노랑
    (255, 0, 255),  # 보라
    (0, 255, 255),  # 청록
    (255, 128, 0),  # 주황
    (255, 255, 255) # 흰색
]

print("색상이 바뀝니다...")

# 색상 순서대로 표시
for color in colors:
    np[0] = color
    np.write()
    print(f"색상: {color}")
    time.sleep(1)

# 끄기
np[0] = (0, 0, 0)
np.write()
print("완료!")
```

**실행 결과**:

- 0번 LED가 1초마다 색상이 바뀝니다
- 총 8가지 색상

---

## 💻 실습 3: 여러 LED 켜기

### 5개 LED 켜기

**코드**:

```python
# 파일명: ch05_neopixel_multiple.py
# 여러 LED 켜기

from machine import Pin
import neopixel
import time

NUM_LEDS = 25
PIN = 23

np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

# 처음 5개 LED를 서로 다른 색으로
np[0] = (255, 0, 0)    # 빨강
np[1] = (0, 255, 0)    # 초록
np[2] = (0, 0, 255)    # 파랑
np[3] = (255, 255, 0)  # 노랑
np[4] = (255, 0, 255)  # 보라

np.write()

print("5개 LED가 켜졌습니다!")
print("Ctrl+C로 종료하세요")

# 프로그램 유지
while True:
    time.sleep(1)
```

**결과**:

```
┌─────────────┐
│🔴🟢🔵🟡🟣│  ← 첫 줄만 켜짐
│░░░░░░░░░░│
│░░░░░░░░░░│
│░░░░░░░░░░│
│░░░░░░░░░░│
└─────────────┘
```

---

## 💻 실습 4: 전체 LED 제어

### 모든 LED를 같은 색으로

**코드**:

```python
# 파일명: ch05_neopixel_all.py
# 전체 LED를 같은 색으로

from machine import Pin
import neopixel
import time

NUM_LEDS = 25
PIN = 23

np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

def fill(color):
    """모든 LED를 같은 색으로"""
    for i in range(NUM_LEDS):
        np[i] = color
    np.write()

# 빨간색으로 채우기
print("빨간색!")
fill((255, 0, 0))
time.sleep(2)

# 초록색으로 채우기
print("초록색!")
fill((0, 255, 0))
time.sleep(2)

# 파란색으로 채우기
print("파란색!")
fill((0, 0, 255))
time.sleep(2)

# 끄기
print("끄기!")
fill((0, 0, 0))
```

**핵심 아이디어**:

- `for` 반복문으로 모든 LED 제어
- `fill()` 함수로 재사용 가능

---

## 💻 실습 5: 간단한 애니메이션

### LED가 하나씩 켜지는 효과

**코드**:

```python
# 파일명: ch05_neopixel_wave.py
# LED 웨이브 효과

from machine import Pin
import neopixel
import time

NUM_LEDS = 25
PIN = 23

np = neopixel.NeoPixel(Pin(PIN), NUM_LEDS)

# 모두 끄기
for i in range(NUM_LEDS):
    np[i] = (0, 0, 0)
np.write()

print("웨이브 시작!")

# LED가 순서대로 켜짐
for i in range(NUM_LEDS):
    # 이전 LED 끄기
    if i > 0:
        np[i-1] = (0, 0, 0)

    # 현재 LED 켜기
    np[i] = (0, 255, 0)  # 초록색
    np.write()

    time.sleep(0.1)

# 마지막 LED 끄기
np[NUM_LEDS-1] = (0, 0, 0)
np.write()

print("완료!")
```

**효과**:

- 초록색 LED가 0번부터 24번까지 순서대로 이동
- 물결치는 듯한 효과

---

## ✅ 동작 확인

**정상 동작하면**:

- ✅ 실습 1: 0번 LED가 빨간색으로 켜짐
- ✅ 실습 2: 0번 LED가 8가지 색으로 변함
- ✅ 실습 3: 첫 줄 5개 LED가 서로 다른 색으로 켜짐
- ✅ 실습 4: 전체 LED가 빨강 → 초록 → 파랑으로 변함
- ✅ 실습 5: LED가 순서대로 이동

---

## 🐛 문제 해결

### 문제 1: LED가 안 켜져요

**해결 방법**:

1. `np.write()` 를 빼먹지 않았나요?
2. 핀 번호가 23번이 맞나요?
3. 헥사보드가 연결되어 있나요?

```python
# 올바른 순서
np[0] = (255, 0, 0)
np.write()  # 꼭 필요!
```

### 문제 2: 색이 이상해요

**해결 방법**:

- RGB 순서를 확인하세요
- 각 값은 0~255 범위

```python
# 올바른 색상 값
np[0] = (255, 0, 0)    # 빨강 ✅
np[0] = (256, 0, 0)    # 잘못됨 ❌ (255 초과)
np[0] = (100, 100, 100) # 밝은 회색 ✅
```

### 문제 3: 너무 밝아요!

**해결 방법**:

- 숫자를 줄이세요 (밝기 조절)

```python
# 밝기 50%
np[0] = (128, 0, 0)   # 어두운 빨강

# 밝기 20%
np[0] = (50, 0, 0)    # 더 어두운 빨강
```

---

## 🎓 핵심 요약

### 오늘 배운 것

1. **네오픽셀 기본**: RGB 색상 조합
2. **개별 제어**: `np[0] = (R, G, B)`
3. **전체 제어**: 반복문으로 모든 LED 제어
4. **애니메이션**: 시간 지연으로 움직이는 효과

### 핵심 코드

```python
# 네오픽셀 초기화
np = neopixel.NeoPixel(Pin(23), 25)

# LED 켜기
np[0] = (255, 0, 0)  # 빨간색
np.write()           # 실제로 표시!

# 모두 끄기
for i in range(25):
    np[i] = (0, 0, 0)
np.write()
```

---

## 🚀 도전 과제

### 과제 1: 무지개 만들기 ⭐️

첫 줄 5개 LED를 무지개 색으로 만들어보세요!

```
🔴🟠🟡🟢🔵
```

**힌트**: 빨강, 주황, 노랑, 초록, 파랑

### 과제 2: 깜빡이는 LED ⭐️⭐️

전체 LED가 켜졌다 꺼졌다 반복하게 만들어보세요.

**힌트**: `while True` + `time.sleep()`

### 과제 3: 십자가 패턴 ⭐️⭐️

5×5 LED의 가운데 십자(+) 모양만 켜보세요!

```
░░🔴░░
░░🔴░░
🔴🔴🔴🔴🔴
░░🔴░░
░░🔴░░
```

**힌트**:

- 세로: 2, 7, 12, 17, 22번
- 가로: 10, 11, 12, 13, 14번

---

## 🎨 색상 참고표

```python
# 기본 색상
RED     = (255, 0, 0)
GREEN   = (0, 255, 0)
BLUE    = (0, 0, 255)
YELLOW  = (255, 255, 0)
PURPLE  = (255, 0, 255)
CYAN    = (0, 255, 255)
WHITE   = (255, 255, 255)
OFF     = (0, 0, 0)

# 파스텔 톤 (밝기 50%)
PINK    = (255, 128, 128)
MINT    = (128, 255, 128)
LAVENDER= (128, 128, 255)

# 어두운 톤 (밝기 20%)
DARK_RED = (50, 0, 0)
DARK_GREEN = (0, 50, 0)
DARK_BLUE = (0, 0, 50)
```

---

## 📝 학습 체크

- [ ] 네오픽셀 1개를 켜고 색상을 바꿀 수 있나요?
- [ ] 여러 LED를 동시에 제어할 수 있나요?
- [ ] `np.write()`의 역할을 이해했나요?
- [ ] RGB 색상 조합을 이해했나요?

**완료 시간**: \_\_\_시 \_\_\_분

---

**다음 챕터**: Chapter 6 - 버튼 + 네오픽셀로 만드는 상태 머신

버튼과 LED를 결합하면 더 재미있는 프로젝트를 만들 수 있습니다!

---

> **💡 TIP**: 네오픽셀은 밝기를 낮춰서 사용하면 눈이 편하고 전력도 절약됩니다!

---

**챕터 작성**: 2025-11-25  
**작성자**: AIoT eBook Team

# Chapter 6. 버튼 + 네오픽셀로 만드는 상태 머신

> **PART 2**: 헥사보드 기본 제어 – 버튼과 네오픽셀

---

## 📚 이 챕터에서 배울 내용

- [ ] 버튼으로 LED 색상을 바꿀 수 있다
- [ ] 상태 머신의 개념을 이해할 수 있다
- [ ] 간단한 게임을 만들 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **상태 머신**: 상태를 저장하고 전환하는 방식
- **모드 전환**: 버튼으로 여러 모드 바꾸기
- **인터랙션**: 입력과 출력을 결합

---

## 📖 상태 머신이란?

### 간단한 예시

전등 스위치를 생각해봅시다:

```
[켜짐] ←→ [꺼짐]
  ↑         ↑
버튼 누름  버튼 누름
```

**상태**: 켜짐 또는 꺼짐  
**전환**: 버튼을 누르면 상태가 바뀜

### 프로그램에서의 상태 머신

```python
# 상태 저장
state = "빨강"

# 버튼을 누르면
if button_pressed:
    if state == "빨강":
        state = "초록"
    elif state == "초록":
        state = "파랑"
    elif state == "파랑":
        state = "빨강"
```

---

## 🔧 실습 준비

### 필요한 것

- [x] 헥사보드 × 1
- [x] USB 케이블 × 1

---

## 💻 실습 1: 버튼으로 LED 켜기/끄기

### 토글 스위치 만들기

**코드**:

```python
# 파일명: ch06_led_toggle.py
# 버튼으로 LED 켜기/끄기

from machine import Pin
import neopixel
import time

# 설정
button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
np = neopixel.NeoPixel(Pin(23), 25)

# 상태 변수
is_on = False  # LED가 켜져 있는지
prev_button = 0

print("버튼 A를 눌러서 LED를 켜고 끄세요!")

while True:
    curr_button = button_a.value()

    # 버튼을 눌렀을 때 (0 → 1)
    if prev_button == 0 and curr_button == 1:
        is_on = not is_on  # 상태 반전!

        if is_on:
            # 전체 LED 켜기
            for i in range(25):
                np[i] = (0, 255, 0)  # 초록색
            print("LED ON")
        else:
            # 전체 LED 끄기
            for i in range(25):
                np[i] = (0, 0, 0)
            print("LED OFF")

        np.write()

    prev_button = curr_button
    time.sleep(0.05)
```

**동작**:

- 버튼 A를 누를 때마다 LED가 켜졌다 꺼졌다 반복

---

## 💻 실습 2: 버튼으로 색상 바꾸기

### 3가지 색상 순환

**코드**:

```python
# 파일명: ch06_color_cycle.py
# 버튼으로 색상 바꾸기

from machine import Pin
import neopixel
import time

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
np = neopixel.NeoPixel(Pin(23), 25)

# 색상 리스트
colors = [
    (255, 0, 0),    # 빨강
    (0, 255, 0),    # 초록
    (0, 0, 255)     # 파랑
]

# 상태 변수
color_index = 0  # 현재 색상 번호
prev_button = 0

def fill(color):
    """전체 LED를 같은 색으로"""
    for i in range(25):
        np[i] = color
    np.write()

# 처음 색상 표시
fill(colors[color_index])
print(f"색상: {color_index} - {colors[color_index]}")

print("버튼 A를 눌러서 색상을 바꾸세요!")

while True:
    curr_button = button_a.value()

    # 버튼 눌림 감지
    if prev_button == 0 and curr_button == 1:
        # 다음 색상으로
        color_index = (color_index + 1) % 3

        # LED 업데이트
        fill(colors[color_index])
        print(f"색상: {color_index} - {colors[color_index]}")

    prev_button = curr_button
    time.sleep(0.05)
```

**핵심 아이디어**:

- `color_index`로 현재 색상 추적
- `(color_index + 1) % 3`: 0 → 1 → 2 → 0 순환

---

## 💻 실습 3: 두 버튼으로 제어하기

### 버튼 A: 색상 변경, 버튼 B: 끄기

**코드**:

```python
# 파일명: ch06_two_buttons.py
# 두 버튼으로 제어

from machine import Pin
import neopixel
import time

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
button_b = Pin(34, Pin.IN, Pin.PULL_DOWN)
np = neopixel.NeoPixel(Pin(23), 25)

colors = [
    (255, 0, 0),    # 빨강
    (0, 255, 0),    # 초록
    (0, 0, 255),    # 파랑
    (255, 255, 0),  # 노랑
    (255, 0, 255)   # 보라
]

color_index = 0
prev_a = 0
prev_b = 0

def fill(color):
    for i in range(25):
        np[i] = color
    np.write()

fill(colors[color_index])

print("버튼 A: 색상 변경")
print("버튼 B: 끄기")

while True:
    curr_a = button_a.value()
    curr_b = button_b.value()

    # 버튼 A: 색상 변경
    if prev_a == 0 and curr_a == 1:
        color_index = (color_index + 1) % 5
        fill(colors[color_index])
        print(f"색상 {color_index+1}")

    # 버튼 B: 끄기
    if prev_b == 0 and curr_b == 1:
        fill((0, 0, 0))
        color_index = 0  # 초기화
        print("LED OFF")

    prev_a = curr_a
    prev_b = curr_b
    time.sleep(0.05)
```

---

## 💻 실습 4: 간단한 게임 – 빠르게 누르기

### 반응 속도 게임

**코드**:

```python
# 파일명: ch06_reaction_game.py
# 반응 속도 게임

from machine import Pin
import neopixel
import time
import random

button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)
np = neopixel.NeoPixel(Pin(23), 25)

def fill(color):
    for i in range(25):
        np[i] = color
    np.write()

print("=" * 30)
print("  반응 속도 게임")
print("=" * 30)
print("빨간색이 나오면 빠르게 버튼을 누르세요!")
print()

prev_button = 0

while True:
    # 모두 끄기
    fill((0, 0, 0))

    # 랜덤 대기 시간 (1~3초)
    wait_time = random.uniform(1, 3)
    print(f"대기 중... ({wait_time:.1f}초)")
    time.sleep(wait_time)

    # 빨간색 켜기!
    fill((255, 0, 0))
    start_time = time.time()
    print("지금!")

    # 버튼 누를 때까지 대기
    while True:
        curr_button = button_a.value()

        if prev_button == 0 and curr_button == 1:
            # 반응 시간 계산
            reaction_time = time.time() - start_time

            # 결과 표시
            if reaction_time < 0.3:
                print(f"⚡ 굉장해요! {reaction_time:.3f}초")
                fill((255, 255, 0))  # 노란색
            elif reaction_time < 0.5:
                print(f"👍 빨라요! {reaction_time:.3f}초")
                fill((0, 255, 0))  # 초록색
            else:
                print(f"💪 좋아요! {reaction_time:.3f}초")
                fill((0, 0, 255))  # 파란색

            time.sleep(2)
            break

        prev_button = curr_button
        time.sleep(0.01)

    print()
```

**게임 설명**:

1. LED가 꺼진 상태로 대기
2. 랜덤 시간 후 빨간색 켜짐
3. 빠르게 버튼 누르기!
4. 반응 시간 측정 및 결과 표시

---

## ✅ 동작 확인

**정상 동작하면**:

- ✅ 실습 1: 버튼으로 LED가 켜지고 꺼짐
- ✅ 실습 2: 버튼으로 색상이 순환함
- ✅ 실습 3: 두 버튼이 각각 다르게 동작
- ✅ 실습 4: 게임이 정상 작동

---

## 🎓 핵심 요약

### 오늘 배운 것

1. **상태 머신**: 상태를 저장하고 전환
2. **버튼 + LED**: 입력과 출력 결합
3. **모드 전환**: 여러 상태 순환
4. **게임 만들기**: 타이밍과 피드백

### 핵심 코드 패턴

```python
# 상태 저장
state = 0

# 버튼 눌림 감지
if prev == 0 and curr == 1:
    # 상태 변경
    state = (state + 1) % 3

    # LED 업데이트
    update_led(state)
```

---

## 🚀 도전 과제

### 과제 1: 밝기 조절 ⭐️

버튼 A: 밝기 증가  
버튼 B: 밝기 감소

**힌트**: 밝기 변수를 만들고 0~255 범위로 제한

### 과제 2: 패턴 선택 ⭐️⭐️

버튼을 누를 때마다 다른 패턴 표시:

- 패턴 1: 전체 빨강
- 패턴 2: 십자가
- 패턴 3: 테두리만

**힌트**: 각 패턴을 함수로 만들기

### 과제 3: 타이머 ⭐️⭐️⭐️

버튼 A를 누르면 5초 카운트다운:

- 5초: 초록색
- 3초: 노란색
- 1초: 빨간색
- 0초: 깜빡임

**힌트**: `time.time()`으로 경과 시간 계산

---

## 📝 학습 체크

- [ ] 버튼으로 LED를 제어할 수 있나요?
- [ ] 상태 머신의 개념을 이해했나요?
- [ ] 두 버튼을 함께 사용할 수 있나요?
- [ ] 간단한 게임을 만들 수 있나요?

**완료 시간**: \_\_\_시 \_\_\_분

---

## 🎉 PART 2 완료!

축하합니다! PART 2를 모두 마쳤습니다.

**PART 2에서 배운 것**:

- ✅ 버튼 2개 제어
- ✅ 네오픽셀 25개 제어
- ✅ 버튼 + LED 결합
- ✅ 상태 머신 개념

**다음은?**  
PART 3에서는 온습도 센서와 조도 센서를 연결합니다!

---

**다음 챕터**: Chapter 7 - 온습도 센서 이해와 연결

---

> **💡 TIP**: 상태 머신은 복잡한 프로그램을 만들 때 매우 유용합니다. 나중에 AI 제어에서도 사용됩니다!

---

**챕터 작성**: 2025-11-25  
**작성자**: AIoT eBook Team

# Chapter 7. 온습도 센서 이해와 연결

> **PART 3**: 온습도 센서 & 조도 센서 연결하기

---

## 📚 이 챕터에서 배울 내용

- [ ] 온습도 센서(DHT11)를 연결할 수 있다
- [ ] 온도와 습도를 측정할 수 있다
- [ ] 측정값을 화면에 출력할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **온습도 센서**: 온도와 습도를 동시에 측정하는 센서
- **DHT11**: 가장 많이 사용되는 온습도 센서
- **디지털 센서**: 데이터를 디지털로 전송

---

## 📖 온습도 센서란?

### DHT11 vs DHT22

**DHT11** (우리가 사용):

- 온도: 0~50°C (±2°C 오차)
- 습도: 20~90% (±5% 오차)
- 저렴함
- 초보자에게 적합

**DHT22** (고급):

- 온도: -40~80°C (±0.5°C)
- 습도: 0~100% (±2%)
- 더 정확하지만 비쌈

> 💡 **팁**: 이 책에서는 DHT11을 사용하지만 DHT22도 같은 코드로 동작합니다!

### DHT11 핀 구성

```
DHT11 센서 (3핀)
┌─────────┐
│  DHT11  │
│         │
│ 1  2  3 │
└─┬──┬──┬─┘
  │  │  │
VCC DATA GND
```

- **VCC**: 전원 (3.3V)
- **DATA**: 데이터 신호
- **GND**: 접지

---

## 🔧 실습 준비

### 필요한 것

- [x] 헥사보드 × 1
- [x] DHT11 센서 모듈 × 1 (저항 내장)
- [x] 3핀 케이블 × 1
- [x] USB 케이블 × 1

> **💡 TIP**: DHT11 센서 모듈은 필요한 저항이 내장되어 있고, 3핀 케이블로 헥사보드에 바로 연결할 수 있어 매우 간편합니다!

### 센서 연결하기

```
DHT11          헥사보드
--------------------------
VCC (1번)  →  3.3V
DATA (2번) →  PIN1 (GPIO 32)
GND (3번)  →  GND
```

**연결 순서**:

1. 헥사보드의 전원을 끕니다 (USB 제거)
2. 점퍼 케이블로 연결합니다
3. 연결을 다시 확인합니다
4. USB를 연결합니다

⚠️ **주의**: VCC와 GND를 반대로 연결하면 센서가 고장날 수 있습니다!

---

## 💻 실습 1: DHT11 라이브러리 설치

### dht 모듈 확인

MicroPython에는 `dht` 모듈이 기본 내장되어 있습니다!

**테스트 코드**:

```python
# 파일명: ch07_test_import.py
# DHT 모듈 확인

try:
    import dht
    print("✓ dht 모듈이 있습니다!")
except ImportError:
    print("✗ dht 모듈이 없습니다")
```

실행하면 "dht 모듈이 있습니다!"가 나와야 합니다.

---

## 💻 실습 2: 첫 번째 온습도 측정

### 온도와 습도 읽기

**코드**:

```python
# 파일명: ch07_dht_basic.py
# 온습도 센서 기본

from machine import Pin
import dht
import time

# DHT11 센서 설정 (GPIO 32번)
sensor = dht.DHT11(Pin(32))

print("온습도 센서 테스트")
print("-" * 30)

# 한 번 측정
sensor.measure()  # 측정 시작
temp = sensor.temperature()  # 온도 (°C)
humid = sensor.humidity()    # 습도 (%)

print(f"온도: {temp}°C")
print(f"습도: {humid}%")
```

**코드 설명**:

- `dht.DHT11(Pin(32))`: DHT11 센서를 GPIO 32번으로 설정
- `sensor.measure()`: 측정 명령 (꼭 필요!)
- `sensor.temperature()`: 온도 읽기
- `sensor.humidity()`: 습도 읽기

### 실행 결과 예시

```
온습도 센서 테스트
------------------------------
온도: 24°C
습도: 65%
```

---

## 💻 실습 3: 실시간 모니터링

### 1초마다 측정하기

**코드**:

```python
# 파일명: ch07_dht_monitor.py
# 실시간 온습도 모니터링

from machine import Pin
import dht
import time

sensor = dht.DHT11(Pin(32))

print("=" * 40)
print("  실시간 온습도 모니터링")
print("=" * 40)
print("Ctrl+C로 종료")
print()

count = 0

while True:
    try:
        # 측정
        sensor.measure()
        temp = sensor.temperature()
        humid = sensor.humidity()

        # 출력
        count += 1
        print(f"[{count}] 온도: {temp}°C | 습도: {humid}%")

        # 2초 대기 (DHT11은 최소 2초 간격 필요)
        time.sleep(2)

    except OSError as e:
        print("센서 읽기 실패:", e)
        time.sleep(2)
```

**실행 결과**:

```
========================================
  실시간 온습도 모니터링
========================================
Ctrl+C로 종료

[1] 온도: 24°C | 습도: 65%
[2] 온도: 24°C | 습도: 66%
[3] 온도: 25°C | 습도: 65%
```

> 💡 **팁**: DHT11은 최소 2초 간격으로 측정해야 합니다!

---

## 💻 실습 4: LED로 온도 표시

### 온도에 따라 색상 변경

**코드**:

```python
# 파일명: ch07_temp_led.py
# 온도에 따라 LED 색상 변경

from machine import Pin
import dht
import neopixel
import time

sensor = dht.DHT11(Pin(32))
np = neopixel.NeoPixel(Pin(23), 25)

def fill(color):
    """전체 LED를 같은 색으로"""
    for i in range(25):
        np[i] = color
    np.write()

print("온도 표시 LED")
print("낮음: 파랑 | 보통: 초록 | 높음: 빨강")
print()

while True:
    try:
        sensor.measure()
        temp = sensor.temperature()
        humid = sensor.humidity()

        # 온도에 따라 색상 선택
        if temp < 20:
            color = (0, 0, 255)  # 파랑 (추움)
            status = "낮음"
        elif temp < 26:
            color = (0, 255, 0)  # 초록 (적당)
            status = "보통"
        else:
            color = (255, 0, 0)  # 빨강 (더움)
            status = "높음"

        # LED 업데이트
        fill(color)

        print(f"온도: {temp}°C ({status}) | 습도: {humid}%")

        time.sleep(2)

    except OSError as e:
        print("오류:", e)
        time.sleep(2)
```

**동작**:

- 20°C 미만: 파란색 (추움)
- 20~25°C: 초록색 (적당)
- 26°C 이상: 빨간색 (더움)

---

## ✅ 동작 확인

**정상 동작하면**:

- ✅ 온도 값이 출력됨 (예: 24°C)
- ✅ 습도 값이 출력됨 (예: 65%)
- ✅ 2초마다 업데이트됨
- ✅ LED 색상이 온도에 따라 변함

---

## 🐛 문제 해결

### 문제 1: "OSError" 에러

**증상**:

```
OSError: [Errno 116] ETIMEDOUT
```

**원인**:

- 센서가 제대로 연결되지 않음
- 측정 간격이 너무 짧음

**해결 방법**:

1. 연결 확인:
   - VCC → 3.3V
   - DATA → GPIO 32
   - GND → GND
2. 2초 이상 간격으로 측정
3. 센서를 다시 연결

### 문제 2: 값이 이상해요

**증상**:

- 온도가 너무 높거나 낮음 (예: 50°C)
- 습도가 0% 또는 100%

**원인**:

- 센서가 초기화 중
- 불량 센서

**해결 방법**:

1. 10초 정도 기다리기
2. 헥사보드 재시작
3. 센서를 다른 것으로 교체

### 문제 3: 측정값이 안 변해요

**증상**:

- 계속 같은 값만 나옴

**원인**:

- DHT11은 측정이 느림 (2초 간격)
- 실제로 온습도가 안정적

**해결 방법**:

- 손가락으로 센서를 살짝 감싸면 온도와 습도가 올라갑니다
- 입김을 불면 습도가 올라갑니다

---

## 🎓 핵심 요약

### 오늘 배운 것

1. **DHT11 센서**: 온도와 습도를 동시 측정
2. **센서 연결**: VCC, DATA, GND 3핀 연결
3. **측정 방법**: `measure()` → `temperature()` / `humidity()`
4. **측정 간격**: 최소 2초

### 핵심 코드

```python
# 온습도 센서 사용
sensor = dht.DHT11(Pin(32))

sensor.measure()  # 측정
temp = sensor.temperature()  # 온도
humid = sensor.humidity()    # 습도

time.sleep(2)  # 2초 대기 (중요!)
```

---

## 🚀 도전 과제

### 과제 1: 경고 시스템 ⭐️

온도가 28°C 이상이면 LED를 빨간색으로 깜빡이게 만들어보세요.

**힌트**: `while` 안에 `if temp > 28` 조건 추가

### 과제 2: 최고/최저 온도 ⭐️⭐️

측정한 온도 중 최고 온도와 최저 온도를 기록하고 출력하세요.

**힌트**: `max_temp = 0`, `min_temp = 100` 변수 사용

### 과제 3: 쾌적도 표시 ⭐️⭐️

온도와 습도를 모두 고려해서 쾌적도를 표시하세요:

- 쾌적: 온도 20~25°C, 습도 40~60%
- 보통: 그 외
- 불쾌: 온도 30°C 이상 또는 습도 80% 이상

---

## 📝 학습 체크

- [ ] DHT11 센서를 연결했나요?
- [ ] 온도와 습도를 측정할 수 있나요?
- [ ] LED로 온도를 표시할 수 있나요?
- [ ] 2초 간격의 중요성을 이해했나요?

**완료 시간**: \_\_\_시 \_\_\_분

---

**다음 챕터**: Chapter 8 - 조도 센서 이해와 연결

빛의 밝기를 측정해봅시다!

---

> **💡 TIP**: DHT11 센서는 실내 환경 모니터링에 아주 유용합니다. 스마트 홈의 시작입니다!

---

**챕터 작성**: 2025-11-25  
**작성자**: AIoT eBook Team

# Chapter 8. 조도 센서 이해와 연결

> **PART 3**: 온습도 센서 & 조도 센서 연결하기

---

## 📚 이 챕터에서 배울 내용

- [ ] 조도 센서를 연결할 수 있다
- [ ] 빛의 밝기를 측정할 수 있다
- [ ] 밝기에 따라 LED를 제어할 수 있다

**예상 소요 시간**: 35분

---

## 🎯 학습 목표

### 핵심 개념

- **조도 센서**: 빛의 밝기를 측정하는 센서
- **포토레지스터**: 빛에 따라 저항이 변하는 소자
- **ADC**: 아날로그 값을 디지털로 변환

---

## 📖 조도 센서란?

### 포토레지스터 (CdS 센서)

**동작 원리**:

- 빛이 많으면 → 저항 낮아짐 → 전압 높아짐
- 빛이 적으면 → 저항 높아짐 → 전압 낮아짐

**활용 예**:

- 자동 가로등 (어두우면 켜짐)
- 스마트폰 화면 밝기 자동 조절
- 보안등

> 💡 **팁**: 손으로 센서를 가리면 어두워져서 값이 변합니다!

### ADC란?

**ADC** (Analog to Digital Converter):

- 아날로그 전압 → 디지털 숫자로 변환
- ESP32는 0~4095 범위 (12bit)

```
밝음 (높은 전압)  →  높은 숫자 (예: 3000)
어두움 (낮은 전압) →  낮은 숫자 (예: 100)
```

---

## 🔧 실습 준비

### 필요한 것

- [x] 헥사보드 × 1
- [x] 조도 센서 모듈 × 1 (저항 내장)
- [x] 3핀 케이블 × 1
- [x] USB 케이블 × 1

> **💡 TIP**: 조도 센서 모듈은 포토레지스터와 필요한 저항이 이미 내장되어 있고, 3핀 케이블로 헥사보드에 바로 연결할 수 있어 매우 간편합니다!

### 센서 연결하기

```
조도센서 모듈     헥사보드
--------------------------
VCC          →  3.3V
OUT          →  PIN2 (GPIO 33)
GND          →  GND
```

**연결 순서**:

1. VCC를 헥사보드 3.3V에 연결
2. OUT을 GPIO 33 (PIN2)에 연결
3. GND를 헥사보드 GND에 연결

⚠️ **주의**: GPIO 33은 ADC 전용 핀입니다.

---

## 💻 실습 1: ADC 기본 사용

### 빛의 밝기 읽기

**코드**:

```python
# 파일명: ch08_light_basic.py
# 조도 센서 기본

from machine import Pin, ADC
import time

# ADC 설정 (GPIO 33번)
light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)  # 0~3.3V 범위

print("조도 센서 테스트")
print("-" * 30)

# 한 번 측정
value = light_sensor.read()  # 0~4095
print(f"밝기 값: {value}")

if value > 2000:
    print("상태: 밝음 ☀️")
elif value > 1000:
    print("상태: 보통 ⛅")
else:
    print("상태: 어두움 🌙")
```

**코드 설명**:

- `ADC(Pin(33))`: GPIO 33번을 ADC로 사용
- `atten(ADC.ATTN_11DB)`: 0~3.3V 전압 측정
- `read()`: 현재 값 읽기 (0~4095)

### 실행 결과 예시

```
조도 센서 테스트
------------------------------
밝기 값: 2850
상태: 밝음 ☀️
```

---

## 💻 실습 2: 실시간 밝기 모니터링

### 0.5초마다 측정하기

**코드**:

```python
# 파일명: ch08_light_monitor.py
# 실시간 밝기 모니터링

from machine import Pin, ADC
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)

print("=" * 40)
print("  실시간 밝기 모니터링")
print("=" * 40)
print("손으로 센서를 가려보세요!")
print("Ctrl+C로 종료")
print()

count = 0

while True:
    value = light_sensor.read()

    # 상태 판단
    if value > 2500:
        status = "매우 밝음 ☀️☀️"
        bar = "█" * 20
    elif value > 2000:
        status = "밝음 ☀️"
        bar = "█" * 15 + "░" * 5
    elif value > 1000:
        status = "보통 ⛅"
        bar = "█" * 10 + "░" * 10
    elif value > 500:
        status = "어두움 🌙"
        bar = "█" * 5 + "░" * 15
    else:
        status = "매우 어두움 🌙🌙"
        bar = "░" * 20

    count += 1
    print(f"[{count:3d}] {value:4d} | {bar} | {status}")

    time.sleep(0.5)
```

**실행 결과**:

```
========================================
  실시간 밝기 모니터링
========================================
손으로 센서를 가려보세요!
Ctrl+C로 종료

[  1] 2850 | ████████████████████ | 매우 밝음 ☀️☀️
[  2] 2750 | ████████████████████ | 매우 밝음 ☀️☀️
[  3] 1200 | ██████████░░░░░░░░░░ | 보통 ⛅
[  4]  350 | ░░░░░░░░░░░░░░░░░░░░ | 매우 어두움 🌙🌙
```

---

## 💻 실습 3: 자동 조명 시스템

### 어두우면 LED 켜기

**코드**:

```python
# 파일명: ch08_auto_light.py
# 자동 조명 시스템

from machine import Pin, ADC
import neopixel
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)

np = neopixel.NeoPixel(Pin(23), 25)

def fill(color):
    """전체 LED를 같은 색으로"""
    for i in range(25):
        np[i] = color
    np.write()

print("자동 조명 시스템")
print("손으로 센서를 가려보세요!")
print()

# 기준값 설정
DARK_THRESHOLD = 1000  # 이 값보다 낮으면 어두움

while True:
    value = light_sensor.read()

    if value < DARK_THRESHOLD:
        # 어두우면 LED 켜기
        fill((255, 255, 100))  # 따뜻한 흰색
        print(f"밝기: {value:4d} | LED ON  💡")
    else:
        # 밝으면 LED 끄기
        fill((0, 0, 0))
        print(f"밝기: {value:4d} | LED OFF")

    time.sleep(0.5)
```

**동작**:

- 밝을 때: LED 꺼짐
- 어두울 때: LED 켜짐 (자동!)

---

## 💻 실습 4: 밝기에 따른 LED 색상

### 밝기를 색상으로 표현

**코드**:

```python
# 파일명: ch08_brightness_color.py
# 밝기를 색상으로 표현

from machine import Pin, ADC
import neopixel
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)

np = neopixel.NeoPixel(Pin(23), 25)

def fill(color):
    for i in range(25):
        np[i] = color
    np.write()

print("밝기 표시 LED")
print("빨강: 어두움 | 노랑: 보통 | 흰색: 밝음")
print()

while True:
    value = light_sensor.read()

    # 밝기에 따라 색상 결정
    if value > 2500:
        color = (255, 255, 255)  # 흰색 (매우 밝음)
        status = "매우 밝음"
    elif value > 2000:
        color = (255, 255, 0)  # 노랑 (밝음)
        status = "밝음"
    elif value > 1000:
        color = (0, 255, 0)  # 초록 (보통)
        status = "보통"
    elif value > 500:
        color = (255, 128, 0)  # 주황 (어두움)
        status = "어두움"
    else:
        color = (255, 0, 0)  # 빨강 (매우 어두움)
        status = "매우 어두움"

    fill(color)
    print(f"밝기: {value:4d} | {status}")

    time.sleep(0.5)
```

---

## ✅ 동작 확인

**정상 동작하면**:

- ✅ 밝기 값이 출력됨 (예: 2850)
- ✅ 손으로 가리면 값이 낮아짐
- ✅ LED가 밝기에 따라 변함
- ✅ 자동 조명이 작동함

---

## 🐛 문제 해결

### 문제 1: 값이 항상 0 또는 4095

**원인**:

- 센서 연결 불량
- 잘못된 핀 번호

**해결 방법**:

1. 연결 확인: VCC, OUT, GND
2. GPIO 33번 확인
3. 센서 모듈 확인

### 문제 2: 값이 너무 작거나 큼

**원인**:

- 환경이 너무 밝거나 어두움
- 센서 감도 차이

**해결 방법**:

- `DARK_THRESHOLD` 값을 조정
- 손으로 가려서 테스트

```python
# 기준값 조정
DARK_THRESHOLD = 1500  # 높이면 더 쉽게 켜짐
```

### 문제 3: 값이 너무 빠르게 변해요

**원인**:

- 센서가 민감함
- 조명이 깜빡임

**해결 방법**:

- 평균값 사용

```python
# 5번 측정 평균
total = 0
for i in range(5):
    total += light_sensor.read()
    time.sleep(0.01)
value = total // 5
```

---

## 🎓 핵심 요약

### 오늘 배운 것

1. **조도 센서**: 빛의 밝기를 0~4095로 측정
2. **ADC**: 아날로그 전압을 디지털 값으로 변환
3. **자동 제어**: 밝기에 따라 LED 자동 제어
4. **기준값**: `THRESHOLD`로 켜짐/꺼짐 결정

### 핵심 코드

```python
# 조도 센서 사용
light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)

value = light_sensor.read()  # 0~4095

if value < 1000:  # 어두움
    fill((255, 255, 100))  # LED 켜기
```

---

## 🚀 도전 과제

### 과제 1: 자동 밝기 조절 ⭐️

밝기에 비례해서 LED 밝기를 조절하세요.

- 매우 밝음 → LED 꺼짐
- 어두움 → LED 밝게

**힌트**: `value`를 0~255로 변환

### 과제 2: 야간 모드 ⭐️⭐️

일정 시간 동안 어두우면 "야간 모드"로 전환하세요.

**힌트**: 카운터 사용, 10회 연속 어두우면 전환

### 과제 3: 온도+밝기 복합 ⭐️⭐️⭐️

온도 센서와 조도 센서를 함께 사용:

- 밝고 더우면: 빨간색
- 어둡고 추우면: 파란색
- 그 외: 초록색

---

## 📝 학습 체크

- [ ] 조도 센서를 연결했나요?
- [ ] 밝기를 측정할 수 있나요?
- [ ] 자동 조명 시스템이 작동하나요?
- [ ] 기준값을 조정할 수 있나요?

**완료 시간**: \_\_\_시 \_\_\_분

---

**다음 챕터**: Chapter 9 - 센서 데이터 정리 및 단위 변환

센서 값을 더 유용하게 만들어봅시다!

---

> **💡 TIP**: 조도 센서는 스마트 홈에서 가장 많이 사용되는 센서 중 하나입니다!

---

**챕터 작성**: 2025-11-25  
**작성자**: AIoT eBook Team

# Chapter 9. 센서 데이터 정리 및 단위 변환

> **PART 3**: 온습도 센서 & 조도 센서 연결하기

---

## 📚 이 챕터에서 배울 내용

- [ ] 센서 데이터를 정리할 수 있다
- [ ] 단위를 변환할 수 있다 (°C ↔ °F, ADC ↔ %)
- [ ] 평균값을 계산할 수 있다

**예상 소요 시간**: 30분

---

## 🎯 학습 목표

### 핵심 개념

- **데이터 정리**: 센서 오차 제거
- **단위 변환**: 사용자 친화적인 값으로 변환
- **평균값**: 안정적인 측정

---

## 📖 왜 데이터 정리가 필요한가?

### 센서의 문제점

센서는 완벽하지 않습니다:

- 값이 튀는 경우 (노이즈)
- 소수점 너무 많음
- 단위가 사용자 친화적이지 않음

**예시**:

```
온도: 24.8723°C     → 25°C로 표시
밝기: 2847 (ADC)    → 70% 밝음
습도: 64.9%         → 65%
```

---

## 💻 실습 1: 값 반올림하기

### 소수점 정리

**코드**:

```python
# 파일명: ch09_round.py
# 값 반올림

from machine import Pin
import dht
import time

sensor = dht.DHT11(Pin(32))

print("반올림 예제")
print()

sensor.measure()
temp = sensor.temperature()
humid = sensor.humidity()

# 원본 값
print(f"원본: {temp}°C, {humid}%")

# 반올림 (정수)
temp_rounded = round(temp)
humid_rounded = round(humid)

print(f"반올림: {temp_rounded}°C, {humid_rounded}%")
```

**함수**:

- `round(값)`: 반올림 (정수)
- `round(값, 1)`: 소수점 1자리

---

## 💻 실습 2: 단위 변환

### °C → °F 변환

**코드**:

```python
# 파일명: ch09_convert.py
# 온도 단위 변환

from machine import Pin
import dht

sensor = dht.DHT11(Pin(32))

def celsius_to_fahrenheit(celsius):
    """섭씨를 화씨로 변환"""
    return celsius * 9/5 + 32

sensor.measure()
temp_c = sensor.temperature()

# 변환
temp_f = celsius_to_fahrenheit(temp_c)

print(f"섭씨: {temp_c}°C")
print(f"화씨: {temp_f:.1f}°F")
```

**변환 공식**:

- °F = °C × 9/5 + 32
- °C = (°F - 32) × 5/9

---

## 💻 실습 3: ADC를 퍼센트로

### 0~4095 → 0~100%

**코드**:

```python
# 파일명: ch09_adc_percent.py
# ADC 값을 퍼센트로

from machine import Pin, ADC
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)

def adc_to_percent(value, min_val=0, max_val=4095):
    """ADC 값을 퍼센트로 변환"""
    percent = (value - min_val) / (max_val - min_val) * 100
    return int(percent)

print("ADC → 퍼센트 변환")
print()

while True:
    value = light_sensor.read()
    percent = adc_to_percent(value)

    print(f"ADC: {value:4d} | 밝기: {percent:3d}%")

    time.sleep(1)
```

**변환 공식**:

```
퍼센트 = (현재값 - 최소값) / (최대값 - 최소값) × 100
```

---

## 💻 실습 4: 평균값 계산

### 안정적인 측정

**코드**:

```python
# 파일명: ch09_average.py
# 평균값으로 안정화

from machine import Pin, ADC
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)

def read_average(sensor, count=5):
    """여러 번 측정하여 평균 계산"""
    total = 0
    for i in range(count):
        total += sensor.read()
        time.sleep(0.01)
    return total // count

print("평균값 측정")
print()

while True:
    # 한 번 측정
    single = light_sensor.read()

    # 5번 평균
    avg = read_average(light_sensor, 5)

    print(f"단일: {single:4d} | 평균: {avg:4d}")

    time.sleep(1)
```

**효과**:

- 노이즈 감소
- 더 안정적인 값

---

## 💻 실습 5: 종합 데이터 클래스

### 모든 센서 데이터 정리

**코드**:

```python
# 파일명: ch09_sensor_data.py
# 센서 데이터 클래스

from machine import Pin, ADC
import dht
import time

class SensorData:
    """센서 데이터 관리 클래스"""

    def __init__(self):
        self.dht_sensor = dht.DHT11(Pin(32))
        self.light_sensor = ADC(Pin(33))
        self.light_sensor.atten(ADC.ATTN_11DB)

    def read_all(self):
        """모든 센서 읽기"""
        # 온습도
        self.dht_sensor.measure()
        temp = self.dht_sensor.temperature()
        humid = self.dht_sensor.humidity()

        # 조도 (평균)
        light_total = 0
        for i in range(5):
            light_total += self.light_sensor.read()
            time.sleep(0.01)
        light = light_total // 5

        # 조도 퍼센트
        light_percent = int(light / 4095 * 100)

        return {
            'temperature': round(temp),
            'humidity': round(humid),
            'light_raw': light,
            'light_percent': light_percent
        }

    def print_data(self, data):
        """데이터 출력"""
        print(f"온도: {data['temperature']}°C")
        print(f"습도: {data['humidity']}%")
        print(f"밝기: {data['light_percent']}% ({data['light_raw']})")

# 사용 예시
sensors = SensorData()

print("=" * 40)
print("  전체 센서 모니터링")
print("=" * 40)
print()

count = 0
while True:
    try:
        data = sensors.read_all()

        count += 1
        print(f"[{count}]")
        sensors.print_data(data)
        print()

        time.sleep(2)

    except Exception as e:
        print(f"오류: {e}")
        time.sleep(2)
```

**실행 결과**:

```
========================================
  전체 센서 모니터링
========================================

[1]
온도: 24°C
습도: 65%
밝기: 70% (2847)

[2]
온도: 24°C
습도: 66%
밝기: 68% (2765)
```

---

## ✅ 동작 확인

**정상 동작하면**:

- ✅ 값이 반올림됨
- ✅ 단위가 변환됨 (°C ↔ °F)
- ✅ ADC가 퍼센트로 표시됨
- ✅ 평균값이 더 안정적

---

## 🎓 핵심 요약

### 오늘 배운 것

1. **반올림**: `round()` 함수
2. **단위 변환**: 공식을 함수로 만들기
3. **퍼센트 변환**: (값 / 최대값) × 100
4. **평균값**: 여러 번 측정하여 안정화

### 핵심 코드

```python
# 반올림
value = round(24.8)  # 25

# 온도 변환
temp_f = temp_c * 9/5 + 32

# 퍼센트
percent = int(value / 4095 * 100)

# 평균
total = 0
for i in range(5):
    total += sensor.read()
avg = total // 5
```

---

## 🚀 도전 과제

### 과제 1: 불쾌지수 계산 ⭐️

온도와 습도로 불쾌지수 계산:

```
불쾌지수 = (9/5 × 온도) - (0.55 × (1 - 습도/100) × (9/5 × 온도 - 26)) + 32
```

### 과제 2: 이동 평균 ⭐️⭐️

최근 10개 값의 평균 계산

**힌트**: 리스트 사용

### 과제 3: JSON 형식 ⭐️⭐️

센서 데이터를 JSON 문자열로 변환

**힌트**: `ujson` 모듈

---

## 📝 학습 체크

- [ ] 값을 반올림할 수 있나요?
- [ ] 단위를 변환할 수 있나요?
- [ ] ADC를 퍼센트로 바꿀 수 있나요?
- [ ] 평균값을 계산할 수 있나요?

**완료 시간**: \_\_\_시 \_\_\_분

---

**다음 챕터**: Chapter 10 - 센서 데이터를 시각적으로 표현하기

LED로 데이터를 멋지게 표현해봅시다!

---

> **💡 TIP**: 데이터 정리는 사용자 경험을 크게 향상시킵니다!

---

**챕터 작성**: 2025-11-25  
**작성자**: AIoT eBook Team

# Chapter 10. 센서 데이터를 시각적으로 표현하기

> **PART 3**: 온습도 센서 & 조도 센서 연결하기

---

## 📚 이 챕터에서 배울 내용

- [ ] LED로 온도를 바(Bar) 형태로 표시할 수 있다
- [ ] 센서 값에 따라 다양한 패턴을 만들 수 있다
- [ ] 5×5 LED를 그래프처럼 사용할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **데이터 시각화**: 숫자를 그림으로 표현
- **바 그래프**: 값을 막대 형태로 표시
- **히트맵**: 색상으로 온도 표시

---

## 📖 왜 시각화가 중요한가?

숫자보다 그림이 더 직관적입니다!

**숫자로 보기**:

```
온도: 28°C
```

**시각화로 보기**:

```
🟩🟩🟩🟨🟨  (온도 막대)
```

한눈에 "조금 높구나!"를 알 수 있습니다.

---

## 💻 실습 1: 온도 바 그래프

### 온도를 막대로 표시

**코드**:

```python
# 파일명: ch10_temp_bar.py
# 온도 바 그래프

from machine import Pin
import dht
import neopixel
import time

sensor = dht.DHT11(Pin(32))
np = neopixel.NeoPixel(Pin(23), 25)

def show_temperature_bar(temp):
    """온도를 바 그래프로 표시 (중앙 열)"""
    # 모두 끄기
    for i in range(25):
        np[i] = (0, 0, 0)

    # 온도에 따라 막대 높이 결정 (15~35°C)
    if temp < 15:
        bars = 0
    elif temp > 35:
        bars = 5
    else:
        bars = int((temp - 15) / 20 * 5)

    # 중앙 열에 표시 (2번, 7번, 12번, 17번, 22번)
    center_column = [22, 17, 12, 7, 2]  # 아래부터 위로

    for i in range(bars):
        led_index = center_column[i]

        # 온도에 따라 색상 변경
        if temp < 20:
            color = (0, 0, 255)  # 파랑 (추움)
        elif temp < 25:
            color = (0, 255, 0)  # 초록 (적당)
        elif temp < 30:
            color = (255, 255, 0)  # 노랑 (따뜻)
        else:
            color = (255, 0, 0)  # 빨강 (더움)

        np[led_index] = color

    np.write()

print("온도 바 그래프")
print()

while True:
    try:
        sensor.measure()
        temp = sensor.temperature()

        show_temperature_bar(temp)
        print(f"온도: {temp}°C")

        time.sleep(2)

    except Exception as e:
        print(f"오류: {e}")
        time.sleep(2)
```

**시각화 예시**:

```
온도 18°C:          온도 28°C:
░░🔵░░            ░░🔴░░
░░🔵░░            ░░🔴░░
░░░░░            ░░🟡░░
░░░░░            ░░🟢░░
░░░░░            ░░🔵░░
```

---

## 💻 실습 2: 습도 게이지

### 습도를 원형으로 표시

**코드**:

```python
# 파일명: ch10_humid_gauge.py
# 습도 게이지

from machine import Pin
import dht
import neopixel
import time

sensor = dht.DHT11(Pin(32))
np = neopixel.NeoPixel(Pin(23), 25)

def show_humidity_gauge(humid):
    """습도를 테두리로 표시"""
    # 모두 끄기
    for i in range(25):
        np[i] = (0, 0, 0)

    # 테두리 LED (시계 방향)
    border = [0, 1, 2, 3, 4, 9, 14, 19, 24, 23, 22, 21, 20, 15, 10, 5]

    # 습도에 따라 LED 개수 (0~100% → 0~16개)
    led_count = int(humid / 100 * len(border))

    # 색상 결정
    if humid < 40:
        color = (255, 0, 0)  # 빨강 (건조)
    elif humid < 70:
        color = (0, 255, 0)  # 초록 (적당)
    else:
        color = (0, 0, 255)  # 파랑 (습함)

    # LED 켜기
    for i in range(led_count):
        np[border[i]] = color

    np.write()

print("습도 게이지")
print()

while True:
    try:
        sensor.measure()
        humid = sensor.humidity()

        show_humidity_gauge(humid)
        print(f"습도: {humid}%")

        time.sleep(2)

    except Exception as e:
        print(f"오류: {e}")
        time.sleep(2)
```

---

## 💻 실습 3: 밝기 히트맵

### 밝기를 색상 그라데이션으로

**코드**:

```python
# 파일명: ch10_light_heatmap.py
# 밝기 히트맵

from machine import Pin, ADC
import neopixel
import time

light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)

np = neopixel.NeoPixel(Pin(23), 25)

def value_to_color(value):
    """값을 색상으로 변환 (0~4095)"""
    # 0~255 범위로 변환
    brightness = int(value / 4095 * 255)

    if brightness < 64:
        # 매우 어두움: 빨강
        return (brightness * 4, 0, 0)
    elif brightness < 128:
        # 어두움: 주황
        b = (brightness - 64) * 4
        return (255, b, 0)
    elif brightness < 192:
        # 보통: 노랑 → 초록
        r = 255 - (brightness - 128) * 4
        return (r, 255, 0)
    else:
        # 밝음: 흰색
        b = (brightness - 192) * 4
        return (255, 255, b)

def show_heatmap(value):
    """전체 LED를 같은 색으로"""
    color = value_to_color(value)

    for i in range(25):
        np[i] = color
    np.write()

print("밝기 히트맵")
print()

while True:
    value = light_sensor.read()
    percent = int(value / 4095 * 100)

    show_heatmap(value)
    print(f"밝기: {percent}% ({value})")

    time.sleep(0.5)
```

**색상 변화**:

```
어두움 → 밝음
🔴 → 🟠 → 🟡 → 🟢 → ⚪
```

---

## 💻 실습 4: 종합 대시보드

### 모든 센서를 한 화면에

**코드**:

```python
# 파일명: ch10_dashboard.py
# 센서 종합 대시보드

from machine import Pin, ADC
import dht
import neopixel
import time

# 센서 초기화
temp_sensor = dht.DHT11(Pin(32))
light_sensor = ADC(Pin(33))
light_sensor.atten(ADC.ATTN_11DB)
np = neopixel.NeoPixel(Pin(23), 25)

def show_dashboard(temp, humid, light):
    """센서 데이터를 LED로 표시"""
    # 모두 끄기
    for i in range(25):
        np[i] = (0, 0, 0)

    # 왼쪽: 온도 (0, 5, 10, 15, 20)
    temp_bars = int((temp - 15) / 20 * 5)
    temp_leds = [20, 15, 10, 5, 0]
    for i in range(min(temp_bars, 5)):
        np[temp_leds[i]] = (255, 0, 0) if temp > 26 else (0, 255, 0)

    # 중앙: 습도 (2, 7, 12, 17, 22)
    humid_bars = int(humid / 100 * 5)
    humid_leds = [22, 17, 12, 7, 2]
    for i in range(min(humid_bars, 5)):
        np[humid_leds[i]] = (0, 0, 255)

    # 오른쪽: 밝기 (4, 9, 14, 19, 24)
    light_bars = int(light / 4095 * 5)
    light_leds = [24, 19, 14, 9, 4]
    for i in range(min(light_bars, 5)):
        np[light_leds[i]] = (255, 255, 0)

    np.write()

print("=" * 40)
print("  센서 종합 대시보드")
print("=" * 40)
print("왼쪽: 온도 | 중앙: 습도 | 오른쪽: 밝기")
print()

while True:
    try:
        # 온습도 측정
        temp_sensor.measure()
        temp = temp_sensor.temperature()
        humid = temp_sensor.humidity()

        # 밝기 측정
        light = light_sensor.read()
        light_percent = int(light / 4095 * 100)

        # 표시
        show_dashboard(temp, humid, light)

        print(f"온도:{temp:2d}°C | 습도:{humid:2d}% | 밝기:{light_percent:3d}%")

        time.sleep(2)

    except Exception as e:
        print(f"오류: {e}")
        time.sleep(2)
```

**대시보드 화면**:

```
🔴  🔵  🟡
🔴  🔵  🟡
🟢  🔵  ░
🟢  ░   ░
░   ░   ░
```

- 왼쪽 빨강/초록: 온도
- 중앙 파랑: 습도
- 오른쪽 노랑: 밝기

---

## ✅ 동작 확인

**정상 동작하면**:

- ✅ 온도가 바 그래프로 표시됨
- ✅ 습도가 테두리로 표시됨
- ✅ 밝기가 색상으로 표시됨
- ✅ 대시보드가 동시에 표시됨

---

## 🎓 핵심 요약

### 오늘 배운 것

1. **바 그래프**: 값을 높이로 표시
2. **게이지**: 테두리를 채우는 형태
3. **히트맵**: 색상 그라데이션
4. **대시보드**: 여러 데이터 동시 표시

### 핵심 패턴

```python
# 값 → LED 개수
bars = int(value / max_value * 5)

# 값 → 색상
if value < threshold1:
    color = (255, 0, 0)
elif value < threshold2:
    color = (0, 255, 0)
else:
    color = (0, 0, 255)
```

---

## 🚀 도전 과제

### 과제 1: 그래프 애니메이션 ⭐️

바가 부드럽게 올라가고 내려가게 만들기

### 과제 2: 경고 표시 ⭐️⭐️

온도가 너무 높거나 낮으면 깜빡이기

### 과제 3: 데이터 히스토리 ⭐️⭐️⭐️

최근 5개 측정값을 세로로 표시 (트렌드 파악)

---

## 🎉 PART 3 완료!

축하합니다! PART 3를 모두 마쳤습니다.

**PART 3에서 배운 것**:

- ✅ 온습도 센서 (DHT11)
- ✅ 조도 센서 (포토레지스터)
- ✅ 데이터 정리 및 변환
- ✅ LED 시각화

**다음은?**  
PART 4에서는 MQTT로 데이터를 전송합니다!

---

**다음 챕터**: Chapter 11 - MQTT 개념과 데이터 흐름 이해

---

## 📝 학습 체크

- [ ] 바 그래프를 만들 수 있나요?
- [ ] 게이지를 표시할 수 있나요?
- [ ] 대시보드를 만들 수 있나요?

**완료 시간**: \_\_\_시 \_\_\_분

---

> **💡 TIP**: 시각화는 IoT 프로젝트의 꽃입니다. 사용자 경험을 크게 향상시킵니다!

---

**챕터 작성**: 2025-11-25  
**작성자**: AIoT eBook Team

# Chapter 11. MQTT 개념과 데이터 흐름 이해

> **PART 4**: MQTT를 통한 센서 데이터 전송

---

## 📚 이 챕터에서 배울 내용

- [ ] MQTT가 무엇인지 이해할 수 있다
- [ ] Publish/Subscribe 구조를 이해할 수 있다
- [ ] Topic과 Message의 개념을 이해할 수 있다

**예상 소요 시간**: 30분

---

## 🎯 학습 목표

### 핵심 개념

- **MQTT**: IoT를 위한 가벼운 통신 프로토콜
- **Pub/Sub**: 발행(Publish)과 구독(Subscribe) 구조
- **Topic**: 메시지를 분류하는 주소

---

## 📖 MQTT란 무엇인가?

### IoT를 위한 통신 방식

**MQTT (Message Queuing Telemetry Transport)**는 IoT 기기들이 서로 메시지를 주고받기 위한 **가볍고 효율적인** 통신 프로토콜입니다.

**왜 MQTT를 사용할까?**

- ✅ 적은 데이터 사용 (IoT 기기에 적합)
- ✅ 불안정한 네트워크에서도 동작
- ✅ 여러 기기가 동시에 통신 가능
- ✅ 배터리 효율적

---

## 🏗️ MQTT의 기본 구조

### Publish / Subscribe 모델

MQTT는 **중앙 서버(브로커)**를 중심으로 동작합니다.

```
┌─────────────┐
│  헥사보드 A  │ ──── Publish ───→ ┌─────────────┐
└─────────────┘                    │             │
                                   │  MQTT       │
┌─────────────┐                    │  Broker     │
│  헥사보드 B  │ ←─── Subscribe ── │  (중개자)   │
└─────────────┘                    │             │
                                   └─────────────┘
┌─────────────┐
│  Python     │ ←─── Subscribe ──
│  AI Server  │ ──── Publish ───→
└─────────────┘
```

### 주요 개념

#### 1. **Broker (브로커)**

- 모든 메시지를 중개하는 서버
- 예: HiveMQ Cloud, Mosquitto

#### 2. **Publisher (발행자)**

- 데이터를 보내는 기기
- 예: 센서 데이터를 보내는 헥사보드

#### 3. **Subscriber (구독자)**

- 데이터를 받는 기기
- 예: 센서 데이터를 분석하는 Python 서버

#### 4. **Topic (토픽)**

- 메시지의 주소 (카테고리)
- 예: `hexaboard/sensor/temperature`

---

## 🏷️ Topic의 개념

### Topic은 메시지의 주소입니다

Topic은 **슬래시(`/`)**로 구분된 계층 구조를 가집니다:

```
hexaboard/sensor/temperature
hexaboard/sensor/humidity
hexaboard/control/led
hexaboard/control/buzzer
```

**Topic 구조 예시**:

```
<디바이스 이름> / <카테고리> / <세부 항목>
```

### Topic 설계 예제

**센서 데이터**:

```
hexaboard/A/sensor/temp     → 헥사보드 A의 온도
hexaboard/A/sensor/humid    → 헥사보드 A의 습도
hexaboard/B/sensor/light    → 헥사보드 B의 조도
```

**제어 명령**:

```
hexaboard/A/control/led     → 헥사보드 A의 LED 제어
hexaboard/B/control/mode    → 헥사보드 B의 모드 변경
```

---

## 💬 Message의 개념

### Message는 실제 데이터입니다

Message는 Topic으로 전송되는 **실제 내용**입니다.

**예시 1: 센서 데이터 (JSON 형식)**

```json
{
  "temperature": 25.3,
  "humidity": 60,
  "timestamp": "2025-11-25T10:30:00"
}
```

**예시 2: 제어 명령 (JSON 형식)**

```json
{
  "action": "led_on",
  "color": [255, 0, 0],
  "brightness": 50
}
```

**예시 3: 단순 텍스트**

```
25.3
```

---

## 🔄 MQTT 통신 흐름

### 실제 동작 예시

**시나리오**: 헥사보드가 온도를 전송하고, Python 서버가 받아서 처리

#### Step 1: 구독자 등록

```
Python 서버 → Broker: "hexaboard/sensor/temp" 구독 신청
```

#### Step 2: 발행

```
헥사보드 → Broker: Topic "hexaboard/sensor/temp"로 "25.3" 전송
```

#### Step 3: 배포

```
Broker → Python 서버: "25.3" 전달
```

**흐름도**:

```
┌─────────────┐
│  헥사보드    │
│  (Publisher) │
└──────┬──────┘
       │
       │ ① Publish
       │ Topic: hexaboard/sensor/temp
       │ Message: "25.3"
       ↓
┌─────────────┐
│   Broker    │
│  (HiveMQ)   │
└──────┬──────┘
       │
       │ ② Deliver
       │ "25.3"
       ↓
┌─────────────┐
│  Python     │
│  (Subscriber)│
└─────────────┘
```

---

## 📊 MQTT의 장점

### HTTP vs MQTT

| 특징          | HTTP                | MQTT                   |
| ------------- | ------------------- | ---------------------- |
| **연결 방식** | 요청-응답 (1:1)     | 발행-구독 (1:N)        |
| **데이터량**  | 헤더가 큼           | 매우 가벼움 (2바이트~) |
| **실시간성**  | 폴링 필요           | 실시간 푸시            |
| **배터리**    | 전력 소모 많음      | 전력 효율적            |
| **사용 사례** | 웹 사이트, API 호출 | IoT 센서, 실시간 통신  |

### MQTT가 유리한 경우

- ✅ 여러 기기가 동시에 데이터를 주고받을 때
- ✅ 실시간으로 데이터를 전송해야 할 때
- ✅ 네트워크가 불안정할 때
- ✅ 배터리 기기를 사용할 때

---

## 🌐 MQTT Broker의 역할

### Broker는 우체국입니다

**Broker의 주요 역할**:

1. **메시지 중개**: Publisher에게서 받은 메시지를 Subscriber에게 전달
2. **Topic 관리**: 어떤 기기가 어떤 Topic을 구독하는지 관리
3. **연결 관리**: 기기들의 연결 상태 유지

**Broker 종류**:

- **HiveMQ Cloud**: 클라우드 기반 (무료 플랜 제공)
- **Mosquitto**: 로컬 서버 (직접 설치)

---

## 🔐 MQTT의 보안

### QoS (Quality of Service)

MQTT는 3가지 전송 품질 레벨을 제공합니다:

| QoS | 의미                      | 사용 예시              |
| --- | ------------------------- | ---------------------- |
| 0   | 최대 1번 전송 (손실 가능) | 실시간 센서 데이터     |
| 1   | 최소 1번 전송 (중복 가능) | 일반적인 센서 데이터   |
| 2   | 정확히 1번 전송           | 제어 명령, 결제 데이터 |

**우리 프로젝트에서는 QoS 1을 주로 사용합니다.**

### TLS 암호화

HiveMQ Cloud는 TLS를 사용해 데이터를 암호화합니다:

- 데이터가 네트워크에서 노출되지 않음
- 안전한 통신 보장

---

## 🎯 헥사보드 AI 센서랩에서의 MQTT 활용

### 우리 프로젝트의 MQTT 구조

```
┌─────────────────┐
│   헥사보드 A     │ ← Publish: 센서 데이터
└────────┬────────┘   Subscribe: 제어 명령
         │
         │         ┌─────────────────┐
         ├────────→│   MQTT Broker   │
         │         │   (HiveMQ)      │
         │         └────────┬────────┘
         │                  │
┌────────┴────────┐        │
│  Python AI      │ ← Subscribe: 센서 데이터
│  Server         │   Publish: 제어 명령
└─────────────────┘        │
                           │
                   ┌───────┴────────┐
                   │  Web Dashboard │ ← Subscribe: 모든 데이터
                   │  (브라우저)     │   Publish: 사용자 명령
                   └────────────────┘
```

### Topic 설계

**센서 데이터 전송**:

```
hexaboard/A/sensor/data → {"temp": 25, "humid": 60, "light": 800}
```

**AI 제어 명령**:

```
hexaboard/A/control/led → {"color": [255, 0, 0], "mode": "on"}
```

---

## 📝 핵심 정리

### 꼭 기억하세요!

1. **MQTT**: IoT를 위한 가벼운 메시징 프로토콜
2. **Broker**: 모든 메시지를 중개하는 서버
3. **Topic**: 메시지의 주소 (예: `hexaboard/sensor/temp`)
4. **Publish**: 데이터 보내기
5. **Subscribe**: 데이터 받기
6. **장점**: 가볍고, 실시간이며, 여러 기기 동시 통신 가능

---

## ❓ 자주 묻는 질문

### Q1. MQTT와 HTTP의 차이는?

**A**: HTTP는 요청-응답 방식(1:1), MQTT는 발행-구독 방식(1:N). MQTT가 IoT에 더 적합합니다.

### Q2. Broker가 없으면 통신이 안 되나요?

**A**: 네, MQTT는 반드시 Broker를 통해야 합니다. Broker가 모든 메시지를 중개합니다.

### Q3. Topic을 어떻게 설계해야 하나요?

**A**: 계층 구조로 설계합니다. `<디바이스>/<카테고리>/<항목>` 형식을 권장합니다.

---

## 🚀 다음 단계

이제 MQTT의 기본 개념을 이해했습니다!

**다음 챕터에서는**:

- HiveMQ Cloud MQTT Broker 설정하기
- 무료 계정 생성 및 설정
- 연결 정보 확인

---

## 💡 더 알아보기

### MQTT 테스트 도구

**온라인 MQTT 클라이언트**:

- MQTT.fx
- MQTTX
- HiveMQ WebSocket Client

다음 챕터에서 실제로 설정하고 테스트해봅시다!

---

**🎉 Chapter 11 완료!**  
이제 MQTT의 기본 개념과 Pub/Sub 구조를 이해했습니다.

# Chapter 12. MQTT 브로커 준비 (HiveMQ Cloud)

> **PART 4**: MQTT를 통한 센서 데이터 전송

---

## 📚 이 챕터에서 배울 내용

- [ ] HiveMQ Cloud 계정을 생성할 수 있다
- [ ] 무료 MQTT Broker를 설정할 수 있다
- [ ] Broker 연결 정보를 확인할 수 있다

**예상 소요 시간**: 30분

---

## 🎯 학습 목표

### 핵심 개념

- **HiveMQ Cloud**: 클라우드 기반 MQTT 브로커
- **Broker 설정**: 연결 정보 및 인증
- **테스트 연결**: 온라인 도구로 확인

---

## 📖 HiveMQ Cloud란?

### 클라우드 MQTT 브로커

**HiveMQ Cloud**는 클라우드에서 제공하는 MQTT Broker 서비스입니다.

**장점**:

- ✅ 무료 플랜 제공 (평생 무료)
- ✅ 설치 없이 바로 사용 가능
- ✅ TLS 암호화 기본 제공
- ✅ 안정적인 클라우드 인프라
- ✅ 웹 기반 관리 콘솔

**무료 플랜 제공 사항**:

- 최대 100개 연결
- 월 10GB 데이터 전송
- 교육 및 프로토타입에 충분

---

## 🔧 실습 1: HiveMQ Cloud 계정 생성

### Step 1: 회원가입

1. **HiveMQ Cloud 웹사이트 접속**

   - URL: https://www.hivemq.com/mqtt-cloud-broker/

2. **"Sign Up" 버튼 클릭**

   - 우측 상단의 "Sign Up" 또는 "Start Free" 클릭

3. **계정 정보 입력**

   ```
   - Email: 본인 이메일
   - Password: 안전한 비밀번호
   - First Name: 이름
   - Last Name: 성
   ```

4. **이메일 인증**
   - 가입 후 이메일 확인
   - 인증 링크 클릭

---

## 🔧 실습 2: Cluster 생성

### Step 1: 클러스터 만들기

**로그인 후**:

1. **"Create new cluster" 버튼 클릭**

2. **Serverless 플랜 선택**

   - "Serverless" 탭 선택
   - 무료 플랜 확인

3. **클러스터 설정**

   ```
   - Cluster Name: hexaboard-lab (원하는 이름)
   - Cloud Provider: AWS
   - Region: ap-northeast-2 (서울) 또는 가까운 지역
   ```

4. **"Create" 버튼 클릭**
   - 클러스터 생성 시작 (약 1-2분 소요)

### Step 2: 클러스터 상태 확인

생성이 완료되면:

- Status: **Running** ✅
- 초록색 표시

---

## 🔧 실습 3: 접속 정보 설정

### Step 1: Credentials 생성

**클러스터 상세 페이지에서**:

1. **"Access Management" 탭 클릭**

2. **"Add new credential" 버튼 클릭**

3. **사용자 정보 입력**

   ```
   - Username: hexaboard
   - Password: YOUR_SECURE_PASSWORD (직접 생성)
   ```

4. **권한 설정**

   ```
   - Topic: # (모든 토픽)
   - Permission: Publish and Subscribe
   ```

5. **"Add" 버튼 클릭**

⚠️ **중요**: 비밀번호를 안전하게 저장하세요! 나중에 다시 볼 수 없습니다.

### Step 2: 연결 정보 확인

**"Overview" 탭에서 확인**:

```
┌─────────────────────────────────────────┐
│  Connection Settings                    │
├─────────────────────────────────────────┤
│  Host: abc123.s1.eu.hivemq.cloud        │
│  Port: 8883 (TLS)                       │
│  Username: hexaboard                    │
│  Password: YOUR_PASSWORD                │
└─────────────────────────────────────────┘
```

**필요한 정보**:

- **Host**: Broker 주소 (예: `abc123.s1.eu.hivemq.cloud`)
- **Port**: `8883` (TLS 암호화)
- **Username**: 위에서 생성한 사용자 이름
- **Password**: 위에서 생성한 비밀번호

---

## 📝 연결 정보 기록하기

### 정보 저장 방법

**메모장 또는 텍스트 파일에 저장**:

```python
# mqtt_config.txt

MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USERNAME = "hexaboard"
MQTT_PASSWORD = "your_password_here"
```

⚠️ **주의**:

- 이 정보를 안전하게 보관하세요
- GitHub 등 공개 저장소에 올리지 마세요
- 나중에 헥사보드와 Python 코드에 사용됩니다

---

## 🔧 실습 4: 온라인 테스트

### HiveMQ WebSocket Client로 테스트

**목적**: Broker가 제대로 동작하는지 확인

### Step 1: WebSocket Client 접속

1. **URL 접속**

   - http://www.hivemq.com/demos/websocket-client/

2. **연결 설정 입력**

   ```
   Host: abc123.s1.eu.hivemq.cloud (본인의 Host)
   Port: 8884 (WebSocket TLS)
   Username: hexaboard
   Password: YOUR_PASSWORD
   ```

3. **"Connect" 버튼 클릭**
   - 연결 성공: 초록색 "Connected" 표시

### Step 2: Subscribe 테스트

1. **"Subscriptions" 섹션에서**

   ```
   Topic: hexaboard/test
   QoS: 0
   ```

2. **"Subscribe" 버튼 클릭**

### Step 3: Publish 테스트

1. **"Publish" 섹션에서**

   ```
   Topic: hexaboard/test
   Message: Hello MQTT!
   QoS: 0
   ```

2. **"Publish" 버튼 클릭**

### Step 4: 메시지 확인

**"Messages" 섹션에서**:

```
hexaboard/test: Hello MQTT!
```

메시지가 표시되면 **성공**! ✅

---

## 📊 HiveMQ Cloud 대시보드

### 모니터링 기능

**HiveMQ Cloud 콘솔에서 확인 가능**:

1. **Connected Clients**

   - 현재 연결된 기기 수
   - 연결/해제 이벤트

2. **Message Rate**

   - 초당 메시지 전송 수
   - Publish/Subscribe 통계

3. **Data Transfer**
   - 데이터 사용량 (월별)
   - 무료 플랜 한도 확인

---

## 🔐 보안 설정

### TLS 인증서

HiveMQ Cloud는 **자동으로 TLS를 활성화**합니다:

- 포트 `8883`: MQTT over TLS
- 포트 `8884`: WebSocket over TLS

**별도 설정 불필요**:

- 인증서는 자동으로 제공됨
- 안전한 연결 보장

### 권한 관리

**Credentials에서 관리**:

- 사용자별 접근 권한 설정
- Topic 단위로 Publish/Subscribe 제한 가능

**예시**:

```
Username: sensor_only
Topic: hexaboard/sensor/# (센서 데이터만)
Permission: Publish only
```

---

## 🛠️ 문제 해결

### 연결이 안 될 때

#### 1. 인증 정보 확인

```
❌ 잘못된 Username 또는 Password
✅ HiveMQ 콘솔에서 Credentials 다시 확인
```

#### 2. Host 주소 확인

```
❌ abc123.s1.eu.hivemq.cloud (예시)
✅ 본인의 실제 Host 주소 사용
```

#### 3. Port 번호 확인

```
- MQTT: 8883
- WebSocket: 8884
```

#### 4. 방화벽 확인

```
- 포트 8883, 8884가 열려 있는지 확인
- 공용 Wi-Fi는 차단될 수 있음
```

### 무료 플랜 제한

**제한 사항**:

- 최대 100개 연결
- 월 10GB 데이터

**초과 시**:

- 연결이 거부될 수 있음
- 대시보드에서 사용량 확인

---

## 🚀 다음 챕터 준비

### 저장해야 할 정보

다음 챕터에서 사용할 정보를 준비하세요:

```python
# 헥사보드 코드에 사용
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"  # 본인의 Host
MQTT_PORT = 8883
MQTT_USER = "hexaboard"                     # 본인의 Username
MQTT_PASSWORD = "your_password"             # 본인의 Password

# Topic 설계
TOPIC_SENSOR = "hexaboard/A/sensor/data"
TOPIC_CONTROL = "hexaboard/A/control/led"
```

---

## 📝 핵심 정리

### 꼭 기억하세요!

1. **HiveMQ Cloud**: 무료 클라우드 MQTT Broker
2. **Cluster**: MQTT Broker 인스턴스
3. **Credentials**: 연결을 위한 Username/Password
4. **연결 정보**: Host, Port, Username, Password
5. **테스트**: WebSocket Client로 확인 가능

---

## ❓ 자주 묻는 질문

### Q1. 무료 플랜으로 충분한가요?

**A**: 네! 교육 및 개인 프로젝트에는 충분합니다. 100개 연결, 월 10GB 제공.

### Q2. TLS 인증서를 따로 설정해야 하나요?

**A**: 아니요. HiveMQ Cloud는 자동으로 TLS를 제공합니다.

### Q3. 로컬 Mosquitto와 어떻게 다른가요?

**A**: HiveMQ는 클라우드 기반이라 어디서나 접속 가능. Mosquitto는 로컬 네트워크에서만 사용.

### Q4. 여러 개의 Cluster를 만들 수 있나요?

**A**: 무료 플랜은 1개의 Cluster만 제공. 유료 플랜에서 추가 가능.

---

## 🚀 다음 단계

Broker 설정이 완료되었습니다!

**다음 챕터에서는**:

- 헥사보드에서 MQTT 라이브러리 사용하기
- Publish로 센서 데이터 전송
- Subscribe로 제어 명령 받기

---

**🎉 Chapter 12 완료!**  
이제 HiveMQ Cloud Broker를 사용할 준비가 되었습니다!

# Chapter 13. 헥사보드에서 MQTT Publish / Subscribe 구현

> **PART 4**: MQTT를 통한 센서 데이터 전송

---

## 📚 이 챕터에서 배울 내용

- [ ] 헥사보드에서 Wi-Fi에 연결할 수 있다
- [ ] MQTT Broker에 연결할 수 있다
- [ ] 센서 데이터를 Publish할 수 있다
- [ ] 제어 명령을 Subscribe할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **Wi-Fi 연결**: 헥사보드를 네트워크에 연결
- **MQTT Publish**: 센서 데이터 전송
- **MQTT Subscribe**: 제어 명령 수신

---

## 🔧 실습 준비

### 필요한 것

- [x] 헥사보드 × 1
- [x] USB 케이블 × 1
- [x] Wi-Fi 네트워크 (2.4GHz)
- [x] HiveMQ Cloud 연결 정보 (Chapter 12에서 준비)

> **💡 TIP**: ESP32는 **2.4GHz Wi-Fi만** 지원합니다. 5GHz는 사용할 수 없습니다!

### 연결 정보 준비

Chapter 12에서 저장한 정보를 준비하세요:

```python
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"  # 본인의 주소
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
```

---

## 💻 실습 1: Wi-Fi 연결

### Wi-Fi 기본 연결

**코드**:

```python
# 파일명: ch13_wifi_connect.py
# Wi-Fi 연결 테스트

import network
import time

# Wi-Fi 설정
WIFI_SSID = "Your_WiFi_Name"      # 본인의 Wi-Fi 이름
WIFI_PASSWORD = "Your_Password"   # 본인의 Wi-Fi 비밀번호

def connect_wifi():
    """Wi-Fi 연결"""
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)

    if not wlan.isconnected():
        print("Wi-Fi 연결 중...")
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)

        # 연결 대기 (최대 10초)
        timeout = 10
        while not wlan.isconnected() and timeout > 0:
            print(".", end="")
            time.sleep(1)
            timeout -= 1

        print()

    if wlan.isconnected():
        print("✅ Wi-Fi 연결 성공!")
        print(f"IP 주소: {wlan.ifconfig()[0]}")
        return True
    else:
        print("❌ Wi-Fi 연결 실패")
        return False

# 테스트
connect_wifi()
```

**동작**:

1. Wi-Fi 모드 활성화
2. SSID와 Password로 연결
3. IP 주소 확인

**출력 예시**:

```
Wi-Fi 연결 중...
..........
✅ Wi-Fi 연결 성공!
IP 주소: 192.168.0.101
```

---

## 💻 실습 2: MQTT 기본 연결

### Broker에 연결하기

**코드**:

```python
# 파일명: ch13_mqtt_connect.py
# MQTT 연결 테스트

import network
from umqtt.simple import MQTTClient
import time

# Wi-Fi 설정
WIFI_SSID = "Your_WiFi_Name"
WIFI_PASSWORD = "Your_Password"

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"  # 본인의 Broker
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
MQTT_CLIENT_ID = "hexaboard_A"

def connect_wifi():
    """Wi-Fi 연결"""
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)

    if not wlan.isconnected():
        print("Wi-Fi 연결 중...")
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)

        timeout = 10
        while not wlan.isconnected() and timeout > 0:
            time.sleep(1)
            timeout -= 1

    if wlan.isconnected():
        print("✅ Wi-Fi 연결 성공!")
        return True
    return False

def connect_mqtt():
    """MQTT Broker 연결"""
    try:
        client = MQTTClient(
            client_id=MQTT_CLIENT_ID,
            server=MQTT_BROKER,
            port=MQTT_PORT,
            user=MQTT_USER,
            password=MQTT_PASSWORD,
            ssl=True  # TLS 사용
        )
        client.connect()
        print("✅ MQTT 연결 성공!")
        return client
    except Exception as e:
        print(f"❌ MQTT 연결 실패: {e}")
        return None

# 테스트
if connect_wifi():
    client = connect_mqtt()
    if client:
        client.disconnect()
        print("연결 테스트 완료!")
```

**핵심 코드**:

```python
client = MQTTClient(
    client_id="hexaboard_A",  # 고유한 ID
    server=MQTT_BROKER,       # Broker 주소
    port=8883,                # TLS 포트
    user=MQTT_USER,           # Username
    password=MQTT_PASSWORD,   # Password
    ssl=True                  # TLS 활성화
)
client.connect()              # 연결
```

---

## 💻 실습 3: Publish (데이터 전송)

### 센서 데이터 보내기

**코드**:

```python
# 파일명: ch13_mqtt_publish.py
# MQTT Publish 예제

import network
from umqtt.simple import MQTTClient
import time
import ujson

# Wi-Fi 설정
WIFI_SSID = "Your_WiFi_Name"
WIFI_PASSWORD = "Your_Password"

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
MQTT_CLIENT_ID = "hexaboard_A"

# Topic 설정
TOPIC_SENSOR = "hexaboard/A/sensor/data"

def connect_wifi():
    """Wi-Fi 연결"""
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)

    if not wlan.isconnected():
        print("Wi-Fi 연결 중...")
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)

        timeout = 10
        while not wlan.isconnected() and timeout > 0:
            time.sleep(1)
            timeout -= 1

    return wlan.isconnected()

def connect_mqtt():
    """MQTT 연결"""
    try:
        client = MQTTClient(
            client_id=MQTT_CLIENT_ID,
            server=MQTT_BROKER,
            port=MQTT_PORT,
            user=MQTT_USER,
            password=MQTT_PASSWORD,
            ssl=True
        )
        client.connect()
        print("✅ MQTT 연결 성공!")
        return client
    except Exception as e:
        print(f"❌ MQTT 연결 실패: {e}")
        return None

def publish_sensor_data(client, temp, humid, light):
    """센서 데이터 전송"""
    data = {
        "temperature": temp,
        "humidity": humid,
        "light": light,
        "timestamp": time.time()
    }

    # JSON으로 변환
    message = ujson.dumps(data)

    # Publish
    client.publish(TOPIC_SENSOR, message)
    print(f"📤 전송: {message}")

# 메인 실행
if connect_wifi():
    client = connect_mqtt()

    if client:
        try:
            # 5번 전송 테스트
            for i in range(5):
                temp = 20 + i  # 가상 센서 데이터
                humid = 50 + i
                light = 500 + i * 100

                publish_sensor_data(client, temp, humid, light)
                time.sleep(2)  # 2초 대기

            print("전송 완료!")

        finally:
            client.disconnect()
```

**동작**:

1. Wi-Fi와 MQTT Broker 연결
2. 센서 데이터를 JSON으로 변환
3. Topic으로 Publish
4. 2초마다 반복

**출력 예시**:

```
✅ MQTT 연결 성공!
📤 전송: {"temperature": 20, "humidity": 50, "light": 500, "timestamp": 1234567890}
📤 전송: {"temperature": 21, "humidity": 51, "light": 600, "timestamp": 1234567892}
...
전송 완료!
```

---

## 💻 실습 4: Subscribe (명령 수신)

### LED 제어 명령 받기

**코드**:

```python
# 파일명: ch13_mqtt_subscribe.py
# MQTT Subscribe 예제

import network
from umqtt.simple import MQTTClient
from machine import Pin
import neopixel
import time
import ujson

# Wi-Fi 설정
WIFI_SSID = "Your_WiFi_Name"
WIFI_PASSWORD = "Your_Password"

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
MQTT_CLIENT_ID = "hexaboard_A"

# Topic 설정
TOPIC_CONTROL = "hexaboard/A/control/led"

# NeoPixel 설정
np = neopixel.NeoPixel(Pin(23), 25)

def connect_wifi():
    """Wi-Fi 연결"""
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)

    if not wlan.isconnected():
        print("Wi-Fi 연결 중...")
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)

        timeout = 10
        while not wlan.isconnected() and timeout > 0:
            time.sleep(1)
            timeout -= 1

    return wlan.isconnected()

def on_message(topic, msg):
    """메시지 수신 콜백"""
    print(f"📥 수신: {msg}")

    try:
        # JSON 파싱
        data = ujson.loads(msg)

        action = data.get("action")

        if action == "led_on":
            # LED 켜기
            color = data.get("color", [255, 255, 255])
            for i in range(25):
                np[i] = tuple(color)
            np.write()
            print("💡 LED ON")

        elif action == "led_off":
            # LED 끄기
            for i in range(25):
                np[i] = (0, 0, 0)
            np.write()
            print("💡 LED OFF")

        elif action == "led_color":
            # 색상 변경
            color = data.get("color", [255, 0, 0])
            for i in range(25):
                np[i] = tuple(color)
            np.write()
            print(f"🎨 색상 변경: {color}")

    except Exception as e:
        print(f"❌ 처리 오류: {e}")

def connect_mqtt():
    """MQTT 연결 및 Subscribe"""
    try:
        client = MQTTClient(
            client_id=MQTT_CLIENT_ID,
            server=MQTT_BROKER,
            port=MQTT_PORT,
            user=MQTT_USER,
            password=MQTT_PASSWORD,
            ssl=True
        )

        # 메시지 콜백 설정
        client.set_callback(on_message)

        client.connect()
        print("✅ MQTT 연결 성공!")

        # Topic 구독
        client.subscribe(TOPIC_CONTROL)
        print(f"📬 구독 시작: {TOPIC_CONTROL}")

        return client

    except Exception as e:
        print(f"❌ MQTT 연결 실패: {e}")
        return None

# 메인 실행
if connect_wifi():
    client = connect_mqtt()

    if client:
        print("명령 대기 중... (Ctrl+C로 종료)")

        try:
            while True:
                client.check_msg()  # 메시지 확인
                time.sleep(0.1)

        except KeyboardInterrupt:
            print("\n종료")

        finally:
            client.disconnect()
```

**핵심 코드**:

```python
# 콜백 함수 정의
def on_message(topic, msg):
    # 메시지 처리
    pass

# 콜백 설정
client.set_callback(on_message)

# Subscribe
client.subscribe("hexaboard/A/control/led")

# 메시지 확인 (반복)
while True:
    client.check_msg()
```

**테스트 방법**:

HiveMQ WebSocket Client에서 다음 메시지 전송:

**LED 켜기**:

```json
Topic: hexaboard/A/control/led
Message: {"action": "led_on", "color": [255, 0, 0]}
```

**LED 끄기**:

```json
Topic: hexaboard/A/control/led
Message: {"action": "led_off"}
```

**색상 변경**:

```json
Topic: hexaboard/A/control/led
Message: {"action": "led_color", "color": [0, 255, 0]}
```

---

## 💻 실습 5: Publish + Subscribe 통합

### 센서 데이터 전송 + 제어 명령 수신

**코드**:

```python
# 파일명: ch13_mqtt_full.py
# MQTT Publish + Subscribe 통합

import network
from umqtt.simple import MQTTClient
from machine import Pin
import neopixel
import dht
import time
import ujson

# Wi-Fi 설정
WIFI_SSID = "Your_WiFi_Name"
WIFI_PASSWORD = "Your_Password"

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
MQTT_CLIENT_ID = "hexaboard_A"

# Topic 설정
TOPIC_SENSOR = "hexaboard/A/sensor/data"
TOPIC_CONTROL = "hexaboard/A/control/led"

# 하드웨어 설정
np = neopixel.NeoPixel(Pin(23), 25)
sensor = dht.DHT11(Pin(32))

def connect_wifi():
    """Wi-Fi 연결"""
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)

    if not wlan.isconnected():
        print("Wi-Fi 연결 중...")
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)

        timeout = 10
        while not wlan.isconnected() and timeout > 0:
            time.sleep(1)
            timeout -= 1

    if wlan.isconnected():
        print("✅ Wi-Fi 연결 성공!")
        return True
    return False

def on_message(topic, msg):
    """제어 명령 수신"""
    print(f"📥 수신: {msg}")

    try:
        data = ujson.loads(msg)
        action = data.get("action")

        if action == "led_on":
            color = data.get("color", [255, 255, 255])
            for i in range(25):
                np[i] = tuple(color)
            np.write()
            print("💡 LED ON")

        elif action == "led_off":
            for i in range(25):
                np[i] = (0, 0, 0)
            np.write()
            print("💡 LED OFF")

    except Exception as e:
        print(f"❌ 처리 오류: {e}")

def connect_mqtt():
    """MQTT 연결"""
    try:
        client = MQTTClient(
            client_id=MQTT_CLIENT_ID,
            server=MQTT_BROKER,
            port=MQTT_PORT,
            user=MQTT_USER,
            password=MQTT_PASSWORD,
            ssl=True
        )

        client.set_callback(on_message)
        client.connect()
        client.subscribe(TOPIC_CONTROL)

        print("✅ MQTT 연결 성공!")
        print(f"📬 구독: {TOPIC_CONTROL}")

        return client

    except Exception as e:
        print(f"❌ MQTT 연결 실패: {e}")
        return None

def publish_sensor_data(client):
    """센서 데이터 전송"""
    try:
        sensor.measure()
        temp = sensor.temperature()
        humid = sensor.humidity()

        data = {
            "temperature": temp,
            "humidity": humid,
            "timestamp": time.time()
        }

        message = ujson.dumps(data)
        client.publish(TOPIC_SENSOR, message)
        print(f"📤 전송: 온도 {temp}°C, 습도 {humid}%")

    except Exception as e:
        print(f"❌ 센서 읽기 실패: {e}")

# 메인 실행
if connect_wifi():
    client = connect_mqtt()

    if client:
        print("시스템 실행 중... (Ctrl+C로 종료)")

        last_publish = 0

        try:
            while True:
                # 제어 명령 확인
                client.check_msg()

                # 5초마다 센서 데이터 전송
                if time.time() - last_publish > 5:
                    publish_sensor_data(client)
                    last_publish = time.time()

                time.sleep(0.1)

        except KeyboardInterrupt:
            print("\n종료")

        finally:
            client.disconnect()
```

**동작**:

1. Wi-Fi 연결
2. MQTT Broker 연결
3. 제어 Topic 구독
4. 5초마다 센서 데이터 Publish
5. 제어 명령 수신 시 LED 제어

---

## 🛠️ 문제 해결

### Wi-Fi 연결 실패

```python
❌ Wi-Fi 연결 실패
```

**원인**:

- SSID 또는 Password 오류
- 5GHz Wi-Fi 사용 (ESP32는 2.4GHz만 지원)
- Wi-Fi 신호 약함

**해결**:

```python
# SSID와 Password 재확인
WIFI_SSID = "정확한_이름"  # 공백, 대소문자 주의
WIFI_PASSWORD = "정확한_비밀번호"

# 2.4GHz 네트워크 사용
```

### MQTT 연결 실패

```python
❌ MQTT 연결 실패: OSError: -1
```

**원인**:

- Broker 주소 오류
- Username/Password 오류
- 방화벽/네트워크 차단

**해결**:

```python
# HiveMQ 콘솔에서 연결 정보 재확인
MQTT_BROKER = "본인의_실제_주소"
MQTT_USER = "정확한_Username"
MQTT_PASSWORD = "정확한_Password"

# TLS 포트 확인
MQTT_PORT = 8883  # 8883이어야 함
```

### 메시지가 안 보일 때

```
메시지 전송했지만 아무 반응 없음
```

**원인**:

- Topic 이름 불일치
- Subscribe 안 됨
- JSON 형식 오류

**해결**:

```python
# Topic 일치 확인
Publisher: "hexaboard/A/control/led"
Subscriber: "hexaboard/A/control/led"  # 정확히 동일해야 함

# JSON 형식 확인
{"action": "led_on", "color": [255, 0, 0]}  # 올바른 형식
```

---

## 🚀 도전 과제

### 과제 1: 버튼으로 메시지 전송

버튼 A를 누르면 "Button A Pressed" 메시지를 전송하세요.

**힌트**:

```python
TOPIC_BUTTON = "hexaboard/A/button"

if button_a.value() == 1:
    client.publish(TOPIC_BUTTON, "Button A Pressed")
```

### 과제 2: 온도에 따라 LED 색상 변경

온도가 25°C 이상이면 빨간색, 미만이면 파란색 LED를 켜는 메시지를 받으세요.

---

## 📝 핵심 정리

### 꼭 기억하세요!

1. **Wi-Fi 연결**: `network.WLAN().connect(ssid, password)`
2. **MQTT 연결**: `MQTTClient()`로 Broker 연결
3. **Publish**: `client.publish(topic, message)`로 전송
4. **Subscribe**: `client.subscribe(topic)`로 구독
5. **메시지 수신**: `client.check_msg()`로 확인

---

## ❓ 자주 묻는 질문

### Q1. ESP32가 5GHz Wi-Fi를 지원하나요?

**A**: 아니요. ESP32는 **2.4GHz Wi-Fi만** 지원합니다.

### Q2. TLS 인증서를 따로 설정해야 하나요?

**A**: HiveMQ Cloud는 자동으로 TLS 인증서를 제공하므로 `ssl=True`만 설정하면 됩니다.

### Q3. 메시지가 전송되는지 어떻게 확인하나요?

**A**: HiveMQ WebSocket Client나 대시보드에서 확인할 수 있습니다.

---

## 🚀 다음 단계

단일 헥사보드로 MQTT 통신에 성공했습니다!

**다음 챕터에서는**:

- 여러 개의 헥사보드를 연결
- 보드 간 통신
- 멀티 디바이스 제어

---

**🎉 Chapter 13 완료!**  
이제 헥사보드가 MQTT로 데이터를 주고받을 수 있습니다!

# Chapter 14. 멀티 헥사보드 확장 실험

> **PART 4**: MQTT를 통한 센서 데이터 전송

---

## 📚 이 챕터에서 배울 내용

- [ ] 여러 헥사보드를 동시에 연결할 수 있다
- [ ] 보드 간 통신을 구현할 수 있다
- [ ] Topic으로 보드를 구분할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **멀티 디바이스**: 여러 IoT 기기 동시 연결
- **Client ID**: 각 기기의 고유 식별자
- **Topic 설계**: 보드별 데이터 분리

---

## 📖 왜 멀티 보드가 필요한가?

### 실제 IoT 시스템

실제 IoT 환경에서는 **여러 센서와 디바이스**가 동시에 동작합니다.

**예시**:

- 집의 각 방마다 온도 센서
- 여러 층의 조명 제어
- 다수의 스마트 기기 모니터링

**MQTT의 장점**:

- ✅ 수십~수백 개의 기기 동시 연결
- ✅ Broker 하나로 모든 기기 관리
- ✅ 기기 간 직접 통신 가능

---

## 🏗️ 멀티 보드 시스템 구조

### 시스템 아키텍처

```
┌─────────────┐
│ 헥사보드 A   │ ─┐
└─────────────┘  │
                 │
┌─────────────┐  │
│ 헥사보드 B   │ ─┤─→ ┌─────────────┐
└─────────────┘  │   │    MQTT     │
                 │   │   Broker    │
┌─────────────┐  │   │  (HiveMQ)   │
│ 헥사보드 C   │ ─┘   └─────────────┘
└─────────────┘            │
                           │
                   ┌───────┴────────┐
                   │   Python AI    │
                   │     Server     │
                   └────────────────┘
```

---

## 🏷️ Topic 설계 전략

### 보드별 Topic 구조

각 헥사보드는 **고유한 Topic**을 가져야 합니다.

**권장 구조**:

```
hexaboard/<보드ID>/<카테고리>/<항목>
```

**예시**:

**헥사보드 A**:

```
hexaboard/A/sensor/data     → 센서 데이터
hexaboard/A/control/led     → LED 제어
hexaboard/A/status          → 상태 정보
```

**헥사보드 B**:

```
hexaboard/B/sensor/data
hexaboard/B/control/led
hexaboard/B/status
```

**헥사보드 C**:

```
hexaboard/C/sensor/data
hexaboard/C/control/led
hexaboard/C/status
```

---

## 🔧 실습 준비

### 필요한 것

- [x] 헥사보드 × 2개 이상 (또는 1개로 시뮬레이션)
- [x] USB 케이블 × 2개
- [x] Wi-Fi 네트워크
- [x] HiveMQ Cloud 연결 정보

> **💡 TIP**: 헥사보드가 1개만 있다면 코드를 수정해가며 테스트할 수 있습니다!

---

## 💻 실습 1: 헥사보드 A (센서 전송)

### 보드 A 코드

**코드**:

```python
# 파일명: ch14_board_A.py
# 헥사보드 A - 센서 데이터 전송

import network
from umqtt.simple import MQTTClient
from machine import Pin
import dht
import time
import ujson

# Wi-Fi 설정
WIFI_SSID = "Your_WiFi_Name"
WIFI_PASSWORD = "Your_Password"

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
MQTT_CLIENT_ID = "hexaboard_A"  # 고유 ID

# Topic 설정 (보드 A)
TOPIC_SENSOR = "hexaboard/A/sensor/data"
TOPIC_STATUS = "hexaboard/A/status"

# 하드웨어
sensor = dht.DHT11(Pin(32))

def connect_wifi():
    """Wi-Fi 연결"""
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)

    if not wlan.isconnected():
        print("[A] Wi-Fi 연결 중...")
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)

        timeout = 10
        while not wlan.isconnected() and timeout > 0:
            time.sleep(1)
            timeout -= 1

    if wlan.isconnected():
        print("[A] ✅ Wi-Fi 연결 성공!")
        return True
    return False

def connect_mqtt():
    """MQTT 연결"""
    try:
        client = MQTTClient(
            client_id=MQTT_CLIENT_ID,
            server=MQTT_BROKER,
            port=MQTT_PORT,
            user=MQTT_USER,
            password=MQTT_PASSWORD,
            ssl=True
        )
        client.connect()

        # 연결 상태 전송
        client.publish(TOPIC_STATUS, "online")

        print("[A] ✅ MQTT 연결 성공!")
        return client

    except Exception as e:
        print(f"[A] ❌ MQTT 연결 실패: {e}")
        return None

def publish_sensor_data(client):
    """센서 데이터 전송"""
    try:
        sensor.measure()
        temp = sensor.temperature()
        humid = sensor.humidity()

        data = {
            "board": "A",
            "temperature": temp,
            "humidity": humid,
            "timestamp": time.time()
        }

        message = ujson.dumps(data)
        client.publish(TOPIC_SENSOR, message)
        print(f"[A] 📤 온도: {temp}°C, 습도: {humid}%")

    except Exception as e:
        print(f"[A] ❌ 센서 오류: {e}")

# 메인 실행
if connect_wifi():
    client = connect_mqtt()

    if client:
        print("[A] 센서 데이터 전송 시작...")

        try:
            while True:
                publish_sensor_data(client)
                time.sleep(5)  # 5초마다 전송

        except KeyboardInterrupt:
            print("\n[A] 종료")
            client.publish(TOPIC_STATUS, "offline")

        finally:
            client.disconnect()
```

**특징**:

- Client ID: `hexaboard_A`
- Topic: `hexaboard/A/...`
- 5초마다 센서 데이터 전송

---

## 💻 실습 2: 헥사보드 B (제어 수신)

### 보드 B 코드

**코드**:

```python
# 파일명: ch14_board_B.py
# 헥사보드 B - LED 제어 수신

import network
from umqtt.simple import MQTTClient
from machine import Pin
import neopixel
import time
import ujson

# Wi-Fi 설정
WIFI_SSID = "Your_WiFi_Name"
WIFI_PASSWORD = "Your_Password"

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
MQTT_CLIENT_ID = "hexaboard_B"  # 고유 ID

# Topic 설정 (보드 B)
TOPIC_CONTROL = "hexaboard/B/control/led"
TOPIC_STATUS = "hexaboard/B/status"

# 하드웨어
np = neopixel.NeoPixel(Pin(23), 25)

def connect_wifi():
    """Wi-Fi 연결"""
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)

    if not wlan.isconnected():
        print("[B] Wi-Fi 연결 중...")
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)

        timeout = 10
        while not wlan.isconnected() and timeout > 0:
            time.sleep(1)
            timeout -= 1

    if wlan.isconnected():
        print("[B] ✅ Wi-Fi 연결 성공!")
        return True
    return False

def on_message(topic, msg):
    """LED 제어 명령 수신"""
    print(f"[B] 📥 수신: {msg}")

    try:
        data = ujson.loads(msg)
        action = data.get("action")

        if action == "led_on":
            color = data.get("color", [255, 255, 255])
            for i in range(25):
                np[i] = tuple(color)
            np.write()
            print(f"[B] 💡 LED ON: {color}")

        elif action == "led_off":
            for i in range(25):
                np[i] = (0, 0, 0)
            np.write()
            print("[B] 💡 LED OFF")

    except Exception as e:
        print(f"[B] ❌ 처리 오류: {e}")

def connect_mqtt():
    """MQTT 연결 및 Subscribe"""
    try:
        client = MQTTClient(
            client_id=MQTT_CLIENT_ID,
            server=MQTT_BROKER,
            port=MQTT_PORT,
            user=MQTT_USER,
            password=MQTT_PASSWORD,
            ssl=True
        )

        client.set_callback(on_message)
        client.connect()
        client.subscribe(TOPIC_CONTROL)

        # 상태 전송
        client.publish(TOPIC_STATUS, "online")

        print("[B] ✅ MQTT 연결 성공!")
        print(f"[B] 📬 구독: {TOPIC_CONTROL}")
        return client

    except Exception as e:
        print(f"[B] ❌ MQTT 연결 실패: {e}")
        return None

# 메인 실행
if connect_wifi():
    client = connect_mqtt()

    if client:
        print("[B] 제어 명령 대기 중...")

        try:
            while True:
                client.check_msg()
                time.sleep(0.1)

        except KeyboardInterrupt:
            print("\n[B] 종료")
            client.publish(TOPIC_STATUS, "offline")

        finally:
            client.disconnect()
```

**특징**:

- Client ID: `hexaboard_B`
- Topic: `hexaboard/B/...`
- LED 제어 명령 수신

---

## 💻 실습 3: 보드 간 통신

### 보드 A → 보드 B 메시지 전송

**시나리오**: 보드 A가 버튼을 누르면 보드 B의 LED가 켜짐

**보드 A 코드 (일부)**:

```python
# 파일명: ch14_board_A_button.py
# 보드 A - 버튼으로 보드 B 제어

from machine import Pin

# 버튼 설정
button_a = Pin(35, Pin.IN, Pin.PULL_DOWN)

# Topic (보드 B 제어)
TOPIC_B_CONTROL = "hexaboard/B/control/led"

last_state = 0

while True:
    current_state = button_a.value()

    # 버튼 눌림 감지
    if current_state == 1 and last_state == 0:
        # 보드 B에 LED ON 명령 전송
        cmd = {"action": "led_on", "color": [255, 0, 0]}
        message = ujson.dumps(cmd)
        client.publish(TOPIC_B_CONTROL, message)
        print("[A] → [B] LED ON 전송")
        time.sleep(0.05)

    last_state = current_state
    client.check_msg()  # 보드 A도 메시지 수신 가능
    time.sleep(0.01)
```

**동작**:

1. 보드 A에서 버튼 A 누름
2. `hexaboard/B/control/led` Topic으로 메시지 전송
3. 보드 B가 메시지 수신
4. 보드 B의 LED가 빨간색으로 켜짐

---

## 💻 실습 4: 통합 모니터링

### 모든 보드의 데이터 수신

**Python 모니터링 스크립트**:

```python
# 파일명: ch14_monitor.py
# 모든 헥사보드 모니터링

import paho.mqtt.client as mqtt
import json

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"

# Topic 설정 (와일드카드 사용)
TOPIC_ALL = "hexaboard/#"  # 모든 hexaboard Topic

def on_connect(client, userdata, flags, rc):
    """연결 성공"""
    if rc == 0:
        print("✅ Broker 연결 성공!")
        client.subscribe(TOPIC_ALL)
        print(f"📬 구독: {TOPIC_ALL}")
    else:
        print(f"❌ 연결 실패: {rc}")

def on_message(client, userdata, msg):
    """메시지 수신"""
    topic = msg.topic
    payload = msg.payload.decode()

    print(f"\n📥 [{topic}]")

    try:
        data = json.loads(payload)
        print(f"   데이터: {data}")
    except:
        print(f"   내용: {payload}")

# MQTT 클라이언트 생성
client = mqtt.Client()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)
client.tls_set()  # TLS 활성화

client.on_connect = on_connect
client.on_message = on_message

# 연결 및 실행
try:
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    print("모니터링 시작... (Ctrl+C로 종료)")
    client.loop_forever()

except KeyboardInterrupt:
    print("\n종료")
    client.disconnect()
```

**동작**:

- 모든 `hexaboard/*` Topic 구독
- 모든 보드의 메시지 실시간 표시

**출력 예시**:

```
✅ Broker 연결 성공!
📬 구독: hexaboard/#

📥 [hexaboard/A/sensor/data]
   데이터: {'board': 'A', 'temperature': 25, 'humidity': 60, 'timestamp': 1234567890}

📥 [hexaboard/B/status]
   내용: online

📥 [hexaboard/A/sensor/data]
   데이터: {'board': 'A', 'temperature': 26, 'humidity': 61, 'timestamp': 1234567895}
```

---

## 🎯 Topic 와일드카드

### Wildcard 사용법

MQTT는 **와일드카드**를 지원해 여러 Topic을 한 번에 구독할 수 있습니다.

#### 1. `+` (Single Level)

하나의 계층만 대체:

```
hexaboard/+/sensor/data
```

**매칭**:

- ✅ `hexaboard/A/sensor/data`
- ✅ `hexaboard/B/sensor/data`
- ❌ `hexaboard/A/control/led`

#### 2. `#` (Multi Level)

모든 하위 계층 대체:

```
hexaboard/#
```

**매칭**:

- ✅ `hexaboard/A/sensor/data`
- ✅ `hexaboard/B/control/led`
- ✅ `hexaboard/C/status`
- ✅ 모든 hexaboard 관련 Topic

**예시**:

```python
# 모든 보드의 센서 데이터만 구독
client.subscribe("hexaboard/+/sensor/data")

# 보드 A의 모든 Topic 구독
client.subscribe("hexaboard/A/#")

# 모든 보드의 상태만 구독
client.subscribe("hexaboard/+/status")
```

---

## 🔐 Client ID 관리

### 고유한 Client ID

각 헥사보드는 **고유한 Client ID**를 가져야 합니다.

**잘못된 예**:

```python
# 모든 보드에서 동일한 ID 사용 (❌)
MQTT_CLIENT_ID = "hexaboard"
```

**올바른 예**:

```python
# 보드 A
MQTT_CLIENT_ID = "hexaboard_A"

# 보드 B
MQTT_CLIENT_ID = "hexaboard_B"

# 보드 C
MQTT_CLIENT_ID = "hexaboard_C"
```

**중복 시 문제**:

- 먼저 연결된 기기가 강제 연결 해제됨
- 계속 재연결 시도로 불안정

---

## 📊 시스템 확장

### 많은 보드 관리

**권장 구조**:

```python
# 보드 정보를 딕셔너리로 관리
boards = {
    "A": {"location": "거실", "type": "sensor"},
    "B": {"location": "침실", "type": "control"},
    "C": {"location": "주방", "type": "sensor"}
}

# 동적으로 Topic 생성
board_id = "A"
topic_sensor = f"hexaboard/{board_id}/sensor/data"
topic_control = f"hexaboard/{board_id}/control/led"
```

---

## 🛠️ 문제 해결

### Client ID 중복

```
연결이 계속 끊어짐
```

**원인**: Client ID 중복

**해결**:

```python
# 각 보드마다 다른 ID 사용
MQTT_CLIENT_ID = "hexaboard_A"  # 보드 A
MQTT_CLIENT_ID = "hexaboard_B"  # 보드 B
```

### Topic 메시지가 안 보임

```
메시지를 보냈는데 다른 보드가 못 받음
```

**원인**: Topic 이름 불일치

**해결**:

```python
# 보내는 쪽
client.publish("hexaboard/B/control/led", msg)

# 받는 쪽 (정확히 동일해야 함)
client.subscribe("hexaboard/B/control/led")
```

### 연결 수 제한

```
100개 이상 연결 시도 시 실패
```

**원인**: HiveMQ 무료 플랜 제한 (최대 100개)

**해결**:

- 사용하지 않는 연결 정리
- 또는 유료 플랜으로 업그레이드

---

## 🚀 도전 과제

### 과제 1: 3개 보드 체인 통신

보드 A → 보드 B → 보드 C 순서로 메시지를 전달하세요.

**힌트**:

```python
# 보드 A: B에게 전송
client.publish("hexaboard/B/message", "Hello B")

# 보드 B: C에게 전달
def on_message(topic, msg):
    client.publish("hexaboard/C/message", "Hello C from B")
```

### 과제 2: 브로드캐스트 메시지

하나의 메시지를 모든 보드가 동시에 받도록 구현하세요.

**힌트**:

```python
# 공통 Topic
TOPIC_BROADCAST = "hexaboard/broadcast"

# 모든 보드가 구독
client.subscribe(TOPIC_BROADCAST)
```

---

## 📝 핵심 정리

### 꼭 기억하세요!

1. **Client ID**: 각 기기마다 고유해야 함
2. **Topic 구조**: `hexaboard/<보드ID>/<카테고리>/<항목>`
3. **와일드카드**: `+` (단일), `#` (전체)
4. **보드 간 통신**: Topic만 맞으면 자유롭게 통신 가능
5. **모니터링**: 와일드카드로 모든 메시지 확인

---

## ❓ 자주 묻는 질문

### Q1. 헥사보드를 몇 개까지 연결할 수 있나요?

**A**: HiveMQ 무료 플랜은 최대 100개 연결을 지원합니다.

### Q2. Client ID를 동일하게 해도 되나요?

**A**: 안 됩니다. Client ID가 같으면 먼저 연결된 기기가 강제 해제됩니다.

### Q3. 보드 간 직접 통신이 가능한가요?

**A**: MQTT는 Broker를 통해 통신합니다. 하지만 Topic을 통해 보드 간 메시지 전달이 가능합니다.

### Q4. 와일드카드는 Publish에도 사용할 수 있나요?

**A**: 아니요. 와일드카드는 **Subscribe에만** 사용 가능합니다.

---

## 🚀 다음 단계

멀티 헥사보드 시스템을 완성했습니다!

**다음 PART에서는**:

- Python AI 서버 구축
- OpenAI API 연동
- 센서 데이터를 AI로 해석

---

**🎉 Chapter 14 완료!**  
**🎉 PART 4 완료!**

이제 여러 헥사보드를 MQTT로 연결하고 통신할 수 있습니다!

# Chapter 15. Python에서 MQTT 데이터 수신

> **PART 5**: Python + OpenAI로 AI 명령 엔진 만들기

---

## 📚 이 챕터에서 배울 내용

- [ ] Python에서 MQTT 클라이언트를 구현할 수 있다
- [ ] 헥사보드의 센서 데이터를 수신할 수 있다
- [ ] JSON 데이터를 파싱하고 저장할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **paho-mqtt**: Python MQTT 클라이언트 라이브러리
- **Subscribe**: 헥사보드 데이터 구독
- **JSON 파싱**: 센서 데이터 처리

---

## 📖 왜 Python 서버가 필요한가?

### Python의 역할

헥사보드는 센서 데이터를 수집하고, **Python 서버**는 이를 받아서 처리합니다.

**Python 서버의 역할**:

- ✅ MQTT로 센서 데이터 수신
- ✅ 데이터 분석 및 저장
- ✅ AI(OpenAI)와 연동
- ✅ 제어 명령 생성 및 전송

**시스템 구조**:

```
헥사보드 (MicroPython)
   ↓ MQTT Publish
MQTT Broker (HiveMQ)
   ↓ MQTT Subscribe
Python AI 서버 ← 이번 챕터!
   ↓ OpenAI API
AI 분석 및 제어
   ↓ MQTT Publish
헥사보드 (제어 실행)
```

---

## 🔧 실습 준비

### 필요한 것

- [x] Python 3.10 이상
- [x] HiveMQ Cloud 연결 정보
- [x] 헥사보드 (데이터 전송용)

### Python 라이브러리 설치

**필요한 라이브러리**:

```bash
pip install paho-mqtt python-dotenv
```

**각 라이브러리 역할**:

- `paho-mqtt`: MQTT 클라이언트 라이브러리
- `python-dotenv`: 환경 변수 관리 (.env 파일 사용)

---

## 💻 실습 1: 기본 MQTT 수신

### Python MQTT 클라이언트 기본

**코드**:

```python
# 파일명: ch15_mqtt_basic.py
# Python MQTT 기본 수신

import paho.mqtt.client as mqtt

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"  # 본인의 Broker
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"

# Topic 설정
TOPIC_SENSOR = "hexaboard/A/sensor/data"

def on_connect(client, userdata, flags, rc):
    """연결 성공 시 호출"""
    if rc == 0:
        print("✅ MQTT Broker 연결 성공!")
        # Topic 구독
        client.subscribe(TOPIC_SENSOR)
        print(f"📬 구독 시작: {TOPIC_SENSOR}")
    else:
        print(f"❌ 연결 실패 (코드: {rc})")

def on_message(client, userdata, msg):
    """메시지 수신 시 호출"""
    topic = msg.topic
    payload = msg.payload.decode()

    print(f"\n📥 수신:")
    print(f"   Topic: {topic}")
    print(f"   Data: {payload}")

# MQTT 클라이언트 생성
client = mqtt.Client()

# TLS 설정 (HiveMQ Cloud)
client.tls_set()

# 인증 정보 설정
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)

# 콜백 함수 등록
client.on_connect = on_connect
client.on_message = on_message

# Broker 연결
try:
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    print("MQTT 서버 시작...")
    print("Ctrl+C로 종료")

    # 메시지 수신 대기 (무한 루프)
    client.loop_forever()

except KeyboardInterrupt:
    print("\n서버 종료")
    client.disconnect()
```

**핵심 코드 설명**:

```python
# 1. 클라이언트 생성
client = mqtt.Client()

# 2. TLS 암호화 설정
client.tls_set()

# 3. 인증 정보
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)

# 4. 콜백 함수
client.on_connect = on_connect  # 연결 시
client.on_message = on_message  # 메시지 수신 시

# 5. 연결 및 실행
client.connect(MQTT_BROKER, MQTT_PORT, 60)
client.loop_forever()  # 계속 수신
```

**실행**:

```bash
python ch15_mqtt_basic.py
```

**출력 예시**:

```
MQTT 서버 시작...
Ctrl+C로 종료
✅ MQTT Broker 연결 성공!
📬 구독 시작: hexaboard/A/sensor/data

📥 수신:
   Topic: hexaboard/A/sensor/data
   Data: {"temperature": 25, "humidity": 60, "timestamp": 1234567890}
```

---

## 💻 실습 2: JSON 데이터 파싱

### 센서 데이터 처리

**코드**:

```python
# 파일명: ch15_mqtt_json.py
# JSON 데이터 파싱

import paho.mqtt.client as mqtt
import json
from datetime import datetime

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"

TOPIC_SENSOR = "hexaboard/A/sensor/data"

def on_connect(client, userdata, flags, rc):
    """연결 성공"""
    if rc == 0:
        print("✅ MQTT 연결 성공!")
        client.subscribe(TOPIC_SENSOR)
        print(f"📬 구독: {TOPIC_SENSOR}\n")
    else:
        print(f"❌ 연결 실패: {rc}")

def on_message(client, userdata, msg):
    """메시지 수신 및 처리"""
    try:
        # JSON 파싱
        payload = msg.payload.decode()
        data = json.loads(payload)

        # 데이터 추출
        board = data.get("board", "Unknown")
        temp = data.get("temperature")
        humid = data.get("humidity")
        light = data.get("light")
        timestamp = data.get("timestamp")

        # 시간 변환
        time_str = datetime.now().strftime("%H:%M:%S")

        # 출력
        print(f"[{time_str}] 보드 {board}")
        print(f"  🌡️  온도: {temp}°C")
        print(f"  💧 습도: {humid}%")
        if light is not None:
            print(f"  💡 조도: {light}")
        print()

    except json.JSONDecodeError:
        print(f"❌ JSON 파싱 오류: {msg.payload}")
    except Exception as e:
        print(f"❌ 처리 오류: {e}")

# MQTT 클라이언트 생성 및 실행
client = mqtt.Client()
client.tls_set()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)

client.on_connect = on_connect
client.on_message = on_message

try:
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    print("Python MQTT 서버 시작...")
    print("센서 데이터 대기 중...\n")
    client.loop_forever()

except KeyboardInterrupt:
    print("\n서버 종료")
    client.disconnect()
```

**출력 예시**:

```
Python MQTT 서버 시작...
센서 데이터 대기 중...

✅ MQTT 연결 성공!
📬 구독: hexaboard/A/sensor/data

[10:30:15] 보드 A
  🌡️  온도: 25°C
  💧 습도: 60%
  💡 조도: 800

[10:30:20] 보드 A
  🌡️  온도: 26°C
  💧 습도: 61%
  💡 조도: 810
```

---

## 💻 실습 3: 데이터 저장

### CSV 파일에 저장

**코드**:

```python
# 파일명: ch15_mqtt_save.py
# 센서 데이터 저장

import paho.mqtt.client as mqtt
import json
from datetime import datetime
import csv
import os

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"

TOPIC_SENSOR = "hexaboard/+/sensor/data"  # 모든 보드

# CSV 파일 설정
CSV_FILE = "sensor_data.csv"

def init_csv():
    """CSV 파일 초기화"""
    if not os.path.exists(CSV_FILE):
        with open(CSV_FILE, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['Timestamp', 'Board', 'Temperature', 'Humidity', 'Light'])
        print(f"✅ CSV 파일 생성: {CSV_FILE}\n")

def save_to_csv(board, temp, humid, light):
    """CSV 파일에 데이터 저장"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    with open(CSV_FILE, 'a', newline='') as f:
        writer = csv.writer(f)
        writer.writerow([timestamp, board, temp, humid, light])

    print(f"💾 저장 완료: {timestamp}")

def on_connect(client, userdata, flags, rc):
    """연결 성공"""
    if rc == 0:
        print("✅ MQTT 연결 성공!")
        client.subscribe(TOPIC_SENSOR)
        print(f"📬 구독: {TOPIC_SENSOR}\n")
    else:
        print(f"❌ 연결 실패: {rc}")

def on_message(client, userdata, msg):
    """메시지 수신 및 저장"""
    try:
        # JSON 파싱
        payload = msg.payload.decode()
        data = json.loads(payload)

        # 데이터 추출
        board = data.get("board", "Unknown")
        temp = data.get("temperature")
        humid = data.get("humidity")
        light = data.get("light")

        # 콘솔 출력
        time_str = datetime.now().strftime("%H:%M:%S")
        print(f"[{time_str}] 보드 {board}: {temp}°C, {humid}%, 조도 {light}")

        # CSV 저장
        save_to_csv(board, temp, humid, light)

    except Exception as e:
        print(f"❌ 오류: {e}")

# CSV 초기화
init_csv()

# MQTT 클라이언트 생성
client = mqtt.Client()
client.tls_set()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)

client.on_connect = on_connect
client.on_message = on_message

try:
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    print("센서 데이터 수집 및 저장 시작...\n")
    client.loop_forever()

except KeyboardInterrupt:
    print("\n\n서버 종료")
    print(f"📁 데이터 저장 위치: {CSV_FILE}")
    client.disconnect()
```

**CSV 파일 결과**:

```csv
Timestamp,Board,Temperature,Humidity,Light
2025-11-25 10:30:15,A,25,60,800
2025-11-25 10:30:20,A,26,61,810
2025-11-25 10:30:25,B,24,58,750
```

---

## 💻 실습 4: 환경 변수 사용

### .env 파일로 설정 관리

**`.env` 파일 생성**:

```bash
# .env
MQTT_BROKER=abc123.s1.eu.hivemq.cloud
MQTT_PORT=8883
MQTT_USER=hexaboard
MQTT_PASSWORD=your_password_here
TOPIC_SENSOR=hexaboard/+/sensor/data
```

**Python 코드**:

```python
# 파일명: ch15_mqtt_env.py
# 환경 변수 사용

import paho.mqtt.client as mqtt
import json
from datetime import datetime
from dotenv import load_dotenv
import os

# 환경 변수 로드
load_dotenv()

# 설정 불러오기
MQTT_BROKER = os.getenv("MQTT_BROKER")
MQTT_PORT = int(os.getenv("MQTT_PORT", 8883))
MQTT_USER = os.getenv("MQTT_USER")
MQTT_PASSWORD = os.getenv("MQTT_PASSWORD")
TOPIC_SENSOR = os.getenv("TOPIC_SENSOR")

def on_connect(client, userdata, flags, rc):
    """연결 성공"""
    if rc == 0:
        print("✅ MQTT 연결 성공!")
        client.subscribe(TOPIC_SENSOR)
        print(f"📬 구독: {TOPIC_SENSOR}\n")

def on_message(client, userdata, msg):
    """메시지 수신"""
    try:
        data = json.loads(msg.payload.decode())

        board = data.get("board", "Unknown")
        temp = data.get("temperature")
        humid = data.get("humidity")

        time_str = datetime.now().strftime("%H:%M:%S")
        print(f"[{time_str}] 보드 {board}: {temp}°C, {humid}%")

    except Exception as e:
        print(f"❌ 오류: {e}")

# MQTT 클라이언트
client = mqtt.Client()
client.tls_set()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)

client.on_connect = on_connect
client.on_message = on_message

try:
    print(f"연결 중: {MQTT_BROKER}:{MQTT_PORT}")
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    client.loop_forever()

except KeyboardInterrupt:
    print("\n서버 종료")
    client.disconnect()
```

**장점**:

- ✅ 민감한 정보 분리 (Git에 올리지 않음)
- ✅ 설정 변경 용이
- ✅ 배포 환경별 다른 설정 사용 가능

---

## 💻 실습 5: 여러 Topic 구독

### 와일드카드 사용

**코드**:

```python
# 파일명: ch15_mqtt_multi.py
import paho.mqtt.client as mqtt

MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        # 여러 Topic 구독
        client.subscribe("hexaboard/+/sensor/data")  # 모든 보드 센서
        client.subscribe("hexaboard/+/status")       # 모든 보드 상태
        print("✅ 멀티 Topic 구독 완료\n")

def on_message(client, userdata, msg):
    print(f"📥 [{msg.topic}]")
    print(f"   {msg.payload.decode()}\n")

client = mqtt.Client()
client.tls_set()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)
client.on_connect = on_connect
client.on_message = on_message

client.connect(MQTT_BROKER, MQTT_PORT, 60)
client.loop_forever()
```

**와일드카드**:

- `+`: 한 레벨 (예: `hexaboard/+/sensor`)
- `#`: 모든 하위 (예: `hexaboard/#`)

---

## 🛠️ 문제 해결

### 연결 실패

```
❌ 연결 실패 (코드: 5)
```

**원인**: 인증 실패

**해결**:

```python
# Username/Password 재확인
MQTT_USER = "정확한_사용자명"
MQTT_PASSWORD = "정확한_비밀번호"
```

### TLS 오류

```
ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED]
```

**원인**: TLS 인증서 검증 실패

**해결**:

```python
# 인증서 검증 비활성화 (개발용)
import ssl
client.tls_set(cert_reqs=ssl.CERT_NONE)

# 또는 인증서 지정
client.tls_set(certfile="path/to/cert.pem")
```

### 메시지가 안 올 때

```
연결은 되지만 메시지가 안 옴
```

**확인 사항**:

1. 헥사보드가 데이터를 전송하고 있는지 확인
2. Topic 이름이 정확한지 확인
3. HiveMQ 대시보드에서 메시지 확인

---

## 🚀 도전 과제

### 과제 1: 데이터 필터링

온도가 25°C 이상일 때만 출력하세요.

**힌트**:

```python
if temp >= 25:
    print(f"⚠️ 높은 온도: {temp}°C")
```

### 과제 2: 실시간 통계

최근 5개 데이터의 평균 온도를 계산하세요.

**힌트**:

```python
temp_history = []

if len(temp_history) >= 5:
    avg = sum(temp_history[-5:]) / 5
    print(f"평균 온도: {avg:.1f}°C")
```

---

## 📝 핵심 정리

### 꼭 기억하세요!

1. **paho-mqtt**: Python MQTT 클라이언트 라이브러리
2. **on_connect**: 연결 성공 시 콜백
3. **on_message**: 메시지 수신 시 콜백
4. **client.subscribe()**: Topic 구독
5. **client.loop_forever()**: 계속 수신

---

## ❓ 자주 묻는 질문

### Q1. loop_forever()는 무엇인가요?

**A**: MQTT 클라이언트가 계속 실행되며 메시지를 수신하는 무한 루프입니다. Ctrl+C로 종료할 수 있습니다.

### Q2. 여러 Topic을 구독하려면?

**A**: 와일드카드(`+`, `#`)를 사용하거나, `subscribe()`를 여러 번 호출하면 됩니다.

### Q3. .env 파일을 Git에 올려도 되나요?

**A**: 절대 안 됩니다! `.gitignore`에 `.env`를 추가하고, `.env.example`만 올리세요.

---

## 🚀 다음 단계

Python으로 MQTT 데이터 수신에 성공했습니다!

**다음 챕터에서는**:

- 센서 데이터 요약 및 통계
- 상태 해석 (좋음/나쁨)
- AI 연동 준비

---

**🎉 Chapter 15 완료!**  
이제 Python 서버가 헥사보드의 센서 데이터를 실시간으로 받을 수 있습니다!

# Chapter 16. 센서 데이터 요약과 상태 해석

> **PART 5**: Python + OpenAI로 AI 명령 엔진 만들기

---

## 📚 이 챕터에서 배울 내용

- [ ] 센서 데이터를 요약할 수 있다
- [ ] 통계 정보를 계산할 수 있다 (평균, 최대, 최소)
- [ ] 상태를 해석할 수 있다 (좋음/나쁨)

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **데이터 요약**: 핵심 정보 추출
- **통계 계산**: 평균, 최대, 최소
- **상태 해석**: 센서 값의 의미 파악

---

## 📖 왜 데이터 요약이 필요한가?

### AI에게 전달할 정보

센서 데이터를 **그대로** AI에 전달하면:

- ❌ 너무 많은 데이터 (비용 증가)
- ❌ AI가 이해하기 어려움
- ❌ 응답 시간 느림

**요약하면**:

- ✅ 핵심 정보만 전달
- ✅ AI가 이해하기 쉬움
- ✅ 빠른 응답

**예시**:

**요약 전** (100개 데이터):

```
{"temp": 25, "humid": 60}, {"temp": 25, "humid": 61}, ...
```

**요약 후**:

```
평균 온도: 25.3°C (적정)
평균 습도: 60.5% (보통)
조도: 밝음
```

---

## 💻 실습 1: 데이터 수집 및 저장

### 최근 데이터 관리

**코드**:

```python
# 파일명: ch16_data_collector.py
# 데이터 수집 및 관리

import paho.mqtt.client as mqtt
import json
from datetime import datetime
from collections import deque

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"

TOPIC_SENSOR = "hexaboard/+/sensor/data"

# 데이터 저장 (최근 10개)
sensor_data = deque(maxlen=10)

def on_connect(client, userdata, flags, rc):
    """연결 성공"""
    if rc == 0:
        print("✅ MQTT 연결 성공!")
        client.subscribe(TOPIC_SENSOR)
        print(f"📬 구독: {TOPIC_SENSOR}\n")

def on_message(client, userdata, msg):
    """메시지 수신 및 저장"""
    try:
        data = json.loads(msg.payload.decode())

        # 타임스탬프 추가
        data['received_at'] = datetime.now().isoformat()

        # 데이터 저장
        sensor_data.append(data)

        # 출력
        temp = data.get("temperature")
        humid = data.get("humidity")
        print(f"[{len(sensor_data)}/10] {temp}°C, {humid}%")

        # 10개 모이면 요약
        if len(sensor_data) == 10:
            print("\n📊 10개 데이터 수집 완료!")
            show_summary()
            print()

    except Exception as e:
        print(f"❌ 오류: {e}")

def show_summary():
    """데이터 요약 출력"""
    if not sensor_data:
        print("데이터 없음")
        return

    # 온도 리스트
    temps = [d.get("temperature") for d in sensor_data if d.get("temperature")]
    humids = [d.get("humidity") for d in sensor_data if d.get("humidity")]

    # 통계 계산
    avg_temp = sum(temps) / len(temps) if temps else 0
    avg_humid = sum(humids) / len(humids) if humids else 0

    print(f"평균 온도: {avg_temp:.1f}°C")
    print(f"평균 습도: {avg_humid:.1f}%")

# MQTT 클라이언트
client = mqtt.Client()
client.tls_set()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)

client.on_connect = on_connect
client.on_message = on_message

try:
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    print("데이터 수집 시작...\n")
    client.loop_forever()

except KeyboardInterrupt:
    print("\n서버 종료")
    client.disconnect()
```

**출력 예시**:

```
데이터 수집 시작...

✅ MQTT 연결 성공!
📬 구독: hexaboard/+/sensor/data

[1/10] 25°C, 60%
[2/10] 26°C, 61%
...
[10/10] 24°C, 59%

📊 10개 데이터 수집 완료!
평균 온도: 25.3°C
평균 습도: 60.5%
```

---

## 💻 실습 2: 통계 계산

### 평균, 최대, 최소

**코드**:

```python
# 파일명: ch16_statistics.py
# 센서 데이터 통계

from collections import deque
import statistics

class SensorStats:
    """센서 데이터 통계 클래스"""

    def __init__(self, maxlen=20):
        self.temperatures = deque(maxlen=maxlen)
        self.humidities = deque(maxlen=maxlen)
        self.lights = deque(maxlen=maxlen)

    def add_data(self, temp, humid, light=None):
        """데이터 추가"""
        if temp is not None:
            self.temperatures.append(temp)
        if humid is not None:
            self.humidities.append(humid)
        if light is not None:
            self.lights.append(light)

    def get_temp_stats(self):
        """온도 통계"""
        if not self.temperatures:
            return None

        return {
            'avg': statistics.mean(self.temperatures),
            'min': min(self.temperatures),
            'max': max(self.temperatures),
            'median': statistics.median(self.temperatures),
            'count': len(self.temperatures)
        }

    def get_humid_stats(self):
        """습도 통계"""
        if not self.humidities:
            return None

        return {
            'avg': statistics.mean(self.humidities),
            'min': min(self.humidities),
            'max': max(self.humidities),
            'count': len(self.humidities)
        }

    def get_summary(self):
        """전체 요약"""
        temp_stats = self.get_temp_stats()
        humid_stats = self.get_humid_stats()

        summary = []

        if temp_stats:
            summary.append(f"🌡️  온도: {temp_stats['avg']:.1f}°C (최소 {temp_stats['min']}°C, 최대 {temp_stats['max']}°C)")

        if humid_stats:
            summary.append(f"💧 습도: {humid_stats['avg']:.1f}% (최소 {humid_stats['min']}%, 최대 {humid_stats['max']}%)")

        return "\n".join(summary)

# 사용 예시
if __name__ == "__main__":
    stats = SensorStats()

    # 샘플 데이터 추가
    stats.add_data(25, 60, 800)
    stats.add_data(26, 61, 810)
    stats.add_data(24, 59, 790)
    stats.add_data(25, 60, 800)
    stats.add_data(27, 62, 820)

    # 통계 출력
    print("📊 센서 데이터 통계\n")
    print(stats.get_summary())
    print()

    # 상세 정보
    temp_stats = stats.get_temp_stats()
    print(f"온도 중앙값: {temp_stats['median']:.1f}°C")
    print(f"데이터 개수: {temp_stats['count']}개")
```

**출력 예시**:

```
📊 센서 데이터 통계

🌡️  온도: 25.4°C (최소 24°C, 최대 27°C)
💧 습도: 60.4% (최소 59%, 최대 62%)

온도 중앙값: 25.0°C
데이터 개수: 5개
```

---

## 💻 실습 3: 상태 해석

### 센서 값의 의미 파악

**코드**:

```python
# 파일명: ch16_interpret.py
# 상태 해석

class SensorInterpreter:
    """센서 데이터 해석 클래스"""

    def interpret_temperature(self, temp):
        """온도 해석"""
        if temp < 18:
            return "매우 추움", "😰"
        elif temp < 22:
            return "추움", "🥶"
        elif temp < 26:
            return "적정", "😊"
        elif temp < 30:
            return "더움", "🥵"
        else:
            return "매우 더움", "🔥"

    def interpret_humidity(self, humid):
        """습도 해석"""
        if humid < 30:
            return "매우 건조", "🏜️"
        elif humid < 40:
            return "건조", "😐"
        elif humid < 60:
            return "적정", "😊"
        elif humid < 70:
            return "습함", "💧"
        else:
            return "매우 습함", "💦"

    def interpret_light(self, light):
        """조도 해석"""
        if light < 100:
            return "매우 어두움", "🌑"
        elif light < 300:
            return "어두움", "🌘"
        elif light < 700:
            return "보통", "☁️"
        elif light < 1500:
            return "밝음", "🌤️"
        else:
            return "매우 밝음", "☀️"

    def get_overall_status(self, temp, humid, light=None):
        """종합 상태"""
        temp_status, temp_emoji = self.interpret_temperature(temp)
        humid_status, humid_emoji = self.interpret_humidity(humid)

        status = []
        status.append(f"온도: {temp}°C ({temp_status} {temp_emoji})")
        status.append(f"습도: {humid}% ({humid_status} {humid_emoji})")

        if light is not None:
            light_status, light_emoji = self.interpret_light(light)
            status.append(f"조도: {light} ({light_status} {light_emoji})")

        return "\n".join(status)

    def get_recommendation(self, temp, humid):
        """권장 사항"""
        recommendations = []

        # 온도 기반
        if temp < 20:
            recommendations.append("🔥 난방을 켜세요")
        elif temp > 28:
            recommendations.append("❄️ 냉방을 켜세요")

        # 습도 기반
        if humid < 35:
            recommendations.append("💧 가습기를 켜세요")
        elif humid > 65:
            recommendations.append("💨 환기를 하세요")

        if not recommendations:
            recommendations.append("✅ 환경이 쾌적합니다")

        return "\n".join(recommendations)

# 사용 예시
if __name__ == "__main__":
    interpreter = SensorInterpreter()

    # 테스트 데이터
    test_cases = [
        (25, 60, 800),
        (30, 70, 1000),
        (18, 35, 200),
    ]

    for i, (temp, humid, light) in enumerate(test_cases, 1):
        print(f"📊 테스트 케이스 {i}\n")
        print(interpreter.get_overall_status(temp, humid, light))
        print()
        print("💡 권장 사항:")
        print(interpreter.get_recommendation(temp, humid))
        print("\n" + "="*50 + "\n")
```

**출력 예시**:

```
📊 테스트 케이스 1

온도: 25°C (적정 😊)
습도: 60% (적정 😊)
조도: 800 (밝음 🌤️)

💡 권장 사항:
✅ 환경이 쾌적합니다

==================================================

📊 테스트 케이스 2

온도: 30°C (매우 더움 🔥)
습도: 70% (매우 습함 💦)
조도: 1000 (밝음 🌤️)

💡 권장 사항:
❄️ 냉방을 켜세요
💨 환기를 하세요

==================================================
```

---

## 💻 실습 4: 실시간 요약 시스템

### MQTT + 통계 + 해석 통합

**코드**:

```python
# 파일명: ch16_summary_system.py
# 실시간 요약 시스템

import paho.mqtt.client as mqtt
import json
from datetime import datetime
from collections import deque
import statistics

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"

TOPIC_SENSOR = "hexaboard/+/sensor/data"

# 데이터 저장
sensor_buffer = deque(maxlen=10)

class DataSummarizer:
    """데이터 요약기"""

    @staticmethod
    def interpret_temp(temp):
        """온도 해석"""
        if temp < 20:
            return "추움"
        elif temp < 26:
            return "적정"
        else:
            return "더움"

    @staticmethod
    def interpret_humid(humid):
        """습도 해석"""
        if humid < 40:
            return "건조"
        elif humid < 60:
            return "적정"
        else:
            return "습함"

    @staticmethod
    def summarize(data_list):
        """데이터 요약"""
        if not data_list:
            return "데이터 없음"

        # 데이터 추출
        temps = [d['temperature'] for d in data_list if 'temperature' in d]
        humids = [d['humidity'] for d in data_list if 'humidity' in d]

        if not temps or not humids:
            return "데이터 부족"

        # 통계
        avg_temp = statistics.mean(temps)
        avg_humid = statistics.mean(humids)

        # 해석
        temp_status = DataSummarizer.interpret_temp(avg_temp)
        humid_status = DataSummarizer.interpret_humid(avg_humid)

        # 요약 생성
        summary = f"""
📊 환경 요약 (최근 {len(data_list)}개 데이터)

🌡️  온도
  • 평균: {avg_temp:.1f}°C ({temp_status})
  • 범위: {min(temps):.1f}°C ~ {max(temps):.1f}°C

💧 습도
  • 평균: {avg_humid:.1f}% ({humid_status})
  • 범위: {min(humids):.1f}% ~ {max(humids):.1f}%

⏰ 마지막 업데이트: {datetime.now().strftime("%H:%M:%S")}
"""
        return summary

def on_connect(client, userdata, flags, rc):
    """연결 성공"""
    if rc == 0:
        print("✅ MQTT 연결 성공!")
        client.subscribe(TOPIC_SENSOR)
        print(f"📬 구독: {TOPIC_SENSOR}\n")

def on_message(client, userdata, msg):
    """메시지 수신"""
    try:
        data = json.loads(msg.payload.decode())
        sensor_buffer.append(data)

        # 간단한 출력
        temp = data.get("temperature")
        humid = data.get("humidity")
        print(f"📥 [{len(sensor_buffer)}/10] {temp}°C, {humid}%")

        # 5개마다 요약
        if len(sensor_buffer) % 5 == 0:
            print("\n" + "="*50)
            summary = DataSummarizer.summarize(list(sensor_buffer))
            print(summary)
            print("="*50 + "\n")

    except Exception as e:
        print(f"❌ 오류: {e}")

# MQTT 클라이언트
client = mqtt.Client()
client.tls_set()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)

client.on_connect = on_connect
client.on_message = on_message

try:
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    print("실시간 요약 시스템 시작...\n")
    client.loop_forever()

except KeyboardInterrupt:
    print("\n서버 종료")
    client.disconnect()
```

**출력 예시**:

```
실시간 요약 시스템 시작...

✅ MQTT 연결 성공!
📬 구독: hexaboard/+/sensor/data

📥 [1/10] 25°C, 60%
📥 [2/10] 26°C, 61%
📥 [3/10] 24°C, 59%
📥 [4/10] 25°C, 60%
📥 [5/10] 27°C, 62%

==================================================

📊 환경 요약 (최근 5개 데이터)

🌡️  온도
  • 평균: 25.4°C (적정)
  • 범위: 24.0°C ~ 27.0°C

💧 습도
  • 평균: 60.4% (적정)
  • 범위: 59.0% ~ 62.0%

⏰ 마지막 업데이트: 10:35:22

==================================================
```

---

## 🛠️ 문제 해결

### deque가 뭔가요?

```python
from collections import deque

# 최대 10개만 저장 (오래된 것 자동 삭제)
data = deque(maxlen=10)
```

**장점**:

- 자동으로 오래된 데이터 제거
- 메모리 효율적
- 빠른 삽입/삭제

### 통계 계산 오류

```
statistics.StatisticsError: mean requires at least one data point
```

**원인**: 빈 리스트

**해결**:

```python
if temps:
    avg = statistics.mean(temps)
else:
    avg = 0
```

---

## 🚀 도전 과제

### 과제 1: 트렌드 분석

최근 데이터가 증가 추세인지, 감소 추세인지 판단하세요.

**힌트**:

```python
if temps[-1] > temps[0]:
    print("📈 온도 상승 중")
else:
    print("📉 온도 하강 중")
```

### 과제 2: 알림 시스템

온도가 30°C 이상이면 경고 메시지를 출력하세요.

---

## 📝 핵심 정리

### 꼭 기억하세요!

1. **데이터 요약**: AI에 전달하기 전 핵심 정보 추출
2. **통계 계산**: 평균, 최대, 최소로 데이터 파악
3. **상태 해석**: 숫자를 의미 있는 상태로 변환
4. **deque**: 고정 크기 데이터 버퍼
5. **실시간 요약**: 주기적으로 데이터 정리

---

## ❓ 자주 묻는 질문

### Q1. 몇 개의 데이터로 요약해야 하나요?

**A**: 10~20개 정도가 적당합니다. 너무 적으면 통계가 불안정하고, 너무 많으면 실시간성이 떨어집니다.

### Q2. 중앙값(median)과 평균(mean)의 차이는?

**A**: 중앙값은 이상치(outlier)에 덜 민감합니다. 평균은 모든 값을 고려합니다.

### Q3. 상태 해석 기준은 어떻게 정하나요?

**A**: 환경 기준, 사용자 선호도, 국제 표준 등을 참고하여 정합니다.

---

## 🚀 다음 단계

센서 데이터를 요약하고 해석할 수 있게 되었습니다!

**다음 챕터에서는**:

- OpenAI API 연동
- 요약된 데이터를 AI에 전달
- 자연어로 상태 설명 받기

---

**🎉 Chapter 16 완료!**  
이제 센서 데이터를 의미 있는 정보로 변환할 수 있습니다!

# Chapter 17. OpenAI API 연동 및 프롬프트 설계

> **PART 5**: Python + OpenAI로 AI 명령 엔진 만들기

---

## 📚 이 챕터에서 배울 내용

- [ ] OpenAI API를 연동할 수 있다
- [ ] 센서 데이터를 자연어로 변환할 수 있다
- [ ] 효과적인 프롬프트를 설계할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **OpenAI API**: GPT-4를 사용한 AI 분석
- **프롬프트**: AI에게 주는 명령/질문
- **자연어 생성**: 센서 데이터를 사람이 이해하기 쉬운 문장으로 변환

---

## 📖 OpenAI API란?

### GPT를 코드로 사용하기

**OpenAI API**는 ChatGPT와 같은 AI 모델을 프로그램에서 사용할 수 있게 해줍니다.

**가능한 작업**:

- ✅ 센서 데이터 분석 및 설명
- ✅ 환경 상태 해석
- ✅ 제어 명령 생성
- ✅ 사용자 질문에 답변

**우리 프로젝트에서의 역할**:

```
센서 데이터 (25°C, 60%)
  ↓
OpenAI API
  ↓
자연어 설명 ("쾌적한 환경입니다")
  ↓
제어 명령 (LED 초록색)
```

---

## 🔧 실습 준비

### OpenAI API 키 발급

1. **OpenAI 웹사이트 접속**

   - https://platform.openai.com/

2. **회원가입/로그인**

3. **API 키 생성**

   - Settings → API Keys → Create new secret key
   - 키를 복사하여 안전하게 보관

4. **요금 확인**
   - Pay-as-you-go (사용한 만큼 지불)
   - GPT-4: ~$0.03 / 1K tokens
   - 테스트용으로는 몇 달러면 충분

### 라이브러리 설치

```bash
pip install openai python-dotenv
```

### .env 파일 설정

```bash
# .env
OPENAI_API_KEY=sk-proj-XXXXXXXXXXXXXXXXXXXX
```

⚠️ **중요**: API 키를 절대 Git에 올리지 마세요!

---

## 💻 실습 1: OpenAI API 기본 사용

### 첫 번째 API 호출

**코드**:

```python
# 파일명: ch17_openai_basic.py
# OpenAI API 기본 사용

from openai import OpenAI
from dotenv import load_dotenv
import os

# 환경 변수 로드
load_dotenv()

# OpenAI 클라이언트 생성
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def ask_gpt(prompt):
    """GPT에게 질문"""
    try:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "당신은 IoT 환경 분석 전문가입니다."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=200,
            temperature=0.7
        )

        return response.choices[0].message.content

    except Exception as e:
        return f"오류: {e}"

# 테스트
if __name__ == "__main__":
    prompt = "온도 25°C, 습도 60%인 환경에 대해 설명해주세요."

    print("📤 질문:")
    print(prompt)
    print("\n🤖 AI 응답:")

    answer = ask_gpt(prompt)
    print(answer)
```

**주요 파라미터**:

- `model`: 사용할 AI 모델 (`gpt-4`, `gpt-3.5-turbo`)
- `messages`: 대화 내용
  - `system`: AI의 역할 설정
  - `user`: 사용자 질문
- `max_tokens`: 최대 응답 길이
- `temperature`: 창의성 (0~2, 낮을수록 일관적)

**출력 예시**:

```
📤 질문:
온도 25°C, 습도 60%인 환경에 대해 설명해주세요.

🤖 AI 응답:
현재 환경은 매우 쾌적합니다. 온도 25°C는 실내 적정 온도 범위(22-26°C)에 포함되며, 습도 60%도 이상적인 범위(40-60%)에 있습니다. 이러한 환경에서는 대부분의 사람들이 편안함을 느끼며, 별도의 냉난방 조절이 필요하지 않습니다.
```

---

## 💻 실습 2: 센서 데이터 분석

### 센서 데이터를 AI로 분석

**코드**:

```python
# 파일명: ch17_analyze_sensor.py
# 센서 데이터 AI 분석

from openai import OpenAI
from dotenv import load_dotenv
import os

load_dotenv()
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def analyze_sensor_data(temp, humid, light=None):
    """센서 데이터 분석"""

    # 프롬프트 생성
    prompt = f"""
다음 센서 데이터를 분석하고 환경 상태를 설명해주세요:

- 온도: {temp}°C
- 습도: {humid}%
"""

    if light is not None:
        prompt += f"- 조도: {light}\n"

    prompt += """
다음 항목을 포함해 3-4문장으로 설명해주세요:
1. 현재 환경 상태
2. 쾌적도 평가
3. 간단한 권장 사항
"""

    try:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "당신은 실내 환경 분석 전문가입니다. 간결하고 명확하게 답변하세요."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=250,
            temperature=0.5
        )

        return response.choices[0].message.content

    except Exception as e:
        return f"분석 실패: {e}"

# 테스트
if __name__ == "__main__":
    test_cases = [
        (25, 60, 800),   # 쾌적
        (30, 75, 1200),  # 덥고 습함
        (18, 35, 200),   # 춥고 건조
    ]

    for i, (temp, humid, light) in enumerate(test_cases, 1):
        print(f"\n{'='*60}")
        print(f"테스트 케이스 {i}: {temp}°C, {humid}%, 조도 {light}")
        print(f"{'='*60}\n")

        analysis = analyze_sensor_data(temp, humid, light)
        print(analysis)
```

**출력 예시**:

```
============================================================
테스트 케이스 1: 25°C, 60%, 조도 800
============================================================

현재 환경은 매우 쾌적한 상태입니다. 온도 25°C와 습도 60%는 모두 이상적인 범위에 있으며, 조도 800도 실내 활동에 적합한 밝기입니다. 대부분의 사람들이 편안함을 느낄 수 있는 환경으로, 별도의 환경 조절이 필요하지 않습니다. 현재 상태를 유지하시면 됩니다.

============================================================
테스트 케이스 2: 30°C, 75%, 조도 1200
============================================================

현재 환경은 다소 불쾌한 상태입니다. 온도 30°C는 적정 온도보다 높고, 습도 75%도 권장 범위를 초과하여 끈적이고 답답함을 느낄 수 있습니다. 조도 1200은 매우 밝은 편입니다. 에어컨이나 선풍기로 온도를 낮추고, 제습기를 사용하거나 환기를 통해 습도를 조절하는 것이 좋습니다.
```

---

## 💻 실습 3: 프롬프트 설계

### 효과적인 프롬프트 작성

**좋은 프롬프트의 조건**:

1. ✅ **명확한 역할** 정의 (system message)
2. ✅ **구체적인 데이터** 제공
3. ✅ **원하는 출력 형식** 지정
4. ✅ **예시** 제공 (필요 시)

**예시 1: 나쁜 프롬프트**

```python
prompt = "온도 25도"
```

❌ 무엇을 원하는지 불명확

**예시 2: 좋은 프롬프트**

```python
prompt = """
센서 데이터:
- 온도: 25°C
- 습도: 60%

위 데이터를 분석하여 다음 형식으로 답변해주세요:
1. 환경 상태 (한 문장)
2. 권장 조치 (있으면 제시, 없으면 "없음")
"""
```

✅ 명확하고 구조화됨

**프롬프트 템플릿**:

```python
# 파일명: ch17_prompt_template.py
# 프롬프트 템플릿

class PromptBuilder:
    """프롬프트 생성 클래스"""

    @staticmethod
    def build_analysis_prompt(temp, humid, light=None):
        """분석용 프롬프트"""
        prompt = f"""
당신은 실내 환경 분석 AI입니다.

## 현재 센서 데이터
- 온도: {temp}°C
- 습도: {humid}%
"""

        if light is not None:
            prompt += f"- 조도: {light}\n"

        prompt += """

## 분석 요청
위 데이터를 바탕으로 다음을 제공해주세요:

1. **환경 평가**: 현재 환경이 쾌적한지 평가 (한 문장)
2. **문제점**: 있다면 구체적으로 언급 (없으면 "없음")
3. **권장 조치**: 개선이 필요하면 구체적인 방법 제시 (없으면 "현재 상태 유지")

## 답변 형식
간결하고 실용적으로 답변해주세요. (100자 이내)
"""
        return prompt

    @staticmethod
    def build_control_prompt(temp, humid):
        """제어 명령 생성용 프롬프트"""
        prompt = f"""
센서 데이터:
- 온도: {temp}°C
- 습도: {humid}%

위 데이터를 바탕으로 LED 색상을 추천해주세요:
- 쾌적함: 초록색
- 주의 필요: 노란색
- 개선 필요: 빨간색

"초록색", "노란색", "빨간색" 중 하나만 답변하세요.
"""
        return prompt

# 사용 예시
if __name__ == "__main__":
    from openai import OpenAI
    from dotenv import load_dotenv
    import os

    load_dotenv()
    client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

    # 분석 프롬프트 테스트
    prompt = PromptBuilder.build_analysis_prompt(30, 75, 1200)

    print("📤 프롬프트:")
    print(prompt)
    print("\n" + "="*60 + "\n")

    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "user", "content": prompt}
        ],
        max_tokens=200,
        temperature=0.3
    )

    print("🤖 AI 응답:")
    print(response.choices[0].message.content)
```

---

## 💻 실습 4: 실시간 AI 분석 시스템

### MQTT + OpenAI 통합

**코드**:

```python
# 파일명: ch17_ai_system.py
# 실시간 AI 분석 시스템

import paho.mqtt.client as mqtt
from openai import OpenAI
from dotenv import load_dotenv
import os
import json
from datetime import datetime

# 환경 변수 로드
load_dotenv()

# 설정
MQTT_BROKER = os.getenv("MQTT_BROKER")
MQTT_PORT = int(os.getenv("MQTT_PORT", 8883))
MQTT_USER = os.getenv("MQTT_USER")
MQTT_PASSWORD = os.getenv("MQTT_PASSWORD")
TOPIC_SENSOR = "hexaboard/+/sensor/data"

# OpenAI 클라이언트
openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def analyze_with_ai(temp, humid, light=None):
    """AI로 센서 데이터 분석"""
    prompt = f"""
센서 데이터 분석:
- 온도: {temp}°C
- 습도: {humid}%
"""

    if light:
        prompt += f"- 조도: {light}\n"

    prompt += "\n환경을 한 문장으로 평가하고, 필요한 조치를 제안해주세요."

    try:
        response = openai_client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "실내 환경 분석 전문가. 간결하게 답변."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=150,
            temperature=0.5
        )

        return response.choices[0].message.content

    except Exception as e:
        return f"AI 분석 실패: {e}"

def on_connect(client, userdata, flags, rc):
    """MQTT 연결"""
    if rc == 0:
        print("✅ MQTT 연결 성공!")
        client.subscribe(TOPIC_SENSOR)
        print(f"📬 구독: {TOPIC_SENSOR}\n")

def on_message(client, userdata, msg):
    """메시지 수신 및 AI 분석"""
    try:
        data = json.loads(msg.payload.decode())

        temp = data.get("temperature")
        humid = data.get("humidity")
        light = data.get("light")
        board = data.get("board", "Unknown")

        # 데이터 출력
        time_str = datetime.now().strftime("%H:%M:%S")
        print(f"\n{'='*60}")
        print(f"[{time_str}] 보드 {board}")
        print(f"{'='*60}")
        print(f"🌡️  온도: {temp}°C")
        print(f"💧 습도: {humid}%")
        if light:
            print(f"💡 조도: {light}")

        # AI 분석
        print("\n🤖 AI 분석 중...")
        analysis = analyze_with_ai(temp, humid, light)
        print(f"\n💬 {analysis}")
        print()

    except Exception as e:
        print(f"❌ 오류: {e}")

# MQTT 클라이언트
mqtt_client = mqtt.Client()
mqtt_client.tls_set()
mqtt_client.username_pw_set(MQTT_USER, MQTT_PASSWORD)

mqtt_client.on_connect = on_connect
mqtt_client.on_message = on_message

# 실행
try:
    print("🚀 AI 환경 분석 시스템 시작...\n")
    mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
    mqtt_client.loop_forever()

except KeyboardInterrupt:
    print("\n\n시스템 종료")
    mqtt_client.disconnect()
```

**출력 예시**:

```
🚀 AI 환경 분석 시스템 시작...

✅ MQTT 연결 성공!
📬 구독: hexaboard/+/sensor/data

============================================================
[10:45:32] 보드 A
============================================================
🌡️  온도: 30°C
💧 습도: 75%
💡 조도: 1200

🤖 AI 분석 중...

💬 현재 환경은 덥고 습하여 불쾌지수가 높습니다. 에어컨을 가동하고 제습기를 사용하거나 환기를 통해 온도를 25°C 이하, 습도를 60% 이하로 낮추는 것이 좋습니다.
```

---

## 💰 비용 관리

### OpenAI API 요금

**GPT-4 요금** (2024년 기준):

- Input: ~$0.03 / 1K tokens
- Output: ~$0.06 / 1K tokens

**예상 비용**:

```
1회 분석: ~200 tokens
비용: ~$0.01
100회 분석: ~$1
```

**절약 팁**:

1. ✅ `gpt-3.5-turbo` 사용 (저렴함)
2. ✅ `max_tokens` 제한
3. ✅ 분석 빈도 조절 (5-10초마다)
4. ✅ 캐싱 (같은 데이터는 재분석 안 함)

---

## 🛠️ 문제 해결

### API 키 오류

```
openai.AuthenticationError: Incorrect API key
```

**해결**:

- `.env` 파일 확인
- API 키 재생성

### Rate Limit 오류

```
openai.RateLimitError: Rate limit reached
```

**해결**:

- 요청 빈도 낮추기
- 요금제 업그레이드

---

## 🚀 도전 과제

### 과제 1: 감정 분석

환경 데이터를 바탕으로 "기쁨", "불편", "경고" 중 하나를 반환하세요.

### 과제 2: 맞춤형 권장

사용자 선호도 (따뜻함 선호, 시원함 선호)를 고려한 권장 사항을 제시하세요.

---

## 📝 핵심 정리

### 꼭 기억하세요!

1. **OpenAI API**: GPT-4를 코드로 사용
2. **프롬프트**: 명확하고 구체적으로 작성
3. **system message**: AI 역할 정의
4. **temperature**: 창의성 조절 (0=일관적, 2=창의적)
5. **비용 관리**: 불필요한 호출 최소화

---

## ❓ 자주 묻는 질문

### Q1. GPT-4와 GPT-3.5의 차이는?

**A**: GPT-4가 더 정확하지만 비쌉니다. 간단한 분석은 GPT-3.5로도 충분합니다.

### Q2. API 키를 무료로 사용할 수 있나요?

**A**: 무료 크레딧이 제공될 수 있지만, 기본적으로는 유료입니다.

### Q3. temperature는 어떻게 설정하나요?

**A**: 일관된 분석에는 0.3-0.5, 창의적인 응답에는 0.7-1.0을 권장합니다.

---

## 🚀 다음 단계

OpenAI API를 센서 데이터 분석에 성공적으로 연동했습니다!

**다음 챕터에서는**:

- AI 응답을 제어 명령으로 변환
- LED 색상 자동 결정
- 자동 제어 시스템 구축

---

**🎉 Chapter 17 완료!**  
이제 AI가 센서 데이터를 분석하고 조언을 제공할 수 있습니다!

# Chapter 18. AI 응답을 제어 명령으로 변환하기

> **PART 5**: Python + OpenAI로 AI 명령 엔진 만들기

---

## 📚 이 챕터에서 배울 내용

- [ ] AI 응답을 JSON 명령으로 변환할 수 있다
- [ ] LED 색상을 자동으로 결정할 수 있다
- [ ] 제어 명령을 생성할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **명령 변환**: AI 텍스트 → JSON 명령
- **구조화된 출력**: AI가 JSON 형식으로 응답
- **자동 제어**: 센서 데이터 → AI 분석 → 제어

---

## 📖 왜 명령 변환이 필요한가?

### AI 응답의 문제점

AI는 **자연어**로 응답합니다:

```
"온도가 높으니 LED를 빨간색으로 켜세요"
```

하지만 헥사보드는 **JSON 명령**이 필요합니다:

```json
{
  "action": "led_on",
  "color": [255, 0, 0]
}
```

**해결책**:

1. AI에게 JSON 형식으로 응답하도록 요청
2. 또는 AI 응답을 파싱하여 JSON으로 변환

---

## 💻 실습 1: JSON 형식 응답 요청

### AI가 직접 JSON 생성

**코드**:

```python
# 파일명: ch18_json_response.py
# AI로 JSON 명령 생성

from openai import OpenAI
from dotenv import load_dotenv
import os
import json

load_dotenv()
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def generate_led_command(temp, humid):
    """온도/습도에 따른 LED 명령 생성"""

    prompt = f"""
센서 데이터:
- 온도: {temp}°C
- 습도: {humid}%

위 데이터를 분석하여 LED 제어 명령을 JSON 형식으로 생성하세요.

규칙:
- 온도 < 20°C 또는 습도 < 40%: 파란색 [0, 0, 255]
- 온도 20-26°C, 습도 40-60%: 초록색 [0, 255, 0]
- 온도 > 26°C 또는 습도 > 60%: 빨간색 [255, 0, 0]

출력 형식 (JSON만):
{{
  "action": "led_color",
  "color": [R, G, B],
  "reason": "이유 (한 문장)"
}}

JSON만 출력하세요. 다른 텍스트는 포함하지 마세요.
"""

    try:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "당신은 JSON 명령을 생성하는 시스템입니다. 항상 유효한 JSON만 출력하세요."},
                {"role": "user", "content": prompt}
            ],
            max_tokens=150,
            temperature=0.3
        )

        # JSON 파싱
        json_str = response.choices[0].message.content.strip()
        command = json.loads(json_str)

        return command

    except json.JSONDecodeError as e:
        print(f"JSON 파싱 오류: {e}")
        print(f"응답: {response.choices[0].message.content}")
        return None
    except Exception as e:
        print(f"오류: {e}")
        return None

# 테스트
if __name__ == "__main__":
    test_cases = [
        (25, 55, "쾌적"),
        (30, 70, "덥고 습함"),
        (18, 35, "춥고 건조"),
    ]

    for temp, humid, desc in test_cases:
        print(f"\n{'='*60}")
        print(f"테스트: {temp}°C, {humid}% ({desc})")
        print(f"{'='*60}\n")

        command = generate_led_command(temp, humid)

        if command:
            print("✅ 생성된 명령:")
            print(json.dumps(command, indent=2, ensure_ascii=False))
```

**출력 예시**:

```
============================================================
테스트: 25°C, 55% (쾌적)
============================================================

✅ 생성된 명령:
{
  "action": "led_color",
  "color": [0, 255, 0],
  "reason": "온도와 습도가 모두 적정 범위에 있어 쾌적합니다"
}

============================================================
테스트: 30°C, 70% (덥고 습함)
============================================================

✅ 생성된 명령:
{
  "action": "led_color",
  "color": [255, 0, 0],
  "reason": "온도가 높고 습도도 높아 불쾌한 환경입니다"
}
```

---

## 💻 실습 2: 명령 생성 클래스

### 재사용 가능한 명령 생성기

**코드**:

````python
# 파일명: ch18_command_generator.py
# 명령 생성 클래스

from openai import OpenAI
from dotenv import load_dotenv
import os
import json

load_dotenv()

class CommandGenerator:
    """AI 기반 명령 생성기"""

    def __init__(self):
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

    def generate_led_command(self, temp, humid, light=None):
        """LED 제어 명령 생성"""

        prompt = f"""
센서 데이터 분석 및 LED 제어 명령 생성:
- 온도: {temp}°C
- 습도: {humid}%
"""

        if light:
            prompt += f"- 조도: {light}\n"

        prompt += """

조건에 따라 LED 색상을 결정하세요:
1. 매우 쾌적 (온도 22-26°C, 습도 40-60%): 초록색 [0, 255, 0]
2. 주의 필요 (온도 18-30°C, 습도 30-70%): 노란색 [255, 255, 0]
3. 개선 필요 (그 외): 빨간색 [255, 0, 0]

JSON 형식으로 응답:
{
  "action": "led_color",
  "color": [R, G, B],
  "brightness": 50-100 (숫자),
  "reason": "이유"
}
"""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "JSON 명령 생성 전문가. 유효한 JSON만 출력."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=200,
                temperature=0.3
            )

            json_str = response.choices[0].message.content.strip()

            # ```json ... ``` 제거
            if json_str.startswith("```"):
                json_str = json_str.split("```")[1]
                if json_str.startswith("json"):
                    json_str = json_str[4:]

            command = json.loads(json_str.strip())
            return command

        except Exception as e:
            print(f"명령 생성 실패: {e}")
            # 기본 명령 반환
            return {
                "action": "led_color",
                "color": [255, 255, 0],
                "brightness": 50,
                "reason": "AI 분석 실패"
            }

    def generate_multiple_commands(self, temp, humid):
        """여러 제어 명령 생성 (LED + 권장사항)"""

        prompt = f"""
센서: 온도 {temp}°C, 습도 {humid}%

다음 JSON 배열 형식으로 제어 명령을 생성하세요:
[
  {{
    "device": "led",
    "action": "color",
    "params": {{"color": [R, G, B]}}
  }},
  {{
    "device": "notification",
    "action": "message",
    "params": {{"text": "권장사항 메시지"}}
  }}
]
"""

        try:
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "JSON 배열 생성. 유효한 JSON만 출력."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=250,
                temperature=0.3
            )

            json_str = response.choices[0].message.content.strip()

            # 코드 블록 제거
            if "```" in json_str:
                json_str = json_str.split("```")[1]
                json_str = json_str.replace("json", "", 1).strip()

            commands = json.loads(json_str)
            return commands

        except Exception as e:
            print(f"명령 생성 실패: {e}")
            return []

# 테스트
if __name__ == "__main__":
    generator = CommandGenerator()

    # 테스트 1: 단일 명령
    print("📋 테스트 1: LED 명령 생성\n")
    cmd = generator.generate_led_command(28, 65, 900)
    print(json.dumps(cmd, indent=2, ensure_ascii=False))

    # 테스트 2: 여러 명령
    print("\n" + "="*60)
    print("📋 테스트 2: 다중 명령 생성\n")
    cmds = generator.generate_multiple_commands(30, 75)
    print(json.dumps(cmds, indent=2, ensure_ascii=False))
````

---

## 💻 실습 3: 규칙 기반 + AI 하이브리드

### 빠른 응답 + AI 보조

**코드**:

```python
# 파일명: ch18_hybrid.py
# 규칙 기반 + AI 하이브리드

class HybridController:
    """규칙 기반 + AI 하이브리드 제어"""

    def __init__(self, use_ai=True):
        self.use_ai = use_ai
        if use_ai:
            from openai import OpenAI
            from dotenv import load_dotenv
            load_dotenv()
            self.ai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

    def rule_based_command(self, temp, humid):
        """규칙 기반 명령 (빠름)"""

        # 기본 규칙
        if temp < 20 or humid < 40:
            color = [0, 0, 255]  # 파란색
            status = "추움/건조"
        elif temp > 26 or humid > 60:
            color = [255, 0, 0]  # 빨간색
            status = "더움/습함"
        else:
            color = [0, 255, 0]  # 초록색
            status = "쾌적"

        return {
            "action": "led_color",
            "color": color,
            "reason": status,
            "method": "rule"
        }

    def ai_based_command(self, temp, humid):
        """AI 기반 명령 (정교함)"""

        if not self.use_ai:
            return self.rule_based_command(temp, humid)

        prompt = f"""
온도 {temp}°C, 습도 {humid}%

LED 색상 (JSON):
{{"action": "led_color", "color": [R,G,B], "reason": "이유"}}
"""

        try:
            response = self.ai_client.chat.completions.create(
                model="gpt-3.5-turbo",  # 빠르고 저렴
                messages=[
                    {"role": "system", "content": "JSON 생성. 간결하게."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=100,
                temperature=0.3
            )

            json_str = response.choices[0].message.content.strip()
            command = json.loads(json_str)
            command["method"] = "ai"
            return command

        except:
            # AI 실패 시 규칙 기반으로 폴백
            return self.rule_based_command(temp, humid)

    def get_command(self, temp, humid, force_ai=False):
        """명령 생성 (하이브리드)"""

        # 극단적인 경우는 규칙 기반 (빠름)
        if (temp < 15 or temp > 35 or humid < 20 or humid > 80) and not force_ai:
            return self.rule_based_command(temp, humid)

        # 일반적인 경우는 AI 사용
        if self.use_ai:
            return self.ai_based_command(temp, humid)
        else:
            return self.rule_based_command(temp, humid)

# 테스트
if __name__ == "__main__":
    import json
    import time

    controller = HybridController(use_ai=True)

    test_cases = [
        (10, 25, "극단: 매우 추움"),
        (25, 55, "일반: 쾌적"),
        (30, 70, "일반: 덥고 습함"),
    ]

    for temp, humid, desc in test_cases:
        print(f"\n{'='*60}")
        print(f"{desc}: {temp}°C, {humid}%")
        print(f"{'='*60}\n")

        start = time.time()
        cmd = controller.get_command(temp, humid)
        elapsed = time.time() - start

        print(json.dumps(cmd, indent=2, ensure_ascii=False))
        print(f"\n⏱️  처리 시간: {elapsed:.2f}초")
        print(f"📊 처리 방식: {cmd.get('method', 'unknown')}")
```

**출력 예시**:

```
============================================================
극단: 매우 추움: 10°C, 25%
============================================================

{
  "action": "led_color",
  "color": [0, 0, 255],
  "reason": "추움/건조",
  "method": "rule"
}

⏱️  처리 시간: 0.00초
📊 처리 방식: rule

============================================================
일반: 쾌적: 25°C, 55%
============================================================

{
  "action": "led_color",
  "color": [0, 255, 0],
  "reason": "온도와 습도가 적정 범위입니다",
  "method": "ai"
}

⏱️  처리 시간: 1.23초
📊 처리 방식: ai
```

---

## 💻 실습 4: 명령 검증

### 안전한 명령 실행

**코드**:

```python
# 파일명: ch18_validator.py
# 명령 검증

class CommandValidator:
    """명령 검증 클래스"""

    @staticmethod
    def validate_led_command(command):
        """LED 명령 검증"""

        # 필수 필드 확인
        if not isinstance(command, dict):
            return False, "명령이 딕셔너리가 아님"

        if "action" not in command:
            return False, "action 필드 없음"

        if "color" not in command:
            return False, "color 필드 없음"

        # 색상 검증
        color = command["color"]

        if not isinstance(color, list) or len(color) != 3:
            return False, "color는 3개 요소의 리스트여야 함"

        # RGB 범위 확인
        for i, c in enumerate(color):
            if not isinstance(c, int) or c < 0 or c > 255:
                return False, f"color[{i}]는 0-255 범위의 정수여야 함"

        # 밝기 검증 (선택)
        if "brightness" in command:
            brightness = command["brightness"]
            if not isinstance(brightness, int) or brightness < 0 or brightness > 100:
                return False, "brightness는 0-100 범위의 정수여야 함"

        return True, "검증 통과"

    @staticmethod
    def sanitize_command(command):
        """명령 정제 (안전하게 수정)"""

        if not isinstance(command, dict):
            return None

        # 안전한 명령 생성
        safe_command = {}

        # action
        if "action" in command:
            safe_command["action"] = str(command["action"])

        # color
        if "color" in command and isinstance(command["color"], list):
            color = command["color"]
            safe_command["color"] = [
                max(0, min(255, int(c))) for c in color[:3]
            ]

        # brightness
        if "brightness" in command:
            try:
                brightness = int(command["brightness"])
                safe_command["brightness"] = max(0, min(100, brightness))
            except:
                safe_command["brightness"] = 50  # 기본값

        return safe_command

# 테스트
if __name__ == "__main__":
    import json

    validator = CommandValidator()

    test_commands = [
        {"action": "led_color", "color": [0, 255, 0]},  # 정상
        {"action": "led_color", "color": [0, 300, -10]},  # 범위 초과
        {"action": "led_color", "color": "red"},  # 잘못된 형식
        {"color": [255, 0, 0]},  # action 누락
    ]

    for i, cmd in enumerate(test_commands, 1):
        print(f"\n테스트 {i}:")
        print(f"입력: {json.dumps(cmd, ensure_ascii=False)}")

        # 검증
        valid, msg = validator.validate_led_command(cmd)
        print(f"검증: {'✅ ' + msg if valid else '❌ ' + msg}")

        # 정제
        if not valid:
            safe_cmd = validator.sanitize_command(cmd)
            if safe_cmd:
                print(f"정제: {json.dumps(safe_cmd, ensure_ascii=False)}")
```

---

## 🛠️ 문제 해결

### JSON 파싱 오류

```
json.JSONDecodeError: Expecting value
```

**원인**: AI가 JSON 외 텍스트 포함

**해결**:

````python
# 코드 블록 제거
json_str = response.content.strip()
if "```" in json_str:
    json_str = json_str.split("```")[1]
    json_str = json_str.replace("json", "", 1)
````

### 느린 응답

**해결**:

- `gpt-3.5-turbo` 사용 (더 빠름)
- `max_tokens` 줄이기
- 규칙 기반으로 폴백

---

## 🚀 도전 과제

### 과제 1: 복잡한 명령 생성

LED 색상 + 깜빡임 패턴을 포함한 명령을 생성하세요.

### 과제 2: 우선순위 기반 제어

여러 센서 데이터 중 가장 시급한 것을 우선 처리하세요.

---

## 📝 핵심 정리

### 꼭 기억하세요!

1. **JSON 응답**: AI에게 JSON 형식 요청
2. **명령 검증**: 안전성 확인
3. **하이브리드**: 규칙 + AI 조합
4. **폴백**: AI 실패 시 규칙 기반
5. **정제**: 잘못된 값 자동 수정

---

## ❓ 자주 묻는 질문

### Q1. AI가 JSON이 아닌 텍스트를 반환하면?

**A**: 프롬프트를 더 명확하게 작성하고, 파싱 전에 정제하세요.

### Q2. 규칙 기반과 AI 중 무엇을 사용해야 하나요?

**A**: 간단한 경우는 규칙, 복잡한 판단은 AI를 권장합니다.

### Q3. 명령 검증은 필수인가요?

**A**: 네! 안전한 시스템을 위해 반드시 검증하세요.

---

## 🚀 다음 단계

AI 응답을 제어 명령으로 변환하는 데 성공했습니다!

**다음 챕터에서는**:

- 헥사보드로 명령 전송
- MQTT로 제어 명령 Publish
- 완전한 자동 제어 시스템 구축

---

**🎉 Chapter 18 완료!**  
이제 AI가 생성한 명령을 헥사보드가 실행할 수 있는 형식으로 변환할 수 있습니다!

# Chapter 19. 헥사보드로 제어 명령 되돌려 보내기

> **PART 5**: Python + OpenAI로 AI 명령 엔진 만들기

---

## 📚 이 챕터에서 배울 내용

- [ ] Python에서 MQTT로 제어 명령을 보낼 수 있다
- [ ] 완전한 AI 제어 시스템을 구축할 수 있다
- [ ] 센서 데이터 → AI 분석 → 자동 제어 흐름을 완성할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 핵심 개념

- **양방향 통신**: Subscribe (센서) + Publish (제어)
- **완전 자동화**: 사람 개입 없이 AI가 자동 제어
- **피드백 루프**: 제어 → 센서 변화 → 재분석

---

## 📖 완전한 AI 제어 시스템

### 전체 흐름

```
┌─────────────────┐
│   헥사보드       │
│  (센서 데이터)   │
└────────┬────────┘
         │ ① Publish (센서)
         ↓
┌─────────────────┐
│  MQTT Broker    │
│   (HiveMQ)      │
└────────┬────────┘
         │ ② Subscribe
         ↓
┌─────────────────┐
│  Python AI      │
│  • 데이터 수신   │
│  • AI 분석       │
│  • 명령 생성     │
└────────┬────────┘
         │ ③ Publish (제어)
         ↓
┌─────────────────┐
│  MQTT Broker    │
└────────┬────────┘
         │ ④ Subscribe
         ↓
┌─────────────────┐
│   헥사보드       │
│  (명령 실행)     │
└─────────────────┘
```

---

## 🔧 실습 준비

### 필요한 것

- [x] 헥사보드 (Chapter 13 코드 실행 중)
- [x] Python 환경
- [x] OpenAI API 키
- [x] MQTT 연결 정보

---

## 💻 실습 1: 제어 명령 전송

### Python에서 MQTT Publish

**코드**:

```python
# 파일명: ch19_send_command.py
# 제어 명령 전송

import paho.mqtt.client as mqtt
import json
from dotenv import load_dotenv
import os

load_dotenv()

# MQTT 설정
MQTT_BROKER = os.getenv("MQTT_BROKER")
MQTT_PORT = int(os.getenv("MQTT_PORT", 8883))
MQTT_USER = os.getenv("MQTT_USER")
MQTT_PASSWORD = os.getenv("MQTT_PASSWORD")

# Topic 설정
TOPIC_CONTROL = "hexaboard/A/control/led"

def send_led_command(client, color, action="led_color"):
    """LED 제어 명령 전송"""

    command = {
        "action": action,
        "color": color
    }

    # JSON으로 변환
    message = json.dumps(command)

    # Publish
    client.publish(TOPIC_CONTROL, message)
    print(f"📤 명령 전송: {message}")

def on_connect(client, userdata, flags, rc):
    """연결 성공"""
    if rc == 0:
        print("✅ MQTT 연결 성공!\n")

# MQTT 클라이언트
client = mqtt.Client()
client.tls_set()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)
client.on_connect = on_connect

# 연결
client.connect(MQTT_BROKER, MQTT_PORT, 60)
client.loop_start()

# 테스트 명령 전송
try:
    print("제어 명령 테스트\n")

    # 빨간색
    print("1️⃣  빨간색 LED")
    send_led_command(client, [255, 0, 0])
    input("Enter로 다음...")

    # 초록색
    print("\n2️⃣  초록색 LED")
    send_led_command(client, [0, 255, 0])
    input("Enter로 다음...")

    # 파란색
    print("\n3️⃣  파란색 LED")
    send_led_command(client, [0, 0, 255])
    input("Enter로 다음...")

    # LED 끄기
    print("\n4️⃣  LED 끄기")
    send_led_command(client, [0, 0, 0], "led_off")

    print("\n✅ 테스트 완료!")

except KeyboardInterrupt:
    print("\n종료")

finally:
    client.loop_stop()
    client.disconnect()
```

**실행**:

```bash
python ch19_send_command.py
```

---

## 💻 실습 2: 완전 자동 AI 제어 시스템

### 센서 수신 + AI 분석 + 자동 제어

**코드**:

````python
# 파일명: ch19_auto_control.py
# 완전 자동 AI 제어 시스템

import paho.mqtt.client as mqtt
from openai import OpenAI
from dotenv import load_dotenv
import os
import json
from datetime import datetime
import time

load_dotenv()

# MQTT 설정
MQTT_BROKER = os.getenv("MQTT_BROKER")
MQTT_PORT = int(os.getenv("MQTT_PORT", 8883))
MQTT_USER = os.getenv("MQTT_USER")
MQTT_PASSWORD = os.getenv("MQTT_PASSWORD")

# Topic 설정
TOPIC_SENSOR = "hexaboard/+/sensor/data"
TOPIC_CONTROL = "hexaboard/{board}/control/led"

# OpenAI 클라이언트
openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# 제어 간격 (초)
CONTROL_INTERVAL = 10
last_control_time = 0

class AIController:
    """AI 자동 제어 시스템"""

    def __init__(self, mqtt_client):
        self.mqtt_client = mqtt_client

    def analyze_and_control(self, board, temp, humid, light=None):
        """AI 분석 및 자동 제어"""

        global last_control_time

        # 제어 간격 확인 (너무 자주 제어하지 않도록)
        current_time = time.time()
        if current_time - last_control_time < CONTROL_INTERVAL:
            return

        print(f"\n{'='*60}")
        print(f"🤖 AI 분석 시작 (보드 {board})")
        print(f"{'='*60}")

        # 1. 센서 데이터 요약
        print(f"📊 센서 데이터:")
        print(f"   온도: {temp}°C")
        print(f"   습도: {humid}%")
        if light:
            print(f"   조도: {light}")

        # 2. AI로 명령 생성
        print(f"\n🧠 AI 분석 중...")
        command = self.generate_command(temp, humid, light)

        if command:
            print(f"\n✅ 생성된 명령:")
            print(f"   색상: {command['color']}")
            print(f"   이유: {command.get('reason', 'N/A')}")

            # 3. 명령 전송
            self.send_command(board, command)

            last_control_time = current_time
        else:
            print(f"\n❌ 명령 생성 실패")

        print(f"\n{'='*60}\n")

    def generate_command(self, temp, humid, light=None):
        """AI로 LED 제어 명령 생성"""

        prompt = f"""
센서 데이터:
- 온도: {temp}°C
- 습도: {humid}%
"""

        if light:
            prompt += f"- 조도: {light}\n"

        prompt += """

LED 색상을 결정하세요:
- 쾌적: 초록색 [0, 255, 0]
- 주의: 노란색 [255, 255, 0]
- 경고: 빨간색 [255, 0, 0]

JSON 형식 (다른 텍스트 없이):
{"action": "led_color", "color": [R,G,B], "reason": "이유"}
"""

        try:
            response = openai_client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "JSON만 출력. 간결하게."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=100,
                temperature=0.3
            )

            json_str = response.choices[0].message.content.strip()

            # JSON 정제
            if "```" in json_str:
                json_str = json_str.split("```")[1]
                json_str = json_str.replace("json", "", 1).strip()

            command = json.loads(json_str)
            return command

        except Exception as e:
            print(f"   AI 오류: {e}")

            # 규칙 기반 폴백
            if temp > 26 or humid > 60:
                color = [255, 0, 0]  # 빨간색
            elif temp < 20 or humid < 40:
                color = [0, 0, 255]  # 파란색
            else:
                color = [0, 255, 0]  # 초록색

            return {
                "action": "led_color",
                "color": color,
                "reason": "규칙 기반 (AI 실패)"
            }

    def send_command(self, board, command):
        """제어 명령 전송"""

        topic = TOPIC_CONTROL.format(board=board)
        message = json.dumps(command)

        self.mqtt_client.publish(topic, message)
        print(f"\n📤 명령 전송: {topic}")

# MQTT 콜백
ai_controller = None

def on_connect(client, userdata, flags, rc):
    """연결 성공"""
    if rc == 0:
        print("✅ MQTT 연결 성공!")
        client.subscribe(TOPIC_SENSOR)
        print(f"📬 구독: {TOPIC_SENSOR}")
        print(f"\n⏰ 제어 간격: {CONTROL_INTERVAL}초")
        print(f"\n🚀 AI 자동 제어 시스템 시작...\n")

def on_message(client, userdata, msg):
    """센서 데이터 수신 → AI 분석 → 자동 제어"""

    try:
        # 데이터 파싱
        data = json.loads(msg.payload.decode())

        board = data.get("board", "Unknown")
        temp = data.get("temperature")
        humid = data.get("humidity")
        light = data.get("light")

        # 간단한 로그
        time_str = datetime.now().strftime("%H:%M:%S")
        print(f"[{time_str}] 📥 보드 {board}: {temp}°C, {humid}%")

        # AI 분석 및 제어
        if ai_controller:
            ai_controller.analyze_and_control(board, temp, humid, light)

    except Exception as e:
        print(f"❌ 처리 오류: {e}")

# MQTT 클라이언트 생성
mqtt_client = mqtt.Client()
mqtt_client.tls_set()
mqtt_client.username_pw_set(MQTT_USER, MQTT_PASSWORD)

mqtt_client.on_connect = on_connect
mqtt_client.on_message = on_message

# AI 컨트롤러 초기화
ai_controller = AIController(mqtt_client)

# 실행
try:
    mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
    mqtt_client.loop_forever()

except KeyboardInterrupt:
    print("\n\n🛑 시스템 종료")
    mqtt_client.disconnect()
````

**실행**:

```bash
python ch19_auto_control.py
```

**출력 예시**:

```
✅ MQTT 연결 성공!
📬 구독: hexaboard/+/sensor/data

⏰ 제어 간격: 10초

🚀 AI 자동 제어 시스템 시작...

[10:50:15] 📥 보드 A: 30°C, 75%

============================================================
🤖 AI 분석 시작 (보드 A)
============================================================
📊 센서 데이터:
   온도: 30°C
   습도: 75%

🧠 AI 분석 중...

✅ 생성된 명령:
   색상: [255, 0, 0]
   이유: 온도와 습도가 높아 불쾌합니다

📤 명령 전송: hexaboard/A/control/led

============================================================
```

---

## 💻 실습 3: 양방향 통신 헥사보드 코드

### 센서 전송 + 제어 수신

**헥사보드 코드**:

```python
# 파일명: ch19_hexaboard_full.py
# 완전한 양방향 통신

import network
from umqtt.simple import MQTTClient
from machine import Pin
import neopixel
import dht
import time
import ujson

# Wi-Fi 설정
WIFI_SSID = "Your_WiFi_Name"
WIFI_PASSWORD = "Your_Password"

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
MQTT_CLIENT_ID = "hexaboard_A"

# Topic
TOPIC_SENSOR = "hexaboard/A/sensor/data"
TOPIC_CONTROL = "hexaboard/A/control/led"

# 하드웨어
np = neopixel.NeoPixel(Pin(23), 25)
sensor = dht.DHT11(Pin(32))

def connect_wifi():
    """Wi-Fi 연결"""
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)

    if not wlan.isconnected():
        print("[헥사보드] Wi-Fi 연결 중...")
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)

        timeout = 10
        while not wlan.isconnected() and timeout > 0:
            time.sleep(1)
            timeout -= 1

    if wlan.isconnected():
        print("[헥사보드] ✅ Wi-Fi 연결 성공!")
        return True
    return False

def on_control_message(topic, msg):
    """제어 명령 수신"""
    print(f"[헥사보드] 📥 제어 명령 수신: {msg}")

    try:
        command = ujson.loads(msg)
        action = command.get("action")

        if action == "led_color":
            color = command.get("color", [0, 0, 0])
            for i in range(25):
                np[i] = tuple(color)
            np.write()
            print(f"[헥사보드] 💡 LED 색상 변경: {color}")

        elif action == "led_off":
            for i in range(25):
                np[i] = (0, 0, 0)
            np.write()
            print(f"[헥사보드] 💡 LED 끄기")

    except Exception as e:
        print(f"[헥사보드] ❌ 제어 오류: {e}")

def connect_mqtt():
    """MQTT 연결"""
    try:
        client = MQTTClient(
            client_id=MQTT_CLIENT_ID,
            server=MQTT_BROKER,
            port=MQTT_PORT,
            user=MQTT_USER,
            password=MQTT_PASSWORD,
            ssl=True
        )

        client.set_callback(on_control_message)
        client.connect()
        client.subscribe(TOPIC_CONTROL)

        print("[헥사보드] ✅ MQTT 연결 성공!")
        print(f"[헥사보드] 📬 구독: {TOPIC_CONTROL}")

        return client

    except Exception as e:
        print(f"[헥사보드] ❌ MQTT 연결 실패: {e}")
        return None

def publish_sensor_data(client):
    """센서 데이터 전송"""
    try:
        sensor.measure()
        temp = sensor.temperature()
        humid = sensor.humidity()

        data = {
            "board": "A",
            "temperature": temp,
            "humidity": humid,
            "timestamp": time.time()
        }

        message = ujson.dumps(data)
        client.publish(TOPIC_SENSOR, message)
        print(f"[헥사보드] 📤 센서 데이터: {temp}°C, {humid}%")

    except Exception as e:
        print(f"[헥사보드] ❌ 센서 오류: {e}")

# 메인 실행
if connect_wifi():
    client = connect_mqtt()

    if client:
        print("\n[헥사보드] 🚀 시스템 시작\n")

        last_publish = 0

        try:
            while True:
                # 제어 명령 확인
                client.check_msg()

                # 5초마다 센서 데이터 전송
                if time.time() - last_publish > 5:
                    publish_sensor_data(client)
                    last_publish = time.time()

                time.sleep(0.1)

        except KeyboardInterrupt:
            print("\n[헥사보드] 종료")

        finally:
            client.disconnect()
```

---

## 💻 실습 4: 시스템 모니터링

### 전체 시스템 상태 확인

**코드**:

```python
# 파일명: ch19_monitor.py
# 시스템 모니터링

import paho.mqtt.client as mqtt
from dotenv import load_dotenv
import os
import json
from datetime import datetime

load_dotenv()

# MQTT 설정
MQTT_BROKER = os.getenv("MQTT_BROKER")
MQTT_PORT = int(os.getenv("MQTT_PORT", 8883))
MQTT_USER = os.getenv("MQTT_USER")
MQTT_PASSWORD = os.getenv("MQTT_PASSWORD")

# 모든 Topic 구독
TOPIC_ALL = "hexaboard/#"

# 통계
stats = {
    "sensor_count": 0,
    "control_count": 0
}

def on_connect(client, userdata, flags, rc):
    """연결 성공"""
    if rc == 0:
        print("✅ 모니터링 시작!")
        client.subscribe(TOPIC_ALL)
        print(f"📬 구독: {TOPIC_ALL}\n")

def on_message(client, userdata, msg):
    """모든 메시지 모니터링"""

    topic = msg.topic
    payload = msg.payload.decode()
    time_str = datetime.now().strftime("%H:%M:%S")

    # Topic 종류 구분
    if "sensor" in topic:
        stats["sensor_count"] += 1
        icon = "📊"
        label = "센서"
    elif "control" in topic:
        stats["control_count"] += 1
        icon = "🎮"
        label = "제어"
    else:
        icon = "📄"
        label = "기타"

    # 출력
    print(f"[{time_str}] {icon} {label}")
    print(f"  Topic: {topic}")

    # JSON 파싱 시도
    try:
        data = json.loads(payload)
        print(f"  Data: {json.dumps(data, ensure_ascii=False, indent=2)}")
    except:
        print(f"  Data: {payload}")

    # 통계
    print(f"  통계: 센서 {stats['sensor_count']}개, 제어 {stats['control_count']}개")
    print()

# MQTT 클라이언트
client = mqtt.Client()
client.tls_set()
client.username_pw_set(MQTT_USER, MQTT_PASSWORD)

client.on_connect = on_connect
client.on_message = on_message

# 실행
try:
    print("🔍 전체 시스템 모니터링\n")
    client.connect(MQTT_BROKER, MQTT_PORT, 60)
    client.loop_forever()

except KeyboardInterrupt:
    print(f"\n\n📊 최종 통계:")
    print(f"   센서 메시지: {stats['sensor_count']}개")
    print(f"   제어 메시지: {stats['control_count']}개")
    print(f"\n모니터링 종료")
    client.disconnect()
```

---

## 🛠️ 문제 해결

### 제어 명령이 실행 안 됨

**확인 사항**:

1. Topic 이름 일치 확인
2. 헥사보드가 Subscribe 중인지 확인
3. JSON 형식 확인

### 너무 자주 제어됨

**해결**:

```python
CONTROL_INTERVAL = 10  # 10초로 증가
```

### AI 비용이 너무 많이 나옴

**해결**:

- `gpt-3.5-turbo` 사용
- 제어 간격 늘리기
- 규칙 기반 우선 사용

---

## 🚀 도전 과제

### 과제 1: 다중 보드 제어

여러 헥사보드를 동시에 제어하세요.

### 과제 2: 학습 기능

이전 제어 결과를 기억하여 더 나은 판단을 하세요.

---

## 📝 핵심 정리

### 꼭 기억하세요!

1. **양방향 통신**: Subscribe + Publish
2. **자동 제어**: 센서 → AI → 명령 → 실행
3. **제어 간격**: 너무 자주 제어하지 않기
4. **폴백**: AI 실패 시 규칙 기반
5. **모니터링**: 전체 시스템 상태 확인

---

## ❓ 자주 묻는 질문

### Q1. 얼마나 자주 제어해야 하나요?

**A**: 5-10초마다가 적당합니다. 너무 자주하면 비용과 부하 증가.

### Q2. 여러 헥사보드를 제어하려면?

**A**: Topic 패턴을 사용하고, board ID로 구분하세요.

### Q3. 실시간 제어가 필요한가요?

**A**: 환경 제어는 실시간이 아니어도 됩니다. 10초 정도면 충분합니다.

---

## 🚀 다음 단계

완전한 AI 자동 제어 시스템을 구축했습니다!

**다음 PART에서는**:

- 종합 프로젝트: AI 환경 무드 컨트롤러
- 실전 시나리오
- 시스템 통합 및 튜닝

---

**🎉 Chapter 19 완료!**  
**🎉 PART 5 완료!**

이제 센서 데이터를 AI가 분석하고, 자동으로 헥사보드를 제어하는 완전한 AIoT 시스템이 완성되었습니다!

# Chapter 20. 프로젝트 개요

> **PART 6**: 종합 프로젝트 – AI 환경 무드 컨트롤러

---

## 📚 이 챕터에서 배울 내용

- [ ] 종합 프로젝트의 목표를 이해한다
- [ ] 시스템 구성 요소를 파악한다
- [ ] 프로젝트 구현 계획을 세운다

**예상 소요 시간**: 20분

---

## 🎯 프로젝트 소개

### AI 환경 무드 컨트롤러란?

**실내 환경을 AI가 자동으로 분석하고 제어하는 스마트 시스템**

```
센서로 환경 감지
    ↓
AI가 상황 판단
    ↓
LED로 상태 표시
    ↓
사용자에게 권장 사항 제공
```

**핵심 기능**:

- ✅ 실시간 환경 모니터링 (온도, 습도, 조도)
- ✅ AI 기반 환경 분석 및 평가
- ✅ 자동 LED 색상 제어
- ✅ 사용자 알림 및 권장 사항

---

## 🏗️ 시스템 구성

### 전체 아키텍처

```
┌─────────────────┐
│   헥사보드       │
│  ① 센서 수집     │
│  ② LED 제어      │
└────────┬────────┘
         │ MQTT
         ↓
┌─────────────────┐
│  MQTT Broker    │
│   (HiveMQ)      │
└────────┬────────┘
         │
         ↓
┌─────────────────┐
│  Python AI      │
│  ③ 데이터 분석   │
│  ④ AI 판단       │
│  ⑤ 명령 생성     │
└─────────────────┘
```

### 주요 컴포넌트

**1. 헥사보드 (Edge Device)**

- DHT11 온습도 센서
- 조도 센서
- 5×5 NeoPixel LED
- MicroPython

**2. MQTT Broker**

- HiveMQ Cloud
- 실시간 메시지 중개

**3. Python AI 서버**

- OpenAI GPT-4
- 데이터 분석 및 명령 생성

---

## 🎨 무드 시스템 정의

### 5가지 무드 상태

| 무드           | 조건                      | LED 색상 | 의미        |
| -------------- | ------------------------- | -------- | ----------- |
| **🟢 Perfect** | 온도 22-26°C, 습도 40-60% | 초록색   | 완벽한 환경 |
| **🟡 Good**    | 온도 20-28°C, 습도 35-65% | 노란색   | 좋은 환경   |
| **🔵 Cold**    | 온도 < 20°C               | 파란색   | 추운 환경   |
| **🔴 Hot**     | 온도 > 28°C               | 빨간색   | 더운 환경   |
| **🟣 Humid**   | 습도 > 65%                | 보라색   | 습한 환경   |

### LED 패턴

**상태별 LED 표현**:

- **Perfect**: 전체 초록색, 부드러운 밝기
- **Good**: 전체 노란색
- **Cold**: 파란색 깜빡임
- **Hot**: 빨간색 깜빡임
- **Humid**: 보라색 펄스

---

## 📋 프로젝트 요구사항

### 기능 요구사항

**1. 센서 모니터링**

- [ ] 5초마다 센서 데이터 수집
- [ ] MQTT로 데이터 전송
- [ ] 센서 오류 처리

**2. AI 분석**

- [ ] 센서 데이터 해석
- [ ] 환경 상태 평가
- [ ] 권장 조치 생성

**3. 자동 제어**

- [ ] 무드에 따라 LED 자동 변경
- [ ] 사용자 알림 전송
- [ ] 제어 이력 기록

**4. 사용자 인터페이스**

- [ ] 현재 상태 표시
- [ ] 권장 사항 출력
- [ ] 수동 제어 가능

### 비기능 요구사항

- **응답 시간**: 센서 데이터 → LED 제어 < 3초
- **안정성**: 24시간 연속 동작
- **확장성**: 여러 헥사보드 지원 가능
- **사용성**: 초보자도 쉽게 설정

---

## 🛠️ 필요한 것

### 하드웨어

- [x] 헥사보드 × 1
- [x] DHT11 센서 모듈 × 1
- [x] 조도 센서 모듈 × 1
- [x] 3핀 케이블 × 2
- [x] USB 케이블 × 1

### 소프트웨어

- [x] MicroPython 1.24
- [x] Python 3.10+
- [x] OpenAI API 키
- [x] HiveMQ Cloud 계정

### 라이브러리

**Python**:

```bash
pip install paho-mqtt openai python-dotenv
```

**MicroPython**:

- `umqtt.simple`
- `neopixel`
- `dht`
- `machine`

---

## 📅 구현 일정

### 3단계 구현 계획

**Phase 1: 기본 시스템 (1시간)**

- 센서 데이터 수집
- MQTT 통신 설정
- 기본 LED 제어

**Phase 2: AI 통합 (1시간)**

- OpenAI API 연동
- 무드 분석 로직
- 자동 제어 구현

**Phase 3: 튜닝 및 테스트 (1시간)**

- 성능 최적화
- 에러 처리 강화
- 다양한 시나리오 테스트

**총 소요 시간**: 3-4시간

---

## 🎯 학습 목표

### 이 프로젝트를 통해 배울 것

1. **시스템 통합**

   - 여러 컴포넌트를 하나로 연결
   - 전체 데이터 흐름 이해

2. **실전 AIoT 개발**

   - 실제 사용 가능한 시스템 구축
   - 문제 해결 능력 향상

3. **AI 활용**

   - OpenAI API 실전 활용
   - 프롬프트 최적화

4. **프로젝트 관리**
   - 단계별 구현
   - 테스트 및 디버깅

---

## 💡 프로젝트 확장 아이디어

### 추가할 수 있는 기능

**레벨 1 (쉬움)**:

- [ ] 센서 데이터 CSV 저장
- [ ] 일일 통계 리포트
- [ ] 사용자 선호 온도 설정

**레벨 2 (보통)**:

- [ ] 시간대별 자동 모드 전환
- [ ] 여러 방 동시 모니터링
- [ ] 스마트폰 알림 연동

**레벨 3 (어려움)**:

- [ ] 머신러닝 기반 패턴 학습
- [ ] 에너지 소비 최적화
- [ ] 음성 제어 통합

---

## 📊 성공 지표

### 프로젝트 완료 기준

- [x] 센서 데이터가 정확하게 수집됨
- [x] AI가 적절한 무드를 판단함
- [x] LED가 자동으로 변경됨
- [x] 시스템이 안정적으로 동작함
- [x] 사용자가 쉽게 사용할 수 있음

---

## 🎓 사전 지식

### 필수 선수 과정

이 프로젝트를 시작하기 전에 다음을 완료해야 합니다:

- ✅ PART 1-2: 헥사보드 기본 제어
- ✅ PART 3: 센서 연결
- ✅ PART 4: MQTT 통신
- ✅ PART 5: Python AI 서버

**모든 선수 과정을 완료했다면, 시작할 준비가 되었습니다!**

---

## 🚀 다음 단계

프로젝트 개요를 이해했습니다!

**다음 챕터에서는**:

- 시스템 아키텍처 상세 설계
- 데이터 흐름 정의
- 컴포넌트 간 인터페이스 설계

---

## 📝 체크리스트

프로젝트 시작 전 확인:

- [ ] PART 1-5 완료
- [ ] 하드웨어 준비 완료
- [ ] Python 환경 설정 완료
- [ ] OpenAI API 키 발급
- [ ] HiveMQ Cloud 설정 완료
- [ ] 예제 코드 실행 테스트 완료

**모두 체크되었다면, Chapter 21로 진행하세요!**

---

**🎉 Chapter 20 완료!**  
이제 AI 환경 무드 컨트롤러 프로젝트를 시작할 준비가 되었습니다!

# Chapter 21. 시스템 아키텍처 설계

> **PART 6**: 종합 프로젝트 – AI 환경 무드 컨트롤러

---

## 📚 이 챕터에서 배울 내용

- [ ] 시스템 아키텍처를 설계할 수 있다
- [ ] 데이터 흐름을 정의할 수 있다
- [ ] 컴포넌트 간 인터페이스를 설계할 수 있다

**예상 소요 시간**: 30분

---

## 🎯 학습 목표

### 핵심 개념

- **아키텍처**: 시스템 구조와 컴포넌트 관계
- **데이터 흐름**: 정보가 이동하는 경로
- **인터페이스**: 컴포넌트 간 통신 방법

---

## 🏗️ 시스템 아키텍처

### 3계층 구조

```
┌─────────────────────────────────────┐
│      Edge Layer (엣지 계층)          │
│  ┌──────────────────────────────┐   │
│  │     헥사보드 (ESP32)          │   │
│  │  • DHT11 센서                 │   │
│  │  • 조도 센서                  │   │
│  │  • NeoPixel LED              │   │
│  │  • MicroPython                │   │
│  └──────────────────────────────┘   │
└──────────────┬──────────────────────┘
               │ MQTT (TLS)
┌──────────────┴──────────────────────┐
│   Communication Layer (통신 계층)    │
│  ┌──────────────────────────────┐   │
│  │    MQTT Broker (HiveMQ)      │   │
│  │  • Topic 관리                 │   │
│  │  • 메시지 중개                │   │
│  │  • QoS 보장                   │   │
│  └──────────────────────────────┘   │
└──────────────┬──────────────────────┘
               │ MQTT (TLS)
┌──────────────┴──────────────────────┐
│    Intelligence Layer (지능 계층)    │
│  ┌──────────────────────────────┐   │
│  │   Python AI Server            │   │
│  │  • 데이터 수집                │   │
│  │  • AI 분석 (OpenAI)           │   │
│  │  • 명령 생성                  │   │
│  │  • 상태 관리                  │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
```

---

## 📡 데이터 흐름

### 센서 → AI → 제어 흐름

**1. 센서 데이터 수집 (5초 주기)**

```
헥사보드 센서
  ├─ DHT11: 온도 25°C, 습도 60%
  ├─ 조도 센서: 800
  └─ 타임스탬프: 1234567890

↓ JSON 변환

{
  "board": "A",
  "temperature": 25,
  "humidity": 60,
  "light": 800,
  "timestamp": 1234567890
}

↓ MQTT Publish

Topic: hexaboard/A/sensor/data
```

**2. AI 분석 (10초 주기)**

```
Python Server
  ├─ 최근 10개 데이터 수집
  ├─ 평균 계산
  ├─ OpenAI API 호출
  └─ 무드 판단

↓ 무드 결정

{
  "mood": "Perfect",
  "reason": "온도와 습도가 이상적",
  "recommendation": "현재 상태 유지"
}

↓ LED 명령 생성

{
  "action": "led_color",
  "color": [0, 255, 0],
  "pattern": "solid",
  "brightness": 80
}

↓ MQTT Publish

Topic: hexaboard/A/control/led
```

**3. LED 제어 실행**

```
헥사보드
  ├─ MQTT Subscribe
  ├─ 명령 파싱
  ├─ LED 제어 실행
  └─ 상태 확인 전송

↓ 실행 결과

Topic: hexaboard/A/status
Message: "led_updated"
```

---

## 🔄 상태 다이어그램

### 무드 전환 로직

```
        [Perfect]
         ↙  ↓  ↘
    [Cold] [Good] [Hot]
         ↘  ↓  ↙
        [Humid]
```

**전환 조건**:

```python
if 22 <= temp <= 26 and 40 <= humid <= 60:
    mood = "Perfect"
elif 20 <= temp <= 28 and 35 <= humid <= 65:
    mood = "Good"
elif temp < 20:
    mood = "Cold"
elif temp > 28:
    mood = "Hot"
elif humid > 65:
    mood = "Humid"
```

---

## 📋 Topic 설계

### MQTT Topic 구조

**센서 데이터**:

```
hexaboard/{board_id}/sensor/data
  → {"temperature": 25, "humidity": 60, "light": 800}
```

**제어 명령**:

```
hexaboard/{board_id}/control/led
  → {"action": "led_color", "color": [0, 255, 0]}
```

**상태 업데이트**:

```
hexaboard/{board_id}/status
  → "online" | "offline" | "led_updated"
```

**AI 분석 결과** (선택):

```
hexaboard/{board_id}/analysis
  → {"mood": "Perfect", "reason": "..."}
```

---

## 🗂️ 데이터 모델

### 센서 데이터 모델

```python
SensorData = {
    "board": str,           # 보드 ID (예: "A")
    "temperature": float,   # 온도 (°C)
    "humidity": float,      # 습도 (%)
    "light": int,           # 조도 (0-4095)
    "timestamp": int        # Unix timestamp
}
```

### 무드 분석 모델

```python
MoodAnalysis = {
    "mood": str,            # "Perfect" | "Good" | "Cold" | "Hot" | "Humid"
    "score": float,         # 0.0-1.0 (환경 품질 점수)
    "reason": str,          # 무드 판단 이유
    "recommendation": str,  # 권장 조치
    "timestamp": int
}
```

### LED 제어 모델

```python
LEDCommand = {
    "action": str,          # "led_color" | "led_pattern" | "led_off"
    "color": [int, int, int],  # RGB (0-255)
    "pattern": str,         # "solid" | "blink" | "pulse"
    "brightness": int,      # 0-100 (%)
    "duration": int         # 지속 시간 (초, 선택)
}
```

---

## 🔌 컴포넌트 인터페이스

### 헥사보드 인터페이스

**입력 (Subscribe)**:

- `hexaboard/A/control/led` - LED 제어 명령
- `hexaboard/A/control/mode` - 모드 변경 (선택)

**출력 (Publish)**:

- `hexaboard/A/sensor/data` - 센서 데이터 (5초마다)
- `hexaboard/A/status` - 상태 정보

**API (함수)**:

```python
def read_sensors() -> SensorData
def set_led(color: tuple, pattern: str) -> bool
def get_status() -> str
```

### Python AI Server 인터페이스

**입력 (Subscribe)**:

- `hexaboard/+/sensor/data` - 모든 보드 센서 데이터

**출력 (Publish)**:

- `hexaboard/{id}/control/led` - LED 제어 명령
- `hexaboard/{id}/analysis` - 분석 결과 (선택)

**API (함수)**:

```python
def analyze_environment(data: SensorData) -> MoodAnalysis
def generate_command(mood: MoodAnalysis) -> LEDCommand
def send_command(board_id: str, cmd: LEDCommand) -> bool
```

---

## ⚙️ 설정 파일 구조

### 환경 변수 (.env)

```bash
# MQTT 설정
MQTT_BROKER=abc123.s1.eu.hivemq.cloud
MQTT_PORT=8883
MQTT_USER=hexaboard
MQTT_PASSWORD=your_password

# OpenAI 설정
OPENAI_API_KEY=sk-proj-XXXX

# 시스템 설정
BOARD_ID=A
SENSOR_INTERVAL=5
CONTROL_INTERVAL=10

# 무드 임계값
TEMP_MIN_PERFECT=22
TEMP_MAX_PERFECT=26
HUMID_MIN_PERFECT=40
HUMID_MAX_PERFECT=60
```

### 무드 설정 (config.json)

```json
{
  "moods": {
    "Perfect": {
      "color": [0, 255, 0],
      "pattern": "solid",
      "brightness": 80,
      "conditions": {
        "temp_min": 22,
        "temp_max": 26,
        "humid_min": 40,
        "humid_max": 60
      }
    },
    "Good": {
      "color": [255, 255, 0],
      "pattern": "solid",
      "brightness": 70
    },
    "Cold": {
      "color": [0, 0, 255],
      "pattern": "blink",
      "brightness": 60
    },
    "Hot": {
      "color": [255, 0, 0],
      "pattern": "blink",
      "brightness": 60
    },
    "Humid": {
      "color": [128, 0, 255],
      "pattern": "pulse",
      "brightness": 70
    }
  }
}
```

---

## 🛡️ 에러 처리 전략

### 센서 오류

```python
try:
    sensor.measure()
    temp = sensor.temperature()
except:
    temp = None  # 이전 값 사용 또는 기본값
    log_error("Sensor read failed")
```

### MQTT 연결 끊김

```python
def on_disconnect(client, userdata, rc):
    while True:
        try:
            client.reconnect()
            break
        except:
            time.sleep(5)  # 5초 후 재시도
```

### AI API 오류

```python
try:
    analysis = call_openai_api(data)
except:
    # 규칙 기반 폴백
    analysis = rule_based_analysis(data)
```

---

## 📊 성능 요구사항

### 응답 시간

| 작업          | 목표 시간 | 최대 시간 |
| ------------- | --------- | --------- |
| 센서 읽기     | 0.1초     | 0.5초     |
| MQTT 전송     | 0.2초     | 1초       |
| AI 분석       | 1초       | 3초       |
| LED 제어      | 0.1초     | 0.3초     |
| **전체 흐름** | **2초**   | **5초**   |

### 리소스 사용

- **메모리**: 헥사보드 < 50KB, Python < 100MB
- **네트워크**: < 1KB/초 (평균)
- **CPU**: 헥사보드 < 20%, Python < 30%

---

## 🔐 보안 고려사항

### 통신 보안

- ✅ MQTT over TLS (포트 8883)
- ✅ Username/Password 인증
- ✅ API 키 환경 변수 관리

### 데이터 프라이버시

- ✅ 개인 정보 미포함
- ✅ 로컬 처리 우선
- ✅ 데이터 보관 기간 제한

---

## 📝 핵심 정리

### 아키텍처 원칙

1. **모듈화**: 각 컴포넌트 독립적
2. **확장성**: 새로운 보드 추가 용이
3. **신뢰성**: 에러 처리 및 폴백
4. **효율성**: 리소스 최소화
5. **보안성**: TLS 및 인증

### 데이터 흐름

```
센서(5초) → MQTT → AI 분석(10초) → 명령 생성 → MQTT → LED 제어
```

---

## ❓ 자주 묻는 질문

### Q1. 왜 10초마다 AI 분석하나요?

**A**: 비용 절감과 성능 균형. 환경은 빠르게 변하지 않으므로 10초면 충분합니다.

### Q2. 헥사보드가 오프라인이 되면?

**A**: 마지막 명령 상태 유지. 재연결 시 자동으로 다시 동기화됩니다.

### Q3. 여러 보드를 동시에 제어할 수 있나요?

**A**: 네. Board ID로 구분하여 각각 독립적으로 제어 가능합니다.

---

## 🚀 다음 단계

시스템 아키텍처 설계가 완료되었습니다!

**다음 챕터에서는**:

- 실제 코드 구현
- 단계별 통합
- 테스트 및 디버깅

---

**🎉 Chapter 21 완료!**  
이제 실제 구현을 시작할 준비가 되었습니다!

# Chapter 22. 단계별 구현 실습

> **PART 6**: 종합 프로젝트 – AI 환경 무드 컨트롤러

---

## 📚 이 챕터에서 배울 내용

- [ ] 헥사보드 센서 수집 코드를 작성한다
- [ ] Python AI 서버를 구현한다
- [ ] 전체 시스템을 통합하고 테스트한다

**예상 소요 시간**: 90분

---

## 🎯 학습 목표

### 구현 단계

1. **Phase 1**: 헥사보드 센서 + MQTT (30분)
2. **Phase 2**: Python AI 서버 (30분)
3. **Phase 3**: 통합 및 테스트 (30분)

---

## 💻 Phase 1: 헥사보드 구현

### Step 1: 센서 수집 및 전송

**코드**:

```python
# 파일명: mood_controller_hexaboard.py
# 헥사보드 - AI 무드 컨트롤러

import network
from umqtt.simple import MQTTClient
from machine import Pin
import neopixel
import dht
import time
import ujson

# Wi-Fi 설정
WIFI_SSID = "Your_WiFi_Name"
WIFI_PASSWORD = "Your_Password"

# MQTT 설정
MQTT_BROKER = "abc123.s1.eu.hivemq.cloud"
MQTT_PORT = 8883
MQTT_USER = "hexaboard"
MQTT_PASSWORD = "your_password"
BOARD_ID = "A"

# Topic
TOPIC_SENSOR = f"hexaboard/{BOARD_ID}/sensor/data"
TOPIC_CONTROL = f"hexaboard/{BOARD_ID}/control/led"
TOPIC_STATUS = f"hexaboard/{BOARD_ID}/status"

# 하드웨어
np = neopixel.NeoPixel(Pin(23), 25)
sensor_temp = dht.DHT11(Pin(32))

def connect_wifi():
    """Wi-Fi 연결"""
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)

    if not wlan.isconnected():
        print("[Hexaboard] Wi-Fi 연결 중...")
        wlan.connect(WIFI_SSID, WIFI_PASSWORD)

        timeout = 10
        while not wlan.isconnected() and timeout > 0:
            time.sleep(1)
            timeout -= 1

    if wlan.isconnected():
        print(f"[Hexaboard] ✅ Wi-Fi 연결: {wlan.ifconfig()[0]}")
        return True
    return False

def on_control_message(topic, msg):
    """LED 제어 명령 수신"""
    print(f"[Hexaboard] 📥 제어 명령: {msg}")

    try:
        cmd = ujson.loads(msg)
        action = cmd.get("action")

        if action == "led_color":
            color = cmd.get("color", [0, 0, 0])
            pattern = cmd.get("pattern", "solid")
            brightness = cmd.get("brightness", 100)

            # 밝기 조정
            adjusted_color = tuple(int(c * brightness / 100) for c in color)

            # LED 제어
            if pattern == "solid":
                set_led_solid(adjusted_color)
            elif pattern == "blink":
                set_led_blink(adjusted_color)
            elif pattern == "pulse":
                set_led_pulse(adjusted_color)

            print(f"[Hexaboard] 💡 LED: {color}, {pattern}")

        elif action == "led_off":
            set_led_solid((0, 0, 0))
            print("[Hexaboard] 💡 LED OFF")

    except Exception as e:
        print(f"[Hexaboard] ❌ 제어 오류: {e}")

def set_led_solid(color):
    """LED 단색"""
    for i in range(25):
        np[i] = color
    np.write()

def set_led_blink(color):
    """LED 깜빡임 (비동기)"""
    # 간단 구현: 3번 깜빡임
    for _ in range(3):
        set_led_solid(color)
        time.sleep(0.2)
        set_led_solid((0, 0, 0))
        time.sleep(0.2)
    set_led_solid(color)

def set_led_pulse(color):
    """LED 펄스 (간단 버전)"""
    # 밝기 변화
    for brightness in range(30, 101, 10):
        adjusted = tuple(int(c * brightness / 100) for c in color)
        set_led_solid(adjusted)
        time.sleep(0.05)

def connect_mqtt():
    """MQTT 연결"""
    try:
        client = MQTTClient(
            client_id=f"hexaboard_{BOARD_ID}",
            server=MQTT_BROKER,
            port=MQTT_PORT,
            user=MQTT_USER,
            password=MQTT_PASSWORD,
            ssl=True
        )

        client.set_callback(on_control_message)
        client.connect()
        client.subscribe(TOPIC_CONTROL)

        # 온라인 상태 전송
        client.publish(TOPIC_STATUS, "online")

        print("[Hexaboard] ✅ MQTT 연결")
        print(f"[Hexaboard] 📬 구독: {TOPIC_CONTROL}")

        return client

    except Exception as e:
        print(f"[Hexaboard] ❌ MQTT 연결 실패: {e}")
        return None

def read_and_publish_sensors(client):
    """센서 읽고 전송"""
    try:
        sensor_temp.measure()
        temp = sensor_temp.temperature()
        humid = sensor_temp.humidity()

        # 조도 센서 (ADC) - 선택사항
        # light_sensor = ADC(Pin(33))
        # light = light_sensor.read()
        light = 800  # 가상 값

        data = {
            "board": BOARD_ID,
            "temperature": temp,
            "humidity": humid,
            "light": light,
            "timestamp": time.time()
        }

        message = ujson.dumps(data)
        client.publish(TOPIC_SENSOR, message)

        print(f"[Hexaboard] 📤 센서: {temp}°C, {humid}%")

    except Exception as e:
        print(f"[Hexaboard] ❌ 센서 오류: {e}")

# 메인 실행
if connect_wifi():
    client = connect_mqtt()

    if client:
        print("\n[Hexaboard] 🚀 무드 컨트롤러 시작\n")

        last_sensor_time = 0
        SENSOR_INTERVAL = 5  # 5초

        try:
            while True:
                # 제어 명령 확인
                client.check_msg()

                # 5초마다 센서 데이터 전송
                current_time = time.time()
                if current_time - last_sensor_time >= SENSOR_INTERVAL:
                    read_and_publish_sensors(client)
                    last_sensor_time = current_time

                time.sleep(0.1)

        except KeyboardInterrupt:
            print("\n[Hexaboard] 종료")
            client.publish(TOPIC_STATUS, "offline")

        finally:
            client.disconnect()
```

**실행**: Thonny IDE에서 헥사보드에 업로드 및 실행

---

## 💻 Phase 2: Python AI 서버 구현

### Step 2: 무드 컨트롤러 서버

**코드**:

````python
# 파일명: mood_controller_server.py
# Python AI 서버 - 무드 컨트롤러

import paho.mqtt.client as mqtt
from openai import OpenAI
from dotenv import load_dotenv
import os
import json
from datetime import datetime
from collections import deque
import time

load_dotenv()

# MQTT 설정
MQTT_BROKER = os.getenv("MQTT_BROKER")
MQTT_PORT = int(os.getenv("MQTT_PORT", 8883))
MQTT_USER = os.getenv("MQTT_USER")
MQTT_PASSWORD = os.getenv("MQTT_PASSWORD")

# OpenAI 클라이언트
openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Topic
TOPIC_SENSOR = "hexaboard/+/sensor/data"
TOPIC_CONTROL = "hexaboard/{board}/control/led"

# 데이터 버퍼 (보드별)
sensor_buffers = {}
last_control_time = {}
CONTROL_INTERVAL = 10  # 10초

# 무드 설정
MOOD_CONFIG = {
    "Perfect": {
        "color": [0, 255, 0],
        "pattern": "solid",
        "brightness": 80
    },
    "Good": {
        "color": [255, 255, 0],
        "pattern": "solid",
        "brightness": 70
    },
    "Cold": {
        "color": [0, 0, 255],
        "pattern": "blink",
        "brightness": 60
    },
    "Hot": {
        "color": [255, 0, 0],
        "pattern": "blink",
        "brightness": 60
    },
    "Humid": {
        "color": [128, 0, 255],
        "pattern": "pulse",
        "brightness": 70
    }
}

class MoodController:
    """무드 컨트롤러"""

    def __init__(self, mqtt_client):
        self.mqtt_client = mqtt_client

    def analyze_mood_rule_based(self, temp, humid):
        """규칙 기반 무드 판단"""
        if 22 <= temp <= 26 and 40 <= humid <= 60:
            return "Perfect"
        elif 20 <= temp <= 28 and 35 <= humid <= 65:
            return "Good"
        elif temp < 20:
            return "Cold"
        elif temp > 28:
            return "Hot"
        elif humid > 65:
            return "Humid"
        else:
            return "Good"

    def analyze_mood_with_ai(self, temp, humid):
        """AI 기반 무드 판단"""
        try:
            prompt = f"""
환경 데이터:
- 온도: {temp}°C
- 습도: {humid}%

다음 5가지 무드 중 하나를 선택하세요:
- Perfect: 완벽한 환경 (22-26°C, 40-60%)
- Good: 좋은 환경
- Cold: 추운 환경 (< 20°C)
- Hot: 더운 환경 (> 28°C)
- Humid: 습한 환경 (> 65%)

JSON 형식으로 응답:
{{"mood": "무드", "reason": "이유 (한 문장)"}}
"""

            response = openai_client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": "환경 분석 전문가. JSON만 출력."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=100,
                temperature=0.3
            )

            result_str = response.choices[0].message.content.strip()
            if "```" in result_str:
                result_str = result_str.split("```")[1].replace("json", "").strip()

            result = json.loads(result_str)
            return result.get("mood", "Good"), result.get("reason", "")

        except Exception as e:
            print(f"   AI 오류: {e}, 규칙 기반 사용")
            mood = self.analyze_mood_rule_based(temp, humid)
            return mood, "규칙 기반 판단"

    def generate_led_command(self, mood):
        """무드에 따른 LED 명령 생성"""
        config = MOOD_CONFIG.get(mood, MOOD_CONFIG["Good"])

        return {
            "action": "led_color",
            "color": config["color"],
            "pattern": config["pattern"],
            "brightness": config["brightness"]
        }

    def control_board(self, board_id, temp, humid):
        """보드 제어"""
        global last_control_time

        # 제어 간격 확인
        current_time = time.time()
        if board_id in last_control_time:
            if current_time - last_control_time[board_id] < CONTROL_INTERVAL:
                return

        print(f"\n{'='*60}")
        print(f"🤖 무드 분석 (보드 {board_id})")
        print(f"{'='*60}")
        print(f"📊 환경: {temp}°C, {humid}%")

        # AI 분석
        mood, reason = self.analyze_mood_with_ai(temp, humid)
        print(f"💡 무드: {mood}")
        print(f"📝 이유: {reason}")

        # LED 명령 생성
        cmd = self.generate_led_command(mood)

        # 전송
        topic = TOPIC_CONTROL.format(board=board_id)
        message = json.dumps(cmd)
        self.mqtt_client.publish(topic, message)

        print(f"📤 제어: {cmd['color']} ({cmd['pattern']})")
        print(f"{'='*60}\n")

        last_control_time[board_id] = current_time

# MQTT 콜백
mood_controller = None

def on_connect(client, userdata, flags, rc):
    """연결 성공"""
    if rc == 0:
        print("✅ MQTT 연결 성공!")
        client.subscribe(TOPIC_SENSOR)
        print(f"📬 구독: {TOPIC_SENSOR}")
        print(f"⏰ 제어 간격: {CONTROL_INTERVAL}초\n")

def on_message(client, userdata, msg):
    """센서 데이터 수신"""
    try:
        data = json.loads(msg.payload.decode())
        board_id = data.get("board", "Unknown")
        temp = data.get("temperature")
        humid = data.get("humidity")

        # 데이터 버퍼에 저장
        if board_id not in sensor_buffers:
            sensor_buffers[board_id] = deque(maxlen=10)

        sensor_buffers[board_id].append({
            "temp": temp,
            "humid": humid,
            "time": datetime.now()
        })

        # 로그
        time_str = datetime.now().strftime("%H:%M:%S")
        print(f"[{time_str}] 📥 보드 {board_id}: {temp}°C, {humid}%")

        # 무드 분석 및 제어
        if mood_controller:
            mood_controller.control_board(board_id, temp, humid)

    except Exception as e:
        print(f"❌ 오류: {e}")

# MQTT 클라이언트
mqtt_client = mqtt.Client()
mqtt_client.tls_set()
mqtt_client.username_pw_set(MQTT_USER, MQTT_PASSWORD)
mqtt_client.on_connect = on_connect
mqtt_client.on_message = on_message

# 무드 컨트롤러 초기화
mood_controller = MoodController(mqtt_client)

# 실행
try:
    mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
    print("🚀 AI 무드 컨트롤러 시작...\n")
    mqtt_client.loop_forever()

except KeyboardInterrupt:
    print("\n\n🛑 서버 종료")
    mqtt_client.disconnect()
````

**실행**:

```bash
python mood_controller_server.py
```

---

## 🧪 Phase 3: 통합 및 테스트

### Step 3: 전체 시스템 테스트

**테스트 시나리오**:

#### 시나리오 1: Perfect 무드

```
조건: 온도 24°C, 습도 50%
예상 결과: 초록색 LED (solid)
```

#### 시나리오 2: Hot 무드

```
조건: 온도 30°C, 습도 70%
예상 결과: 빨간색 LED (blink)
```

#### 시나리오 3: Cold 무드

```
조건: 온도 18°C, 습도 35%
예상 결과: 파란색 LED (blink)
```

### 테스트 실행

**1. 헥사보드 시작**:

```
[Hexaboard] ✅ Wi-Fi 연결
[Hexaboard] ✅ MQTT 연결
[Hexaboard] 🚀 무드 컨트롤러 시작
[Hexaboard] 📤 센서: 24°C, 50%
```

**2. Python 서버 시작**:

```
✅ MQTT 연결 성공!
📬 구독: hexaboard/+/sensor/data
🚀 AI 무드 컨트롤러 시작...

[10:30:15] 📥 보드 A: 24°C, 50%

============================================================
🤖 무드 분석 (보드 A)
============================================================
📊 환경: 24°C, 50%
💡 무드: Perfect
📝 이유: 온도와 습도가 이상적인 범위에 있습니다
📤 제어: [0, 255, 0] (solid)
============================================================
```

**3. 헥사보드 LED 변경**:

```
[Hexaboard] 📥 제어 명령: {"action":"led_color","color":[0,255,0],"pattern":"solid","brightness":80}
[Hexaboard] 💡 LED: [0, 255, 0], solid
```

---

## 🐛 디버깅 가이드

### 문제 1: 센서 데이터가 안 보임

**증상**:

```
Python 서버에 데이터가 안 옴
```

**확인 사항**:

1. 헥사보드 Wi-Fi 연결 확인
2. MQTT Broker 주소 확인
3. Topic 이름 일치 확인

**해결**:

```python
# 헥사보드에서 수동 테스트
client.publish("test/topic", "hello")
```

### 문제 2: LED가 안 바뀜

**증상**:

```
명령은 전송되지만 LED 변화 없음
```

**확인 사항**:

1. 헥사보드가 제어 Topic 구독 중인지 확인
2. JSON 형식 확인
3. NeoPixel 핀 번호 확인 (GPIO 23)

**해결**:

```python
# LED 수동 테스트
set_led_solid((255, 0, 0))  # 빨간색
```

### 문제 3: AI가 너무 자주 호출됨

**증상**:

```
OpenAI API 비용 많이 발생
```

**해결**:

```python
# CONTROL_INTERVAL 증가
CONTROL_INTERVAL = 30  # 30초로 변경
```

---

## 📝 핵심 정리

### 구현 체크리스트

- [x] 헥사보드: 센서 수집 + MQTT 전송
- [x] 헥사보드: LED 제어 수신
- [x] Python: MQTT 데이터 수신
- [x] Python: AI 무드 분석
- [x] Python: LED 명령 전송
- [x] 전체: 통합 테스트 완료

### 파일 구조

```
project/
├── mood_controller_hexaboard.py    # 헥사보드 코드
├── mood_controller_server.py       # Python 서버
├── .env                            # 환경 변수
└── config.json                     # 무드 설정 (선택)
```

---

## ❓ 자주 묻는 질문

### Q1. 헥사보드 코드를 자동 시작하려면?

**A**: Thonny에서 파일을 `main.py`로 저장하면 부팅 시 자동 실행됩니다.

### Q2. Python 서버를 백그라운드로 실행하려면?

**A**: `nohup python mood_controller_server.py &` (Linux/Mac)

### Q3. 무드 임계값을 변경하려면?

**A**: `MOOD_CONFIG`나 `config.json`에서 조건 수정

---

## 🚀 다음 단계

기본 시스템 구현이 완료되었습니다!

**다음 챕터에서는**:

- AI 프롬프트 튜닝
- 성능 최적화
- 고급 기능 추가

---

**🎉 Chapter 22 완료!**  
완전한 AI 무드 컨트롤러가 동작합니다!

# Chapter 23. AI 실험과 튜닝

> **PART 6**: 종합 프로젝트 – AI 환경 무드 컨트롤러

---

## 📚 이 챕터에서 배울 내용

- [ ] AI 프롬프트를 최적화할 수 있다
- [ ] 시스템 성능을 개선할 수 있다
- [ ] 고급 기능을 추가할 수 있다

**예상 소요 시간**: 50분

---

## 🎯 학습 목표

### 핵심 개념

- **프롬프트 엔지니어링**: AI 응답 품질 향상
- **성능 최적화**: 응답 시간 및 비용 절감
- **기능 확장**: 새로운 기능 추가

---

## 🔧 프롬프트 최적화

### 기본 프롬프트 (개선 전)

```python
prompt = f"""
온도 {temp}°C, 습도 {humid}%

무드를 판단하세요.
"""
```

**문제점**:

- 불명확한 지시
- 출력 형식 불일치
- 맥락 부족

### 개선된 프롬프트 v1

```python
prompt = f"""
당신은 실내 환경 분석 전문가입니다.

## 현재 환경
- 온도: {temp}°C
- 습도: {humid}%

## 무드 기준
- Perfect: 22-26°C, 40-60% (완벽한 환경)
- Good: 20-28°C, 35-65% (좋은 환경)
- Cold: < 20°C (추운 환경)
- Hot: > 28°C (더운 환경)
- Humid: > 65% (습한 환경)

## 요청
위 기준에 따라 현재 환경의 무드를 판단하고, 간단한 이유를 설명하세요.

## 출력 형식 (JSON만)
{{"mood": "무드", "reason": "이유"}}
"""
```

**개선 사항**:

- 역할 명확화
- 기준 제시
- 출력 형식 지정

### 최적화된 프롬프트 v2

```python
def build_analysis_prompt(temp, humid, history=None):
    """최적화된 프롬프트 생성"""

    prompt = f"""당신은 실내 환경 AI 분석가입니다.

# 현재 센서 데이터
- 온도: {temp}°C
- 습도: {humid}%
"""

    # 히스토리 추가 (선택)
    if history:
        avg_temp = sum(h['temp'] for h in history) / len(history)
        avg_humid = sum(h['humid'] for h in history) / len(history)
        prompt += f"""
# 최근 평균 (10개)
- 평균 온도: {avg_temp:.1f}°C
- 평균 습도: {avg_humid:.1f}%
"""

    prompt += """
# 무드 판단 기준
| 무드 | 온도 | 습도 | 설명 |
|------|------|------|------|
| Perfect | 22-26°C | 40-60% | 이상적 환경 |
| Good | 20-28°C | 35-65% | 쾌적한 환경 |
| Cold | < 20°C | 임의 | 추운 환경 |
| Hot | > 28°C | 임의 | 더운 환경 |
| Humid | 임의 | > 65% | 습한 환경 |

# 지시사항
1. 위 기준에 따라 무드를 정확히 판단하세요
2. 이유는 한 문장으로 간결하게
3. JSON 형식만 출력 (다른 텍스트 없이)

# 출력
{"mood": "무드", "reason": "이유", "recommendation": "권장사항"}
"""

    return prompt
```

**추가 개선**:

- 히스토리 데이터 활용
- 표 형식으로 명확화
- 권장사항 추가

---

## ⚡ 성능 최적화

### 1. 모델 선택

**GPT-4 vs GPT-3.5-turbo**:

| 항목       | GPT-4           | GPT-3.5-turbo    |
| ---------- | --------------- | ---------------- |
| **정확도** | 높음            | 보통             |
| **속도**   | 느림 (2-3초)    | 빠름 (1초)       |
| **비용**   | 비쌈 ($0.03/1K) | 저렴 ($0.001/1K) |
| **추천**   | 복잡한 분석     | 단순한 판단      |

**우리 프로젝트**:

```python
# GPT-3.5-turbo 사용 (충분히 정확하고 빠름)
model="gpt-3.5-turbo"
```

### 2. 토큰 최적화

```python
# 개선 전
max_tokens=500  # 불필요하게 많음

# 개선 후
max_tokens=100  # 충분하고 저렴
```

### 3. 캐싱 전략

```python
# 같은 데이터는 재분석 안 함
last_analysis = {}

def analyze_with_cache(board_id, temp, humid):
    cache_key = f"{board_id}_{temp}_{humid}"

    if cache_key in last_analysis:
        # 10초 이내면 캐시 사용
        if time.time() - last_analysis[cache_key]['time'] < 10:
            return last_analysis[cache_key]['result']

    # AI 분석
    result = call_openai_api(temp, humid)

    # 캐시 저장
    last_analysis[cache_key] = {
        'result': result,
        'time': time.time()
    }

    return result
```

### 4. 규칙 기반 우선

```python
def smart_analyze(temp, humid, use_ai=True):
    """지능형 분석 (규칙 + AI)"""

    # 명확한 경우는 규칙 기반 (빠르고 무료)
    if temp < 18 or temp > 32 or humid > 75:
        return rule_based_analysis(temp, humid)

    # 애매한 경우만 AI 사용
    if use_ai:
        return ai_based_analysis(temp, humid)
    else:
        return rule_based_analysis(temp, humid)
```

---

## 📊 데이터 활용 고급

### 1. 통계 기반 분석

```python
def analyze_with_statistics(board_id):
    """통계 기반 분석"""

    if board_id not in sensor_buffers:
        return None

    data = sensor_buffers[board_id]

    # 통계 계산
    temps = [d['temp'] for d in data]
    humids = [d['humid'] for d in data]

    stats = {
        'temp_avg': sum(temps) / len(temps),
        'temp_min': min(temps),
        'temp_max': max(temps),
        'temp_std': statistics.stdev(temps) if len(temps) > 1 else 0,
        'humid_avg': sum(humids) / len(humids),
        'humid_min': min(humids),
        'humid_max': max(humids)
    }

    # 변화 추세
    if len(temps) >= 5:
        recent_avg = sum(temps[-5:]) / 5
        old_avg = sum(temps[:5]) / 5
        stats['temp_trend'] = recent_avg - old_avg

    return stats
```

### 2. 트렌드 감지

```python
def detect_trend(board_id):
    """환경 트렌드 감지"""

    stats = analyze_with_statistics(board_id)

    if not stats:
        return None

    # 온도 상승 중
    if stats.get('temp_trend', 0) > 2:
        return {
            'trend': 'heating',
            'message': '온도가 상승 중입니다. 환기를 고려하세요.'
        }

    # 온도 하강 중
    elif stats.get('temp_trend', 0) < -2:
        return {
            'trend': 'cooling',
            'message': '온도가 하강 중입니다. 난방을 고려하세요.'
        }

    # 안정
    else:
        return {
            'trend': 'stable',
            'message': '환경이 안정적입니다.'
        }
```

---

## 🎨 고급 LED 패턴

### 1. 부드러운 전환

```python
def set_led_smooth_transition(from_color, to_color, steps=20):
    """부드러운 색상 전환"""

    for i in range(steps):
        # 중간 색상 계산
        progress = i / steps
        r = int(from_color[0] + (to_color[0] - from_color[0]) * progress)
        g = int(from_color[1] + (to_color[1] - from_color[1]) * progress)
        b = int(from_color[2] + (to_color[2] - from_color[2]) * progress)

        # LED 설정
        for j in range(25):
            np[j] = (r, g, b)
        np.write()

        time.sleep(0.05)
```

### 2. 그라데이션

```python
def set_led_gradient(color1, color2):
    """세로 그라데이션"""

    for row in range(5):
        progress = row / 4
        r = int(color1[0] + (color2[0] - color1[0]) * progress)
        g = int(color1[1] + (color2[1] - color1[1]) * progress)
        b = int(color1[2] + (color2[2] - color1[2]) * progress)

        # 해당 행의 LED 설정
        for col in range(5):
            idx = row * 5 + col
            np[idx] = (r, g, b)

    np.write()
```

### 3. 무드별 애니메이션

```python
def animate_mood(mood):
    """무드별 애니메이션"""

    if mood == "Perfect":
        # 초록색 펄스
        for brightness in range(50, 101, 10):
            color = (0, int(255 * brightness / 100), 0)
            set_led_solid(color)
            time.sleep(0.1)

    elif mood == "Hot":
        # 빨간색 깜빡임
        for _ in range(5):
            set_led_solid((255, 0, 0))
            time.sleep(0.2)
            set_led_solid((100, 0, 0))
            time.sleep(0.2)

    elif mood == "Cold":
        # 파란색 웨이브
        for offset in range(5):
            for i in range(25):
                if (i + offset) % 5 == 0:
                    np[i] = (0, 0, 255)
                else:
                    np[i] = (0, 0, 50)
            np.write()
            time.sleep(0.1)
```

---

## 🚀 추가 기능 구현

### 1. 알림 시스템

```python
class NotificationSystem:
    """알림 시스템"""

    def __init__(self):
        self.last_notification = {}
        self.NOTIFICATION_INTERVAL = 300  # 5분

    def should_notify(self, board_id, condition):
        """알림 필요 여부"""

        key = f"{board_id}_{condition}"
        current_time = time.time()

        if key not in self.last_notification:
            self.last_notification[key] = 0

        # 5분 이상 지났으면 알림
        if current_time - self.last_notification[key] > self.NOTIFICATION_INTERVAL:
            self.last_notification[key] = current_time
            return True

        return False

    def send_notification(self, board_id, message):
        """알림 전송"""
        print(f"\n🔔 [알림] 보드 {board_id}: {message}\n")

        # 실제로는 이메일, Slack, 카카오톡 등으로 전송 가능
```

### 2. 데이터 로깅

```python
import csv
from datetime import datetime

class DataLogger:
    """데이터 로거"""

    def __init__(self, filename="sensor_log.csv"):
        self.filename = filename
        self.init_csv()

    def init_csv(self):
        """CSV 파일 초기화"""
        with open(self.filename, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([
                'Timestamp', 'Board', 'Temperature', 'Humidity',
                'Light', 'Mood', 'Action'
            ])

    def log(self, board_id, temp, humid, light, mood, action):
        """데이터 로그"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        with open(self.filename, 'a', newline='') as f:
            writer = csv.writer(f)
            writer.writerow([
                timestamp, board_id, temp, humid, light, mood, action
            ])
```

### 3. 웹 API (선택)

```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/api/status/<board_id>')
def get_status(board_id):
    """보드 상태 API"""

    if board_id in sensor_buffers:
        latest = sensor_buffers[board_id][-1]
        return jsonify({
            'board': board_id,
            'temperature': latest['temp'],
            'humidity': latest['humid'],
            'mood': latest.get('mood', 'Unknown'),
            'timestamp': latest['time'].isoformat()
        })
    else:
        return jsonify({'error': 'Board not found'}), 404

@app.route('/api/history/<board_id>')
def get_history(board_id):
    """히스토리 API"""

    if board_id in sensor_buffers:
        history = list(sensor_buffers[board_id])
        return jsonify({
            'board': board_id,
            'count': len(history),
            'data': history
        })
    else:
        return jsonify({'error': 'Board not found'}), 404

# Flask 서버 실행 (백그라운드)
# app.run(host='0.0.0.0', port=5000)
```

---

## 📊 실험 및 A/B 테스트

### 실험 1: 모델 비교

```python
def compare_models(temp, humid):
    """GPT-4 vs GPT-3.5 비교"""

    import time

    # GPT-4
    start = time.time()
    result_gpt4 = call_openai("gpt-4", temp, humid)
    time_gpt4 = time.time() - start

    # GPT-3.5
    start = time.time()
    result_gpt35 = call_openai("gpt-3.5-turbo", temp, humid)
    time_gpt35 = time.time() - start

    print(f"GPT-4: {result_gpt4['mood']} ({time_gpt4:.2f}s)")
    print(f"GPT-3.5: {result_gpt35['mood']} ({time_gpt35:.2f}s)")
```

### 실험 2: 프롬프트 A/B 테스트

```python
def test_prompts(temp, humid):
    """다양한 프롬프트 테스트"""

    prompts = {
        "basic": "온도 {temp}°C, 습도 {humid}%. 무드는?",
        "detailed": build_analysis_prompt(temp, humid, None),
        "with_history": build_analysis_prompt(temp, humid, history)
    }

    for name, prompt in prompts.items():
        result = call_openai_with_prompt(prompt)
        print(f"{name}: {result['mood']}")
```

---

## 📝 핵심 정리

### 최적화 체크리스트

- [x] GPT-3.5-turbo 사용 (비용 절감)
- [x] max_tokens 최소화
- [x] 캐싱 적용
- [x] 규칙 기반 우선
- [x] 명확한 프롬프트
- [x] 데이터 로깅
- [x] 에러 처리 강화

### 성능 개선 결과

| 항목            | 개선 전  | 개선 후   |
| --------------- | -------- | --------- |
| **응답 시간**   | 3초      | 1초       |
| **API 비용**    | $0.03/회 | $0.001/회 |
| **정확도**      | 95%      | 93%       |
| **캐시 히트율** | 0%       | 60%       |

---

## ❓ 자주 묻는 질문

### Q1. AI 없이도 동작하나요?

**A**: 네. 규칙 기반 폴백이 있어 AI 없이도 기본 기능 동작합니다.

### Q2. 비용을 더 줄이려면?

**A**: 제어 간격 늘리기 (10초 → 30초), 규칙 기반 우선 사용

### Q3. 정확도를 높이려면?

**A**: GPT-4 사용, 프롬프트 상세화, 히스토리 데이터 활용

---

## 🚀 다음 단계

AI 무드 컨트롤러를 완성했습니다!

**추가로 시도해볼 것**:

- 여러 방 동시 모니터링
- 스마트폰 앱 연동
- 음성 제어 추가
- 에너지 절약 모드

**다음 PART에서는**:

- 웹 대시보드 구축
- 실시간 모니터링
- 원격 제어

---

**🎉 Chapter 23 완료!**  
**🎉 PART 6 완료!**

AI 무드 컨트롤러가 완전히 최적화되고 확장되었습니다!

# Chapter 24. 웹에서 센서 상태 모니터링하기

> **PART 7**: 웹 기반 AI 제어 대시보드

---

## 📚 이 챕터에서 배울 내용

- [ ] HTML로 웹 페이지를 만들 수 있다
- [ ] MQTT.js로 브라우저에서 센서 데이터를 받을 수 있다
- [ ] 실시간으로 데이터를 화면에 표시할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 웹 대시보드란?

**브라우저에서 헥사보드 센서를 실시간으로 모니터링하는 웹 페이지**

```
헥사보드 센서 → MQTT Broker → 웹 브라우저 (MQTT.js)
```

**장점**:

- ✅ 어디서나 접속 가능 (스마트폰, 태블릿, PC)
- ✅ 서버 불필요 (HTML 파일만으로 동작)
- ✅ 실시간 업데이트
- ✅ 직관적인 UI

---

## 🛠️ 필요한 것

### 소프트웨어

- [x] 웹 브라우저 (Chrome, Safari, Firefox)
- [x] 텍스트 에디터 (VS Code 추천)
- [x] MQTT.js 라이브러리 (CDN 사용)

### 사전 지식

- HTML 기초 (태그, 구조)
- JavaScript 기초 (변수, 함수)
- MQTT 개념 (PART 4)

---

## 💻 실습 1: 기본 웹 페이지 만들기

### Step 1: HTML 기본 구조 (Tailwind CSS)

**Tailwind CSS 사용의 장점**:

- ✅ CDN으로 간단하게 추가
- ✅ Utility-First 클래스로 빠른 개발
- ✅ 반응형 디자인 쉬움
- ✅ 별도 CSS 파일 불필요

**코드**:

```html
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>헥사보드 센서 모니터</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: "#667eea",
              secondary: "#764ba2",
            },
          },
        },
      };
    </script>
  </head>
  <body class="bg-gradient-to-br from-primary to-secondary min-h-screen p-6">
    <div class="max-w-4xl mx-auto">
      <!-- 헤더 -->
      <div class="text-center text-white mb-8">
        <h1 class="text-4xl md:text-5xl font-bold mb-4">
          🎛️ 헥사보드 센서 모니터
        </h1>
        <div
          id="status"
          class="inline-block px-4 py-2 rounded-full text-sm font-bold bg-red-500 text-white"
        >
          연결 대기 중...
        </div>
      </div>

      <!-- 센서 데이터 카드 -->
      <div class="bg-white rounded-2xl shadow-2xl p-8 mb-6">
        <h2 class="text-2xl font-bold text-gray-800 mb-6">
          📊 실시간 센서 데이터
        </h2>
        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
          <!-- 온도 -->
          <div
            class="bg-gradient-to-br from-blue-50 to-blue-100 rounded-xl p-6 text-center"
          >
            <div class="text-5xl mb-3">🌡️</div>
            <div class="text-sm text-gray-600 mb-2">온도</div>
            <div class="text-3xl font-bold text-gray-800">
              <span id="temp">--</span
              ><span class="text-lg text-gray-500">°C</span>
            </div>
          </div>

          <!-- 습도 -->
          <div
            class="bg-gradient-to-br from-cyan-50 to-cyan-100 rounded-xl p-6 text-center"
          >
            <div class="text-5xl mb-3">💧</div>
            <div class="text-sm text-gray-600 mb-2">습도</div>
            <div class="text-3xl font-bold text-gray-800">
              <span id="humid">--</span
              ><span class="text-lg text-gray-500">%</span>
            </div>
          </div>

          <!-- 조도 -->
          <div
            class="bg-gradient-to-br from-yellow-50 to-yellow-100 rounded-xl p-6 text-center"
          >
            <div class="text-5xl mb-3">💡</div>
            <div class="text-sm text-gray-600 mb-2">조도</div>
            <div class="text-3xl font-bold text-gray-800" id="light">--</div>
          </div>
        </div>
      </div>

      <!-- 로그 카드 -->
      <div class="bg-white rounded-2xl shadow-2xl p-8">
        <h2 class="text-2xl font-bold text-gray-800 mb-4">📝 데이터 로그</h2>
        <div
          id="log"
          class="bg-gray-50 rounded-lg p-4 max-h-64 overflow-y-auto font-mono text-sm space-y-2"
        >
          <div class="border-b border-gray-200 pb-2">
            <span class="text-gray-400">--:--:--</span>
            <span class="ml-3">연결 대기 중...</span>
          </div>
        </div>
      </div>
    </div>

    <!-- 다음 단계에서 JavaScript 추가 -->
  </body>
</html>
```

**Tailwind CSS 주요 클래스 설명**:

| 클래스                      | 설명                   |
| --------------------------- | ---------------------- |
| `bg-gradient-to-br`         | 대각선 그라디언트 배경 |
| `from-primary to-secondary` | 커스텀 색상 (보라색)   |
| `rounded-2xl`               | 둥근 모서리 (큰 크기)  |
| `shadow-2xl`                | 큰 그림자 효과         |
| `grid grid-cols-3`          | 3열 그리드 레이아웃    |
| `md:grid-cols-3`            | 중간 화면 이상에서 3열 |
| `gap-6`                     | 그리드 간격            |

**파일명**: `hexaboard_monitor.html`

**실행**: 웹 브라우저에서 파일 열기

---

## 💻 실습 2: MQTT 연결하기

### Step 2: MQTT.js 추가

**HTML에 추가** (`</body>` 앞에):

```html
<!-- MQTT.js 라이브러리 -->
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

<script>
  // MQTT 설정
  const MQTT_BROKER = "wss://abc123.s1.eu.hivemq.cloud:8884/mqtt";
  const MQTT_USER = "hexaboard";
  const MQTT_PASSWORD = "your_password";
  const TOPIC_SENSOR = "hexaboard/+/sensor/data";

  // MQTT 클라이언트
  const client = mqtt.connect(MQTT_BROKER, {
    username: MQTT_USER,
    password: MQTT_PASSWORD,
    clientId: "web_monitor_" + Math.random().toString(16).substr(2, 8),
  });

  // 연결 성공
  client.on("connect", function () {
    console.log("✅ MQTT 연결 성공!");
    updateStatus(true);
    addLog("MQTT Broker에 연결되었습니다.");

    client.subscribe(TOPIC_SENSOR, function (err) {
      if (!err) {
        addLog(`구독 시작: ${TOPIC_SENSOR}`);
      }
    });
  });

  // 메시지 수신
  client.on("message", function (topic, message) {
    try {
      const data = JSON.parse(message.toString());
      updateSensorData(data);
      addLog(`센서 데이터: ${data.temperature}°C, ${data.humidity}%`);
    } catch (e) {
      console.error("파싱 오류:", e);
    }
  });

  // 연결 끊김
  client.on("close", function () {
    console.log("❌ MQTT 연결 끊김");
    updateStatus(false);
    addLog("연결이 끊어졌습니다.");
  });

  // UI 업데이트
  function updateStatus(connected) {
    const statusEl = document.getElementById("status");
    if (connected) {
      statusEl.textContent = "연결됨";
      statusEl.className =
        "inline-block px-4 py-2 rounded-full text-sm font-bold bg-green-400 text-green-900";
    } else {
      statusEl.textContent = "연결 끊김";
      statusEl.className =
        "inline-block px-4 py-2 rounded-full text-sm font-bold bg-red-500 text-white";
    }
  }

  function updateSensorData(data) {
    document.getElementById("temp").textContent = data.temperature;
    document.getElementById("humid").textContent = data.humidity;
    document.getElementById("light").textContent = data.light || "--";
  }

  function addLog(message) {
    const logEl = document.getElementById("log");
    const time = new Date().toLocaleTimeString("ko-KR");

    const logItem = document.createElement("div");
    logItem.className = "border-b border-gray-200 pb-2";
    logItem.innerHTML = `<span class="text-gray-400">${time}</span><span class="ml-3">${message}</span>`;

    logEl.insertBefore(logItem, logEl.firstChild);

    while (logEl.children.length > 20) {
      logEl.removeChild(logEl.lastChild);
    }
  }
</script>
```

**Tailwind CSS 클래스 적용**:

- **연결 상태**: `bg-green-400 text-green-900` (연결됨), `bg-red-500 text-white` (끊김)
- **로그 아이템**: `border-b border-gray-200 pb-2` (하단 테두리)
- **시간**: `text-gray-400` (회색 텍스트)

**설정 수정**:

```javascript
// 본인의 HiveMQ Cloud 정보로 변경
const MQTT_BROKER = "wss://YOUR_BROKER.s1.eu.hivemq.cloud:8884/mqtt";
const MQTT_USER = "your_username";
const MQTT_PASSWORD = "your_password";
```

**⚠️ 중요**: HiveMQ Cloud에서 WebSocket 포트는 **8884**입니다!

---

## 💻 실습 3: 완성된 대시보드 (Tailwind CSS)

### 전체 코드

**파일명**: `hexaboard_monitor_tailwind.html`

이제 Tailwind CSS를 사용한 완전한 버전입니다. 파일은 `code/web/ch24_monitor_tailwind.html`에서 확인할 수 있습니다.

**실행 방법**:

1. 파일을 저장
2. 웹 브라우저에서 열기
3. MQTT 설정 (본인의 HiveMQ Cloud 정보로 변경)
4. 헥사보드가 센서 데이터를 보내면 자동으로 업데이트됨

**화면 구성**:

- 📊 **헤더**: 타이틀 + 연결 상태
- 🎨 **센서 카드**: 3개의 센서 데이터 (온도, 습도, 조도)
- 📝 **로그 카드**: 최근 20개의 이벤트 로그

**반응형 디자인**:

- **모바일**: 1열 레이아웃
- **태블릿 이상**: 3열 그리드 레이아웃

---

## 🔧 HiveMQ Cloud WebSocket 설정

### HiveMQ Cloud에서 WebSocket 활성화

1. **HiveMQ Cloud 대시보드 접속**
2. **Cluster 선택**
3. **Overview → WebSocket** 확인
   - WebSocket 포트: **8884**
   - URL 형식: `wss://your-cluster.s1.eu.hivemq.cloud:8884/mqtt`

**중요**: 일반 MQTT 포트(8883)와 WebSocket 포트(8884)는 다릅니다!

---

## 📝 핵심 정리

### 주요 개념

1. **WebSocket (wss://)**: 브라우저와 MQTT Broker 간 실시간 통신
2. **MQTT.js**: 브라우저에서 MQTT 사용 가능한 JavaScript 라이브러리
3. **실시간 UI**: 센서 데이터 수신 시 자동 화면 업데이트

### 코드 구조

```javascript
// 1. MQTT 연결
const client = mqtt.connect(BROKER, options);

// 2. 연결 성공 시
client.on("connect", () => {
  client.subscribe(TOPIC);
});

// 3. 메시지 수신 시
client.on("message", (topic, message) => {
  const data = JSON.parse(message);
  updateUI(data);
});
```

### Tailwind CSS 주요 클래스

| 용도       | 클래스                                        | 설명                    |
| ---------- | --------------------------------------------- | ----------------------- |
| **배경**   | `bg-gradient-to-br from-primary to-secondary` | 그라디언트 배경         |
| **카드**   | `bg-white rounded-2xl shadow-2xl`             | 흰색 둥근 카드 + 그림자 |
| **그리드** | `grid grid-cols-1 md:grid-cols-3 gap-6`       | 반응형 3열 그리드       |
| **상태**   | `bg-green-400 text-green-900`                 | 연결 상태 (초록)        |
| **로그**   | `border-b border-gray-200 pb-2`               | 하단 테두리             |

---

## ❓ 자주 묻는 질문

### Q1. 연결이 안 됩니다!

**A**:

- WebSocket 포트 확인 (8884)
- HiveMQ Cloud 인증 정보 확인
- 브라우저 콘솔에서 에러 확인 (F12)

### Q2. 스마트폰에서도 됩니까?

**A**: 네! 같은 HTML 파일을 스마트폰 브라우저에서 열면 됩니다.

### Q3. 서버가 필요한가요?

**A**: 아니요. HTML 파일만으로 동작합니다 (서버리스).

---

## 🚀 다음 단계

웹에서 센서 데이터 모니터링 완성!

**다음 챕터에서는**:

- 브라우저에서 LED 제어
- 양방향 통신 (Subscribe + Publish)
- 제어 버튼 추가

---

**🎉 Chapter 24 완료!**  
실시간 웹 센서 모니터가 완성되었습니다!

# Chapter 25. 웹에서 헥사보드 수동 제어 (Tailwind CSS)

> **PART 7**: 웹 기반 AI 제어 대시보드

---

## 📚 이 챕터에서 배울 내용

- [ ] 웹에서 MQTT로 제어 명령을 보낼 수 있다
- [ ] Tailwind CSS로 색상 선택기를 만들 수 있다
- [ ] 양방향 통신을 구현할 수 있다

**예상 소요 시간**: 40분

---

## 🎯 학습 목표

### 웹 제어란?

**브라우저에서 버튼과 컨트롤러로 헥사보드를 직접 제어**

```
웹 브라우저 → MQTT Publish → 헥사보드 → LED 제어
```

**제어 기능**:

- ✅ LED 색상 변경
- ✅ 밝기 조절
- ✅ 패턴 선택 (solid, blink, pulse)
- ✅ LED 켜기/끄기

---

## 💻 실습 1: Tailwind CSS로 제어 UI 만들기

### Step 1: 색상 선택 버튼

**Tailwind CSS 색상 버튼**:

```html
<!-- 색상 프리셋 -->
<div class="mb-6">
  <label class="block text-sm font-semibold text-gray-700 mb-3"
    >색상 선택</label
  >
  <div class="flex flex-wrap gap-3">
    <button
      onclick="setColor(255, 0, 0)"
      class="w-14 h-14 rounded-xl border-4 border-gray-300 hover:border-gray-500 hover:scale-110 transition-all bg-red-500"
    ></button>
    <button
      onclick="setColor(0, 255, 0)"
      class="w-14 h-14 rounded-xl border-4 border-gray-300 hover:border-gray-500 hover:scale-110 transition-all bg-green-500"
    ></button>
    <button
      onclick="setColor(0, 0, 255)"
      class="w-14 h-14 rounded-xl border-4 border-gray-300 hover:border-gray-500 hover:scale-110 transition-all bg-blue-500"
    ></button>
    <button
      onclick="setColor(255, 255, 0)"
      class="w-14 h-14 rounded-xl border-4 border-gray-300 hover:border-gray-500 hover:scale-110 transition-all bg-yellow-400"
    ></button>
    <button
      onclick="setColor(255, 0, 255)"
      class="w-14 h-14 rounded-xl border-4 border-gray-300 hover:border-gray-500 hover:scale-110 transition-all bg-purple-500"
    ></button>
    <button
      onclick="setColor(0, 255, 255)"
      class="w-14 h-14 rounded-xl border-4 border-gray-300 hover:border-gray-500 hover:scale-110 transition-all bg-cyan-400"
    ></button>
    <button
      onclick="setColor(255, 255, 255)"
      class="w-14 h-14 rounded-xl border-4 border-gray-300 hover:border-gray-500 hover:scale-110 transition-all bg-white"
    ></button>
  </div>
</div>
```

**Tailwind 클래스 설명**:

- `w-14 h-14`: 56px × 56px 크기
- `rounded-xl`: 둥근 모서리
- `hover:scale-110`: 호버 시 크기 확대
- `transition-all`: 부드러운 애니메이션

### Step 2: 커스텀 색상 & 밝기 조절

```html
<!-- 커스텀 색상 -->
<div class="mb-6">
  <label class="block text-sm font-semibold text-gray-700 mb-3"
    >커스텀 색상</label
  >
  <div class="flex gap-3">
    <input
      type="color"
      id="colorPicker"
      value="#00ff00"
      class="w-20 h-10 rounded-lg cursor-pointer"
    />
    <button
      onclick="setCustomColor()"
      class="px-6 py-2 bg-primary hover:bg-opacity-90 text-white font-semibold rounded-lg transition-all hover:-translate-y-0.5"
    >
      적용
    </button>
  </div>
</div>

<!-- 밝기 조절 -->
<div class="mb-6">
  <label class="block text-sm font-semibold text-gray-700 mb-3">
    밝기: <span id="brightnessValue" class="text-primary">80</span>%
  </label>
  <input
    type="range"
    id="brightness"
    min="10"
    max="100"
    value="80"
    oninput="updateBrightness(this.value)"
    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary"
  />
</div>

<!-- 패턴 선택 -->
<div class="mb-6">
  <label class="block text-sm font-semibold text-gray-700 mb-3">패턴</label>
  <div class="flex gap-3">
    <button
      onclick="setPattern('solid')"
      class="flex-1 px-4 py-3 bg-gray-100 hover:bg-gray-200 font-semibold rounded-lg transition-all"
    >
      🔆 단색
    </button>
    <button
      onclick="setPattern('blink')"
      class="flex-1 px-4 py-3 bg-gray-100 hover:bg-gray-200 font-semibold rounded-lg transition-all"
    >
      💫 깜빡임
    </button>
    <button
      onclick="setPattern('pulse')"
      class="flex-1 px-4 py-3 bg-gray-100 hover:bg-gray-200 font-semibold rounded-lg transition-all"
    >
      🌊 펄스
    </button>
  </div>
</div>

<!-- LED 끄기 -->
<button
  onclick="turnOffLED()"
  class="w-full px-6 py-4 bg-red-500 hover:bg-red-600 text-white font-bold text-lg rounded-lg transition-all"
>
  ❌ LED 끄기
</button>
```

---

## 💻 실습 2: JavaScript 제어 로직

### 제어 함수 구현

```javascript
// 현재 LED 상태
let currentColor = [0, 255, 0];
let currentBrightness = 80;
let currentPattern = "solid";
const BOARD_ID = "A";

// LED 제어 명령 전송
function sendLEDCommand(color, pattern, brightness) {
  const command = {
    action: "led_color",
    color: color,
    pattern: pattern,
    brightness: brightness,
  };

  const topic = `hexaboard/${BOARD_ID}/control/led`;
  const message = JSON.stringify(command);

  client.publish(topic, message, function (err) {
    if (!err) {
      console.log("✅ 제어 명령 전송:", command);
      addLog(`LED: RGB(${color}) ${pattern} ${brightness}%`);
    }
  });

  currentColor = color;
  currentPattern = pattern;
  currentBrightness = brightness;
}

// 색상 설정
function setColor(r, g, b) {
  currentColor = [r, g, b];
  sendLEDCommand(currentColor, currentPattern, currentBrightness);
}

// 커스텀 색상
function setCustomColor() {
  const hex = document.getElementById("colorPicker").value;
  const r = parseInt(hex.substr(1, 2), 16);
  const g = parseInt(hex.substr(3, 2), 16);
  const b = parseInt(hex.substr(5, 2), 16);
  setColor(r, g, b);
}

// 밝기 업데이트
function updateBrightness(value) {
  document.getElementById("brightnessValue").textContent = value;
  currentBrightness = parseInt(value);
}

// 밝기 슬라이더 변경 완료 시
document.getElementById("brightness").addEventListener("change", function () {
  sendLEDCommand(currentColor, currentPattern, currentBrightness);
});

// 패턴 설정
function setPattern(pattern) {
  currentPattern = pattern;
  sendLEDCommand(currentColor, currentPattern, currentBrightness);
}

// LED 끄기
function turnOffLED() {
  client.publish(
    `hexaboard/${BOARD_ID}/control/led`,
    JSON.stringify({ action: "led_off" })
  );
  addLog("LED OFF");
}
```

---

## 💻 실습 3: 완성된 제어 대시보드

### 전체 코드

완전한 코드는 `code/web/ch25_control_tailwind.html`에서 확인할 수 있습니다.

**주요 구성**:

1. **센서 모니터** (왼쪽)

   - 온도, 습도, 조도 실시간 표시
   - Chapter 24 코드 재사용

2. **LED 제어 패널** (오른쪽)

   - 색상 프리셋 버튼 7개
   - 커스텀 색상 선택기
   - 밝기 슬라이더
   - 패턴 버튼 3개
   - LED 끄기 버튼

3. **로그** (하단)
   - 센서 데이터 + 제어 명령 로그

---

## 📝 핵심 정리

### 양방향 통신

```
웹 브라우저 ⇄ MQTT Broker ⇄ 헥사보드

Subscribe: 센서 데이터 수신
Publish: 제어 명령 전송
```

### Tailwind CSS 제어 컴포넌트

| 컴포넌트      | 주요 클래스                            |
| ------------- | -------------------------------------- |
| **색상 버튼** | `w-14 h-14 rounded-xl hover:scale-110` |
| **슬라이더**  | `w-full h-2 rounded-lg accent-primary` |
| **패턴 버튼** | `flex-1 bg-gray-100 hover:bg-gray-200` |
| **주요 버튼** | `bg-primary hover:bg-opacity-90`       |

---

## ❓ 자주 묻는 질문

### Q1. 명령이 전송되는지 확인하려면?

**A**: 브라우저 콘솔(F12)에서 "제어 명령 전송" 메시지 확인

### Q2. Tailwind CSS 없이도 작동하나요?

**A**: 네. 기능은 동일하며 Tailwind는 스타일링만 담당합니다.

### Q3. 모바일에서도 작동하나요?

**A**: 네! Tailwind의 반응형 클래스로 모바일에서도 최적화됩니다.

---

## 🚀 다음 단계

웹에서 헥사보드 제어 완성!

**다음 챕터에서는**:

- 자연어 입력으로 제어
- OpenAI API 통합
- 완전한 AI 대시보드

---

**🎉 Chapter 25 완료!**  
Tailwind CSS로 양방향 웹 제어 대시보드가 완성되었습니다!

# Chapter 26. 웹에서 자연어 기반 AI 제어 (Tailwind CSS)

> **PART 7**: 웹 기반 AI 제어 대시보드

---

## 📚 이 챕터에서 배울 내용

- [ ] 자연어로 헥사보드를 제어할 수 있다
- [ ] Tailwind CSS로 AI 인터페이스를 만들 수 있다
- [ ] 완전한 AIoT 대시보드를 완성할 수 있다

**예상 소요 시간**: 50분

---

## 🎯 학습 목표

### AI 제어란?

**사용자가 자연어로 입력하면 AI가 명령으로 변환하여 헥사보드를 제어**

```
사용자: "LED를 빨간색으로 바꿔줘"
    ↓
OpenAI API 분석
    ↓
명령: {action: "led_color", color: [255, 0, 0]}
    ↓
헥사보드 제어
```

---

## ⚠️ 중요: API 키 보안

**⚠️ 주의**: HTML에 API 키를 직접 넣으면 누구나 볼 수 있습니다!

**권장 방법**: Python 백엔드 서버 사용 (Chapter 26에서 제공)

---

## 💻 실습 1: AI 제어 UI (Tailwind CSS)

### Step 1: AI 입력 인터페이스

```html
<div class="lg:col-span-2 bg-white rounded-2xl shadow-2xl p-8">
  <h2 class="text-2xl font-bold text-gray-800 mb-6">🤖 AI 자연어 제어</h2>

  <!-- 명령 입력 -->
  <div class="mb-6">
    <label class="block text-sm font-semibold text-gray-700 mb-3"
      >명령 입력</label
    >
    <div class="flex gap-3">
      <input
        type="text"
        id="aiCommand"
        placeholder="예: LED를 파란색으로 바꿔줘"
        onkeypress="if(event.key==='Enter') sendAICommand()"
        class="flex-1 px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-primary"
      />
      <button
        onclick="sendAICommand()"
        class="px-8 py-3 bg-primary hover:bg-opacity-90 text-white font-bold rounded-lg transition-all hover:-translate-y-0.5 whitespace-nowrap"
      >
        ✨ 실행
      </button>
    </div>
  </div>

  <!-- 예시 명령 -->
  <div class="mb-6">
    <label class="block text-sm font-semibold text-gray-700 mb-3"
      >예시 명령</label
    >
    <div class="flex flex-wrap gap-2">
      <button
        onclick="setAIExample('LED를 빨간색으로 바꿔줘')"
        class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm font-medium transition-all"
      >
        빨간색
      </button>
      <button
        onclick="setAIExample('LED를 초록색으로 켜줘')"
        class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm font-medium transition-all"
      >
        초록색
      </button>
      <button
        onclick="setAIExample('LED를 깜빡이게 해줘')"
        class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm font-medium transition-all"
      >
        깜빡임
      </button>
      <button
        onclick="setAIExample('밝기를 50%로 낮춰줘')"
        class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm font-medium transition-all"
      >
        밝기 50%
      </button>
      <button
        onclick="setAIExample('LED를 꺼줘')"
        class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg text-sm font-medium transition-all"
      >
        끄기
      </button>
    </div>
  </div>

  <!-- AI 응답 -->
  <div class="mb-4">
    <label class="block text-sm font-semibold text-gray-700 mb-3"
      >AI 응답</label
    >
    <div
      id="aiResponse"
      class="bg-gray-50 border-l-4 border-primary rounded-lg p-4 text-sm leading-relaxed text-gray-700"
    >
      명령을 입력하고 실행 버튼을 눌러주세요.
    </div>
  </div>
</div>
```

**Tailwind 상태별 스타일**:

```javascript
// 로딩 중
responseEl.className =
  "bg-yellow-50 border-l-4 border-yellow-400 rounded-lg p-4 text-sm leading-relaxed";

// 성공
responseEl.className =
  "bg-green-50 border-l-4 border-green-400 rounded-lg p-4 text-sm leading-relaxed";

// 오류
responseEl.className =
  "bg-red-50 border-l-4 border-red-400 rounded-lg p-4 text-sm leading-relaxed";
```

---

## 💻 실습 2: OpenAI API 통합

### AI 명령 처리 함수

```javascript
// OpenAI API 호출
async function sendAICommand() {
  const inputEl = document.getElementById("aiCommand");
  const userCommand = inputEl.value.trim();

  if (!userCommand) {
    alert("명령을 입력해주세요!");
    return;
  }

  const responseEl = document.getElementById("aiResponse");
  responseEl.textContent = "🤔 AI가 명령을 분석 중...";
  responseEl.className =
    "bg-yellow-50 border-l-4 border-yellow-400 rounded-lg p-4 text-sm leading-relaxed";

  addLog(`AI 명령: ${userCommand}`);

  try {
    const ledCommand = await analyzeLEDCommand(userCommand);

    if (ledCommand) {
      sendLEDCommandFromAI(ledCommand);

      responseEl.innerHTML = `
                ✅ <strong>명령 이해:</strong> ${ledCommand.description}<br>
                📤 <strong>실행:</strong> ${ledCommand.action}
            `;
      responseEl.className =
        "bg-green-50 border-l-4 border-green-400 rounded-lg p-4 text-sm leading-relaxed";
    } else {
      responseEl.textContent = "❌ 명령을 이해하지 못했습니다.";
      responseEl.className =
        "bg-red-50 border-l-4 border-red-400 rounded-lg p-4 text-sm leading-relaxed";
    }
  } catch (error) {
    responseEl.textContent = "❌ AI 처리 중 오류: " + error.message;
    responseEl.className =
      "bg-red-50 border-l-4 border-red-400 rounded-lg p-4 text-sm leading-relaxed";
  }

  inputEl.value = "";
}

// OpenAI API로 명령 분석
async function analyzeLEDCommand(userCommand) {
  const prompt = `
다음 사용자 명령을 LED 제어 명령으로 변환하세요.

사용자 명령: "${userCommand}"

LED 옵션:
- 색상: red(255,0,0), green(0,255,0), blue(0,0,255), yellow(255,255,0), purple(255,0,255), cyan(0,255,255), white(255,255,255)
- 패턴: solid(단색), blink(깜빡임), pulse(펄스)
- 밝기: 10-100%

JSON만 출력:
{"action": "led_color", "color": [R,G,B], "pattern": "solid", "brightness": 80, "description": "설명"}
`;

  try {
    // 백엔드 서버 사용 (권장)
    const response = await fetch("http://localhost:5000/api/analyze-command", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ command: userCommand }),
    });

    if (!response.ok) throw new Error("서버 오류");
    return await response.json();
  } catch (error) {
    console.error("AI 오류:", error);
    throw error;
  }
}

function sendLEDCommandFromAI(aiCommand) {
  if (aiCommand.action === "led_off") {
    client.publish(TOPIC_CONTROL, JSON.stringify({ action: "led_off" }));
  } else {
    client.publish(TOPIC_CONTROL, JSON.stringify(aiCommand));
  }
}

function setAIExample(example) {
  document.getElementById("aiCommand").value = example;
}
```

---

## 💻 실습 3: Python 백엔드 서버

### Flask 서버 (권장)

**파일명**: `ai_server.py` (이미 `code/python/ch26_ai_server.py`에 있음)

````python
from flask import Flask, request, jsonify
from flask_cors import CORS
from openai import OpenAI
import os

app = Flask(__name__)
CORS(app)

openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

@app.route('/api/analyze-command', methods=['POST'])
def analyze_command():
    data = request.json
    user_command = data.get('command', '')

    if not user_command:
        return jsonify({'error': 'No command'}), 400

    try:
        response = openai_client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "LED 제어 명령 변환 전문가. JSON만 출력."},
                {"role": "user", "content": f"명령: {user_command}"}
            ],
            max_tokens=200,
            temperature=0.3
        )

        content = response.choices[0].message.content.strip()
        if '```' in content:
            content = content.split('```')[1].replace('json', '').strip()

        import json
        command = json.loads(content)
        return jsonify(command)

    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    print("🚀 AI 서버 시작...")
    app.run(host='0.0.0.0', port=5000)
````

**실행**:

```bash
# 환경 변수 설정
export OPENAI_API_KEY="sk-proj-YOUR_KEY"

# 서버 실행
python ai_server.py
```

---

## 📝 핵심 정리

### AI 제어 흐름

```
1. 사용자 입력 (자연어)
   ↓
2. Python 서버로 전송
   ↓
3. OpenAI API 분석
   ↓
4. JSON 명령 생성
   ↓
5. MQTT Publish
   ↓
6. 헥사보드 실행
```

### Tailwind CSS AI 컴포넌트

| 컴포넌트        | 클래스                                           |
| --------------- | ------------------------------------------------ |
| **입력창**      | `flex-1 px-4 py-3 border-2 focus:border-primary` |
| **실행 버튼**   | `bg-primary hover:-translate-y-0.5`              |
| **예시 버튼**   | `bg-gray-100 hover:bg-gray-200`                  |
| **응답 (로딩)** | `bg-yellow-50 border-l-4 border-yellow-400`      |
| **응답 (성공)** | `bg-green-50 border-l-4 border-green-400`        |
| **응답 (오류)** | `bg-red-50 border-l-4 border-red-400`            |

---

## 🎉 PART 7 완료!

### 완성한 것들

- ✅ 웹 센서 모니터링 (Tailwind CSS)
- ✅ 웹 수동 제어 (Tailwind CSS)
- ✅ 웹 AI 제어 (Tailwind CSS)
- ✅ Python 백엔드 서버

### 최종 대시보드 기능

1. **실시간 센서 모니터링**
2. **수동 LED 제어** (색상, 밝기, 패턴)
3. **AI 자연어 제어** (GPT 기반)
4. **양방향 통신** (MQTT)
5. **반응형 UI** (Tailwind CSS)
6. **안전한 API** (Python 백엔드)

---

## 🚀 다음 단계

완전한 AIoT 웹 대시보드 완성!

**PART 8에서는**:

- 교육 커리큘럼 설계
- 미션 기반 실습
- 확장 아이디어

---

**🎉 Chapter 26 완료!**  
**🎉 PART 7 완료!**

Tailwind CSS로 완전한 AIoT 웹 대시보드가 완성되었습니다!

# Chapter 27. 교육 커리큘럼 설계 가이드

> **PART 8**: 수업 설계와 확장 아이디어

---

## 📚 이 챕터에서 배울 내용

- [ ] 효과적인 AIoT 교육 커리큘럼을 설계할 수 있다
- [ ] 학습자 수준별 교육 계획을 세울 수 있다
- [ ] 수업 운영 팁을 이해할 수 있다

**예상 소요 시간**: 20분

---

## 🎯 학습 목표

### AIoT 교육의 핵심

**실습 중심 + 프로젝트 기반 학습으로 실전 능력 향상**

```
이론 (20%) + 실습 (50%) + 프로젝트 (30%) = 완성도 높은 학습
```

---

## 📋 커리큘럼 구조

### 기본 20시간 코스 (전체)

| 주차    | PART     | 주제             | 시간    | 난이도 |
| ------- | -------- | ---------------- | ------- | ------ |
| **1주** | PART 1-2 | 기초 & 기본 제어 | 4시간   | ⭐     |
| **2주** | PART 3   | 센서 & 데이터    | 3시간   | ⭐⭐   |
| **3주** | PART 4   | MQTT 통신        | 3.5시간 | ⭐⭐   |
| **4주** | PART 5   | Python AI        | 4시간   | ⭐⭐   |
| **5주** | PART 6   | 종합 프로젝트    | 3.5시간 | ⭐⭐   |
| **6주** | PART 7   | 웹 대시보드      | 1.5시간 | ⭐⭐   |
| **7주** | PART 8   | 최종 프로젝트    | 0.5시간 | ⭐     |

---

## 👥 수준별 커리큘럼

### 1. 초급 코스 (10시간)

**대상**: 프로그래밍 경험 없음, 중고등학생

**목표**: 헥사보드로 센서 제어 및 MQTT 기초

**커리큘럼**:

| 회차    | 내용                        | 시간    |
| ------- | --------------------------- | ------- |
| **1회** | 헥사보드 소개 + 첫 프로그램 | 1.5시간 |
| **2회** | 버튼과 LED 제어             | 2시간   |
| **3회** | 온습도 센서 연결            | 1.5시간 |
| **4회** | MQTT 기초 (데이터 보내기)   | 2시간   |
| **5회** | 간단한 환경 모니터 만들기   | 3시간   |

**제외 항목**:

- Python AI 서버
- 웹 대시보드
- 고급 프로젝트

### 2. 중급 코스 (15시간)

**대상**: 기본 프로그래밍 경험, 대학생/일반인

**목표**: AIoT 시스템 구축 및 Python 활용

**커리큘럼**:

| 회차      | 내용                 | 시간  |
| --------- | -------------------- | ----- |
| **1-2회** | 헥사보드 기초 + 센서 | 4시간 |
| **3-4회** | MQTT 통신 구축       | 4시간 |
| **5-6회** | Python AI 서버       | 4시간 |
| **7회**   | 웹 모니터링 기초     | 2시간 |
| **8회**   | 미니 프로젝트 발표   | 1시간 |

### 3. 고급 코스 (20시간)

**대상**: 개발 경험자, 교육자, 전문가

**목표**: 완전한 AIoT 시스템 + 확장 가능

**커리큘럼**: 전체 PART 1~8 + 심화 프로젝트

---

## 📅 수업 운영 전략

### 수업 구조 (2시간 기준)

```
10분: 지난 시간 복습
20분: 이론 및 개념 설명
60분: 실습 (따라하기)
20분: 도전 과제 (응용)
10분: 질의응답 및 다음 예고
```

### 효과적인 티칭 팁

**1. 실습 중심**

- ✅ 모든 개념을 즉시 코드로 실습
- ✅ 작은 성공 경험 누적 (LED 켜기 → 센서 읽기 → ...)
- ✅ 오류도 학습의 일부 (디버깅 경험)

**2. 페어 프로그래밍**

- 2명이 1조로 협력
- 역할 교대 (드라이버 ↔ 네비게이터)
- 서로 가르치며 학습

**3. 프로젝트 기반**

- 실습마다 작은 목표 설정
- 최종 프로젝트로 통합
- 발표 및 공유 시간

**4. 문제 해결 중심**

- "왜 안 될까?" 질문 유도
- 스스로 해결 방법 찾기
- 구글링 및 문서 읽기 연습

---

## 🛠️ 수업 준비물

### 하드웨어 (학생 1인당)

- [x] 헥사보드 × 1
- [x] DHT11 센서 모듈 × 1
- [x] 조도 센서 모듈 × 1
- [x] 3핀 케이블 × 2
- [x] USB 케이블 × 1

### 소프트웨어

- [x] Thonny IDE (MicroPython)
- [x] Python 3.10+ (AI 서버용)
- [x] 웹 브라우저 (대시보드용)
- [x] HiveMQ Cloud 계정 (무료)
- [x] OpenAI API 키 (선택)

### 기타 준비물

- [x] 와이파이 환경
- [x] 프로젝터 / 화면 공유
- [x] 예제 코드 USB 또는 공유
- [x] 문제 해결 가이드

---

## 📖 수업별 상세 계획

### Week 1: 헥사보드 시작하기

**목표**: 헥사보드 제어 기초

**주요 활동**:

1. 헥사보드 소개 및 연결
2. Thonny 설치 및 설정
3. LED 깜빡이기 (Hello World)
4. 버튼으로 LED 제어

**도전 과제**:

- 버튼으로 색상 변경 게임 만들기

### Week 2: 센서 데이터 다루기

**목표**: 센서 값 읽고 처리하기

**주요 활동**:

1. DHT11 온습도 센서 연결
2. 센서 데이터 읽기
3. LED로 온도 시각화
4. 데이터 저장 및 통계

**도전 과제**:

- 온도 경보 시스템 만들기

### Week 3: MQTT로 연결하기

**목표**: IoT 통신 기초

**주요 활동**:

1. MQTT 개념 이해
2. HiveMQ Cloud 설정
3. 센서 데이터 전송
4. 여러 보드 연동

**도전 과제**:

- 친구 보드와 데이터 주고받기

### Week 4: AI 통합하기

**목표**: AI로 데이터 분석

**주요 활동**:

1. Python 서버 만들기
2. OpenAI API 연동
3. 센서 데이터 AI 분석
4. 자동 제어 구현

**도전 과제**:

- AI 추천 시스템 만들기

### Week 5: 종합 프로젝트

**목표**: 완전한 시스템 구축

**주요 활동**:

1. 프로젝트 기획
2. 시스템 통합
3. 테스트 및 디버깅
4. 최종 발표 준비

---

## 🎓 평가 방법

### 평가 기준

| 항목              | 비율 | 평가 방법        |
| ----------------- | ---- | ---------------- |
| **출석 및 참여**  | 20%  | 수업 참여도      |
| **실습 과제**     | 30%  | 주차별 도전 과제 |
| **최종 프로젝트** | 40%  | 완성도 + 창의성  |
| **발표**          | 10%  | 프레젠테이션     |

### 실습 과제 체크리스트

**기본 (필수)**:

- [ ] 코드가 정상 작동함
- [ ] 주요 기능 구현
- [ ] 기본 오류 처리

**중급**:

- [ ] 코드 주석 작성
- [ ] 추가 기능 구현
- [ ] 사용자 친화적

**고급**:

- [ ] 창의적 확장
- [ ] 최적화
- [ ] 문서화

---

## 💡 교육자를 위한 팁

### 자주 발생하는 문제와 해결

**1. Wi-Fi 연결 안 됨**

- 미리 Wi-Fi 정보 공유
- 핫스팟 백업 준비
- 연결 테스트 시간 확보

**2. 코드 오류**

- 일반적인 오류 목록 준비
- 페어로 서로 확인하게 함
- "5분 법칙" (5분 혼자 시도 후 질문)

**3. 진도 차이**

- 빠른 학생: 도전 과제 제공
- 느린 학생: 페어 매칭
- 핵심만 완성해도 성공!

### 온라인 수업 팁

- 🎥 **화면 공유**: 코드 실시간 작성
- 💬 **채팅 활용**: 질문 및 코드 공유
- 📹 **녹화**: 복습 자료 제공
- 🖥️ **브레이크아웃 룸**: 팀 활동

---

## 📚 추가 학습 자료

### 추천 순서

1. **공식 문서**

   - MicroPython 문서
   - MQTT.org
   - OpenAI API 문서

2. **온라인 리소스**

   - YouTube 튜토리얼
   - GitHub 예제
   - 커뮤니티 포럼

3. **프로젝트 아이디어**
   - Hackster.io
   - Instructables
   - Medium 블로그

---

## 🎯 학습 성과 목표

### 코스 완료 후 학생은...

**기술적 역량**:

- ✅ MicroPython으로 하드웨어 제어
- ✅ 센서 데이터 수집 및 처리
- ✅ MQTT로 IoT 통신 구현
- ✅ Python으로 AI 서버 구축
- ✅ 웹 대시보드 제작

**문제 해결 능력**:

- ✅ 오류 디버깅
- ✅ 문서 읽고 활용
- ✅ 구글링으로 해결책 찾기

**프로젝트 능력**:

- ✅ 요구사항 분석
- ✅ 시스템 설계
- ✅ 단계별 구현
- ✅ 테스트 및 개선

---

## 📝 핵심 정리

### 성공적인 AIoT 교육의 원칙

1. **실습 중심**: 이론 < 코딩
2. **작은 성공**: 단계적 성취감
3. **프로젝트 기반**: 실제 문제 해결
4. **협력 학습**: 페어/팀 활동
5. **재미**: 게임화, 경쟁, 발표

### 교육자 마인드셋

- "완벽보다 완성"
- "오류는 학습의 기회"
- "질문을 환영"
- "창의성 격려"

---

## ❓ 자주 묻는 질문

### Q1. 비전공자도 가능한가요?

**A**: 네! 기초부터 단계별로 진행하므로 누구나 가능합니다.

### Q2. 온라인으로도 진행 가능한가요?

**A**: 가능합니다. 하드웨어 키트를 미리 배송하고 화면 공유로 진행하세요.

### Q3. 몇 명이 적정한가요?

**A**: 오프라인 10-15명, 온라인 20-25명이 적정합니다.

---

## 🚀 다음 단계

교육 커리큘럼 설계 완료!

**다음 챕터에서는**:

- 미션 기반 실습 과제
- 평가 기준 및 루브릭
- 프로젝트 아이디어

---

**🎉 Chapter 27 완료!**  
효과적인 AIoT 교육을 위한 가이드가 준비되었습니다!

# Chapter 28. 미션 기반 실습 및 평가 설계

> **PART 8**: 수업 설계와 확장 아이디어

---

## 📚 이 챕터에서 배울 내용

- [ ] 미션 기반 학습의 효과를 이해할 수 있다
- [ ] 단계별 실습 미션을 설계할 수 있다
- [ ] 효과적인 평가 기준을 만들 수 있다

**예상 소요 시간**: 20분

---

## 🎯 학습 목표

### 미션 기반 학습이란?

**게임처럼 단계별 미션을 수행하며 자연스럽게 학습**

```
미션 제시 → 도전 → 성공 → 보상(피드백) → 다음 미션
```

**장점**:

- ✅ 명확한 목표
- ✅ 자기주도 학습
- ✅ 성취감
- ✅ 재미

---

## 🎮 레벨별 미션 설계

### Level 1: 헥사보드 마스터 (기초)

#### Mission 1-1: LED 깜빡이기

**목표**: 첫 프로그램 실행

**미션**:

```
1. LED를 1초 간격으로 빨간색으로 깜빡이게 하세요
2. 버튼을 누르면 멈추게 하세요
```

**힌트**:

- `time.sleep(1)` 사용
- 버튼 상태 확인

**체크리스트**:

- [ ] LED 깜빡임
- [ ] 버튼으로 정지
- [ ] 코드에 주석

**예상 시간**: 15분

---

#### Mission 1-2: 색상 순환

**목표**: 반복문과 색상 제어

**미션**:

```
버튼을 누를 때마다 LED 색상이 변경되게 하세요
빨강 → 초록 → 파랑 → 빨강 (순환)
```

**힌트**:

- 상태 변수 사용
- 리스트로 색상 관리

**체크리스트**:

- [ ] 색상 순환
- [ ] 버튼 한 번 누르면 한 번만 변경
- [ ] 순환 구조

**예상 시간**: 20분

---

#### Mission 1-3: 반응속도 게임

**목표**: 타이밍과 입력 처리

**미션**:

```
1. LED가 무작위 시간 후 초록색으로 켜짐
2. 사용자가 버튼을 누름
3. 반응 시간을 시리얼로 출력
```

**힌트**:

- `time.ticks_ms()` 사용
- `random.randint()` 사용

**체크리스트**:

- [ ] 무작위 대기
- [ ] 반응 시간 측정
- [ ] 결과 출력

**예상 시간**: 25분

---

### Level 2: 센서 전문가 (중급)

#### Mission 2-1: 환경 모니터

**목표**: 센서 데이터 수집

**미션**:

```
온도, 습도를 1분마다 측정하여 리스트에 저장하고
평균값을 계산하여 출력하세요
```

**힌트**:

- 리스트에 `append()`
- `sum()` / `len()` 사용

**체크리스트**:

- [ ] 센서 데이터 수집
- [ ] 리스트 저장
- [ ] 평균 계산

**예상 시간**: 30분

---

#### Mission 2-2: 온도 경보 시스템

**목표**: 조건문과 시각화

**미션**:

```
온도가 25도 이상이면 빨간색 LED
20~25도는 초록색
20도 미만은 파란색으로 표시
```

**힌트**:

- `if-elif-else` 사용
- LED 색상 매핑

**체크리스트**:

- [ ] 온도 범위별 색상
- [ ] 실시간 업데이트
- [ ] 부드러운 색상 전환

**예상 시간**: 30분

---

#### Mission 2-3: 데이터 로거

**목표**: 데이터 저장 및 분석

**미션**:

```
10분간 온도, 습도를 10초마다 측정하여
최대/최소/평균값을 출력하세요
```

**힌트**:

- `max()`, `min()` 함수
- 타임스탬프 기록

**체크리스트**:

- [ ] 주기적 측정
- [ ] 통계 계산
- [ ] 타임스탬프

**예상 시간**: 35분

---

### Level 3: IoT 통신 마스터 (고급)

#### Mission 3-1: MQTT 데이터 송신

**목표**: 기본 MQTT 통신

**미션**:

```
센서 데이터를 JSON 형식으로
MQTT 브로커에 30초마다 전송하세요
```

**힌트**:

- `ujson.dumps()` 사용
- Topic: `hexaboard/YOUR_ID/data`

**체크리스트**:

- [ ] Wi-Fi 연결
- [ ] MQTT 연결
- [ ] JSON 전송

**예상 시간**: 40분

---

#### Mission 3-2: 양방향 통신

**목표**: Subscribe & Publish

**미션**:

```
1. 센서 데이터를 전송
2. 제어 명령을 구독
3. 명령에 따라 LED 제어
```

**힌트**:

- 2개의 Topic 사용
- 콜백 함수 구현

**체크리스트**:

- [ ] 데이터 송신
- [ ] 명령 수신
- [ ] LED 제어

**예상 시간**: 45분

---

#### Mission 3-3: 멀티 보드 통신

**목표**: 보드 간 통신

**미션**:

```
2개의 헥사보드를 준비하여
Board A의 버튼을 누르면
Board B의 LED가 켜지게 하세요
```

**힌트**:

- 서로 다른 Client ID
- 공통 Topic 사용

**체크리스트**:

- [ ] 2개 보드 연결
- [ ] 버튼 → LED 연동
- [ ] 양방향 가능

**예상 시간**: 50분

---

### Level 4: AI 통합 전문가 (심화)

#### Mission 4-1: Python 데이터 수집

**목표**: Python MQTT 클라이언트

**미션**:

```
Python으로 MQTT 데이터를 수신하여
CSV 파일에 저장하세요
```

**힌트**:

- `paho-mqtt` 라이브러리
- `csv.writer()` 사용

**체크리스트**:

- [ ] MQTT 구독
- [ ] CSV 저장
- [ ] 타임스탬프 포함

**예상 시간**: 40분

---

#### Mission 4-2: AI 데이터 분석

**목표**: OpenAI API 통합

**미션**:

```
수집된 센서 데이터를 OpenAI로 분석하여
환경 상태와 추천사항을 출력하세요
```

**힌트**:

- 프롬프트 설계
- JSON 응답 처리

**체크리스트**:

- [ ] 데이터 요약
- [ ] AI 분석
- [ ] 추천 출력

**예상 시간**: 45분

---

#### Mission 4-3: 자동 제어 시스템

**목표**: 완전 자동화

**미션**:

```
AI가 센서 데이터를 분석하여
자동으로 LED 색상과 패턴을 제어하세요
```

**힌트**:

- 양방향 통신
- AI → 명령 생성

**체크리스트**:

- [ ] 자동 분석
- [ ] 명령 생성
- [ ] 헥사보드 제어

**예상 시간**: 60분

---

## 📊 평가 루브릭

### 실습 미션 평가 기준

#### 기능 구현 (50점)

| 점수   | 기준                            |
| ------ | ------------------------------- |
| **50** | 모든 기능 완벽 구현 + 추가 기능 |
| **40** | 모든 필수 기능 구현             |
| **30** | 주요 기능 대부분 구현           |
| **20** | 일부 기능만 구현                |
| **10** | 시도했으나 미완성               |

#### 코드 품질 (30점)

| 점수   | 기준                             |
| ------ | -------------------------------- |
| **30** | 주석 충분 + 변수명 명확 + 구조화 |
| **20** | 주석 있음 + 가독성 양호          |
| **10** | 최소한의 주석 + 작동함           |

#### 문제 해결 (20점)

| 점수   | 기준                      |
| ------ | ------------------------- |
| **20** | 독립적 해결 + 창의적 접근 |
| **15** | 약간의 도움으로 해결      |
| **10** | 많은 도움 필요            |

---

## 🏆 프로젝트 평가 기준

### 최종 프로젝트 루브릭 (100점)

#### 1. 완성도 (40점)

- **40점**: 모든 기능 완벽 구현 + 안정적
- **30점**: 주요 기능 모두 작동
- **20점**: 핵심 기능 작동
- **10점**: 일부만 작동

#### 2. 창의성 (30점)

- **30점**: 독창적 아이디어 + 차별화
- **20점**: 기본 기능에 응용 추가
- **10점**: 예제 기반 구현

#### 3. 기술 구현 (20점)

- **20점**: 고급 기술 활용 (AI, 웹 등)
- **15점**: 중급 기술 (MQTT, 센서)
- **10점**: 기본 기능

#### 4. 발표 (10점)

- **10점**: 명확한 설명 + 데모 완벽
- **7점**: 설명 양호 + 데모 성공
- **5점**: 기본 발표

---

## 🎯 도전 프로젝트 아이디어

### 테마별 프로젝트

#### 🏠 스마트 홈

**1. 환경 자동 조절기**

- 온습도에 따라 LED 색상 자동 변경
- 불쾌지수 계산 및 알림
- AI 기반 최적 환경 추천

**2. 에너지 모니터**

- 조도 센서로 낮/밤 감지
- 자동 조명 제어
- 에너지 절약 통계

#### 🎮 게임 & 엔터테인먼트

**3. 반응속도 대결**

- 2인용 반응속도 게임
- LED 색상 맞추기
- 점수 집계 및 순위

**4. 음악 비주얼라이저**

- 버튼으로 리듬 입력
- LED 패턴 생성
- MQTT로 여러 보드 동기화

#### 📚 교육 & 실험

**5. 과학 실험 도구**

- 온도 변화 실험
- 데이터 자동 기록
- 그래프 생성 (Python)

**6. AI 챗봇 제어**

- 자연어로 LED 제어
- 센서 데이터 질문 응답
- 웹 인터페이스

#### 🌱 환경 & 농업

**7. 스마트 화분**

- 토양 습도 모니터링 (조도 센서 활용)
- 물주기 알림
- 성장 기록

**8. 공기질 모니터**

- 온습도 + 조도 복합 분석
- 환기 알림
- 일별/주별 통계

---

## 📝 실습 시트 템플릿

### 미션 수행 기록지

**이름**: **\*\***\_\_\_**\*\***  
**미션**: **\*\***\_\_\_**\*\***  
**날짜**: **\*\***\_\_\_**\*\***

#### 계획

**목표**:

**필요한 것**:

- [ ] 하드웨어: **\_\_\_**
- [ ] 라이브러리: **\_\_\_**
- [ ] 지식: **\_\_\_**

**예상 소요 시간**: **\_\_\_**

#### 실행

**시작 시간**: **\_\_\_**  
**종료 시간**: **\_\_\_**  
**실제 소요 시간**: **\_\_\_**

**어려웠던 점**:

**해결 방법**:

#### 결과

**성공 여부**: ⭕ / ❌

**작동 스크린샷**:

**코드 링크**: **\_\_\_**

#### 회고

**배운 점**:

**개선할 점**:

**다음 단계**:

---

## 💡 교육자 가이드

### 미션 운영 팁

**1. 미션 전**

- 미션 목표 명확히 설명
- 필수/선택 구분
- 예상 시간 안내

**2. 미션 중**

- 중간 체크포인트 설정
- 힌트는 단계적으로 제공
- 학생끼리 토론 유도

**3. 미션 후**

- 다양한 해결법 공유
- 베스트 코드 시연
- 실패 사례도 학습 자료

### 차별화 전략

**빠른 학생**:

- 추가 도전 과제
- 친구 도와주기
- 고급 기능 탐구

**느린 학생**:

- 페어 프로그래밍
- 더 많은 힌트
- 핵심만 완성

---

## ❓ 자주 묻는 질문

### Q1. 미션을 못 완수하면 어떡하나요?

**A**: 부분 점수를 주고, 핵심 개념을 이해했는지 확인하세요.

### Q2. 답을 복사하는 학생은?

**A**: 구두 질문으로 이해도 확인, 페어 코드 리뷰 진행

### Q3. 평가 기준이 너무 엄격하지 않나요?

**A**: 초급은 완성도, 고급은 창의성에 더 많은 점수 부여

---

## 🚀 다음 단계

미션 기반 학습 설계 완료!

**다음 챕터에서는**:

- 확장 아이디어
- 후속 프로젝트 방향
- 커뮤니티 및 자료

---

**🎉 Chapter 28 완료!**  
게임처럼 재미있는 AIoT 학습이 시작됩니다!

# Chapter 29. 확장 아이디어 및 후속 프로젝트 방향

> **PART 8**: 수업 설계와 확장 아이디어

---

## 📚 이 챕터에서 배울 내용

- [ ] 헥사보드를 확장하는 다양한 방법을 이해할 수 있다
- [ ] 고급 프로젝트 아이디어를 얻을 수 있다
- [ ] AIoT 학습을 계속 이어갈 수 있다

**예상 소요 시간**: 15분

---

## 🎯 확장의 방향

### 3가지 확장 축

```
1. 하드웨어 확장: 더 많은 센서/액츄에이터
2. 소프트웨어 확장: 더 복잡한 AI/데이터
3. 시스템 확장: 더 큰 네트워크
```

---

## 🔧 하드웨어 확장

### 추가 가능한 센서

#### 환경 센서

**1. BME280 (온습도 + 기압)**

```python
from bme280 import BME280
from machine import I2C, Pin

i2c = I2C(0, scl=Pin(22), sda=Pin(21))
bme = BME280(i2c=i2c)

temp, pressure, humidity = bme.read_compensated_data()
print(f"기압: {pressure/100:.2f} hPa")
```

**응용**:

- 날씨 예측
- 고도 측정
- 기압 변화 감지

**2. MQ-2 (가스 센서)**

```python
from machine import ADC, Pin

gas = ADC(Pin(34))
gas.atten(ADC.ATTN_11DB)

value = gas.read()
print(f"가스 농도: {value}")
```

**응용**:

- 공기질 모니터
- 가스 누출 감지
- 환기 알림

**3. PIR 센서 (움직임 감지)**

```python
from machine import Pin

pir = Pin(27, Pin.IN)

if pir.value():
    print("움직임 감지!")
```

**응용**:

- 자동 조명
- 보안 시스템
- 에너지 절약

#### 출력 장치

**4. OLED 디스플레이 (128x64)**

```python
from machine import I2C, Pin
from ssd1306 import SSD1306_I2C

i2c = I2C(0, scl=Pin(22), sda=Pin(21))
oled = SSD1306_I2C(128, 64, i2c)

oled.text("HexaBoard", 0, 0)
oled.text("Temp: 25C", 0, 20)
oled.show()
```

**응용**:

- 센서 데이터 표시
- 상태 메시지
- 그래프 출력

**5. 서보 모터**

```python
from machine import Pin, PWM

servo = PWM(Pin(26), freq=50)

def set_angle(angle):
    duty = int((angle / 180) * 102 + 26)
    servo.duty(duty)

set_angle(90)  # 90도
```

**응용**:

- 자동 창문 개폐
- 로봇 팔
- 방향 지시

**6. 릴레이 모듈**

```python
from machine import Pin

relay = Pin(25, Pin.OUT)

relay.value(1)  # ON
relay.value(0)  # OFF
```

**응용**:

- 가전제품 제어
- 전등 ON/OFF
- 고전력 장치 제어

---

## 💻 소프트웨어 확장

### 고급 AI 기능

#### 1. 시계열 데이터 예측

```python
import numpy as np
from sklearn.linear_model import LinearRegression

# 온도 데이터 수집 (시간, 온도)
data = [(0, 20), (1, 21), (2, 22), (3, 23)]
X = np.array([d[0] for d in data]).reshape(-1, 1)
y = np.array([d[1] for d in data])

model = LinearRegression()
model.fit(X, y)

# 다음 시간 예측
next_temp = model.predict([[4]])
print(f"예측 온도: {next_temp[0]:.1f}°C")
```

**응용**:

- 온도 트렌드 예측
- 에너지 사용량 예측
- 이상 탐지

#### 2. 이미지 인식 (ESP32-CAM)

```python
# ESP32-CAM 사용 시
import camera

camera.init()
img = camera.capture()

# 이미지를 AI 서버로 전송
import urequests
response = urequests.post('http://server/classify', data=img)
result = response.json()

print(f"인식 결과: {result['label']}")
```

**응용**:

- 얼굴 인식 출입
- 물체 감지
- QR 코드 스캔

#### 3. 음성 명령 (마이크 추가)

```python
# Python 서버에서 음성 인식
import speech_recognition as sr

r = sr.Recognizer()
with sr.Microphone() as source:
    audio = r.listen(source)
    command = r.recognize_google(audio, language='ko-KR')

    print(f"명령: {command}")
    # AI로 명령 처리
```

**응용**:

- "불 켜줘" 음성 제어
- 스마트 홈 어시스턴트
- 핸즈프리 제어

#### 4. 고급 데이터 분석

```python
import pandas as pd
import matplotlib.pyplot as plt

# CSV 데이터 로드
df = pd.read_csv('sensor_data.csv')

# 일별 평균
daily_avg = df.groupby('date')['temperature'].mean()

# 그래프
plt.plot(daily_avg)
plt.title('일별 평균 온도')
plt.xlabel('날짜')
plt.ylabel('온도 (°C)')
plt.savefig('temperature_trend.png')
```

**응용**:

- 장기 트렌드 분석
- 통계 리포트 생성
- 시각화 대시보드

---

## 🌐 시스템 확장

### 1. 멀티 보드 네트워크

**시나리오**: 집 전체를 모니터링

```
거실 보드: 온습도
침실 보드: 온습도 + 움직임
주방 보드: 가스 + 온도
```

**중앙 서버**:

```python
# 모든 보드 데이터 수집
boards = {
    'living': {'temp': 25, 'humid': 60},
    'bedroom': {'temp': 23, 'humid': 55, 'motion': False},
    'kitchen': {'temp': 27, 'gas': 100}
}

# AI로 통합 분석
def analyze_home():
    avg_temp = sum(b.get('temp', 0) for b in boards.values()) / len(boards)

    if boards['kitchen']['gas'] > 500:
        return "⚠️ 주방 가스 경보!"

    return f"🏠 평균 온도: {avg_temp:.1f}°C"
```

### 2. 클라우드 통합

**AWS IoT Core**:

```python
from AWSIoTPythonSDK.MQTTLib import AWSIoTMQTTClient

client = AWSIoTMQTTClient("hexaboard")
client.configureEndpoint("xxx.iot.us-east-1.amazonaws.com", 8883)
client.configureCredentials("root-CA.crt", "private.pem.key", "certificate.pem.crt")

client.connect()
client.publish("hexaboard/data", payload, 1)
```

**Azure IoT Hub**:

```python
from azure.iot.device import IoTHubDeviceClient

connection_string = "HostName=xxx.azure-devices.net;..."
client = IoTHubDeviceClient.create_from_connection_string(connection_string)

client.send_message({"temperature": 25})
```

**응용**:

- 전 세계 어디서나 접근
- 빅데이터 분석
- 머신러닝 학습

### 3. 데이터베이스 연동

**SQLite (로컬)**:

```python
import sqlite3

conn = sqlite3.connect('sensor_data.db')
cursor = conn.cursor()

cursor.execute('''
CREATE TABLE IF NOT EXISTS sensors (
    timestamp DATETIME,
    temperature REAL,
    humidity REAL
)
''')

cursor.execute('INSERT INTO sensors VALUES (?, ?, ?)',
               (datetime.now(), 25.5, 60.0))
conn.commit()
```

**MongoDB (클라우드)**:

```python
from pymongo import MongoClient

client = MongoClient("mongodb+srv://user:pass@cluster.mongodb.net/")
db = client.hexaboard

db.sensors.insert_one({
    'timestamp': datetime.now(),
    'temperature': 25.5,
    'humidity': 60.0
})
```

---

## 🎓 학습 경로 추천

### 초급 → 중급

**마스터한 것**:

- ✅ MicroPython 기초
- ✅ 센서 제어
- ✅ MQTT 통신

**다음 학습**:

1. **Python 백엔드 심화**

   - Flask/FastAPI
   - 데이터베이스 (SQL)
   - RESTful API

2. **웹 프론트엔드**

   - React/Vue.js
   - 실시간 차트 (Chart.js)
   - 반응형 디자인

3. **네트워크 보안**
   - TLS/SSL 인증서
   - OAuth 인증
   - 데이터 암호화

### 중급 → 고급

**마스터한 것**:

- ✅ AI API 통합
- ✅ 웹 대시보드
- ✅ 데이터 분석

**다음 학습**:

1. **머신러닝**

   - TensorFlow Lite (온디바이스)
   - 시계열 예측 (LSTM)
   - 이상 탐지 (Autoencoder)

2. **엣지 컴퓨팅**

   - Edge AI
   - 로컬 추론
   - 모델 최적화

3. **대규모 IoT**
   - Kubernetes
   - 메시지 큐 (RabbitMQ)
   - 시계열 DB (InfluxDB)

---

## 🚀 프로젝트 아이디어

### 레벨 1: 개인 프로젝트

**1. 나만의 날씨 스테이션**

- 온습도 + 기압 센서
- OLED 디스플레이
- 예보 API 연동

**2. 스마트 화분**

- 토양 습도 센서
- 자동 물주기 (펌프)
- 성장 일지 웹앱

**3. 수면 트래커**

- 움직임 센서 (PIR)
- 온습도 모니터
- 수면 품질 AI 분석

### 레벨 2: 팀 프로젝트

**4. 교실 환경 모니터**

- 여러 교실에 보드 설치
- 중앙 대시보드
- 자동 환기 알림

**5. 스마트 오피스**

- 책상별 온도/조도
- 에너지 절약 시스템
- 재실 감지 자동 조명

**6. IoT 보안 시스템**

- 문 센서 (자석)
- 움직임 감지
- 스마트폰 알림

### 레벨 3: 공모전/경진대회

**7. 스마트 시티 미니어처**

- 신호등 제어 (서보)
- 주차 감지 (초음파)
- 가로등 자동 조절

**8. 재난 감지 네트워크**

- 화재 감지 (온도 + 가스)
- 홍수 감지 (수위 센서)
- 긴급 알림 시스템

**9. 친환경 에너지 모니터**

- 태양광 패널 + 전력 센서
- 발전량 vs 소비량
- 최적화 AI 추천

---

## 📚 학습 자료

### 추천 온라인 코스

**무료**:

- [MicroPython 공식 문서](https://docs.micropython.org/)
- [MQTT.org 튜토리얼](https://mqtt.org/)
- [OpenAI Cookbook](https://github.com/openai/openai-cookbook)

**유료**:

- Udemy: "Complete IoT & Machine Learning"
- Coursera: "Introduction to the Internet of Things"
- edX: "IoT Systems and Industrial Applications"

### 추천 도서

1. **"Internet of Things with Python"** - Gaston C. Hillar
2. **"MicroPython Projects"** - Jacob Beningo
3. **"Practical Machine Learning for IoT"** - Alasdair Allan

### 커뮤니티

- **MicroPython Forum**: forum.micropython.org
- **Reddit**: r/esp32, r/IoT, r/MicroPython
- **Discord**: MicroPython, IoT Developers
- **GitHub**: Awesome MicroPython

---

## 🛠️ 유용한 도구

### 개발 도구

**1. Fritzing** (회로도 작성)

- 회로 설계 및 시각화
- PCB 디자인
- 문서화

**2. Thonny** (MicroPython IDE)

- 초보자 친화적
- 디버거 내장
- 파일 관리

**3. Postman** (API 테스트)

- REST API 테스트
- MQTT 테스트
- 자동화 스크립트

### 모니터링 도구

**4. MQTT Explorer**

- MQTT 메시지 실시간 확인
- Topic 구조 시각화
- 디버깅

**5. Grafana** (데이터 시각화)

- 실시간 대시보드
- 알림 설정
- 다양한 데이터 소스 연동

**6. Node-RED** (플로우 프로그래밍)

- 비주얼 프로그래밍
- IoT 프로토타이핑
- 쉬운 통합

---

## 🏆 공모전 & 경진대회

### 국내 대회

**1. 메이커 페어 서울**

- 창의적 메이킹 프로젝트
- 부스 운영
- 네트워킹

**2. IoT 아이디어 경진대회**

- 혁신적 IoT 솔루션
- 프로토타입 시연
- 상금 + 투자 기회

**3. 공개SW 개발자대회**

- 오픈소스 프로젝트
- 사회 문제 해결
- 정부 지원

### 국제 대회

**4. Hackaday Prize**

- 글로벌 하드웨어 해커톤
- 다양한 주제
- 상금 + 멘토링

**5. Microsoft IoT Challenge**

- Azure 기반 IoT
- 클라우드 통합
- 글로벌 네트워킹

---

## 💡 창업 아이디어

### B2C (소비자)

**1. 스마트 홈 키트**

- 헥사보드 기반 DIY 키트
- 모바일 앱 제공
- 구독 서비스 (센서 추가)

**2. 교육용 제품**

- 학교/학원용 교육 키트
- 온라인 강의 패키지
- 교사 가이드 제공

### B2B (기업)

**3. 환경 모니터링 서비스**

- 사무실/공장 환경 측정
- 클라우드 대시보드
- 컨설팅 서비스

**4. 농업 IoT 솔루션**

- 스마트 팜 센서 네트워크
- AI 기반 재배 조언
- 수확량 예측

---

## 📝 핵심 정리

### 확장의 3단계

1. **하드웨어**: 센서/액츄에이터 추가
2. **소프트웨어**: AI/데이터 분석 고도화
3. **시스템**: 네트워크/클라우드 확장

### 학습 계속하기

- ✅ 공식 문서 읽기
- ✅ 오픈소스 프로젝트 참여
- ✅ 커뮤니티 활동
- ✅ 공모전 도전
- ✅ 포트폴리오 구축

---

## 🎉 마무리

### 여러분은 이제...

**할 수 있는 것**:

- ✅ ESP32로 IoT 장치 만들기
- ✅ 센서 데이터 수집 및 분석
- ✅ MQTT로 통신하기
- ✅ AI로 제어하기
- ✅ 웹 대시보드 구축하기

**앞으로 할 수 있는 것**:

- 🚀 더 복잡한 프로젝트
- 🚀 창의적 아이디어 구현
- 🚀 공모전 수상
- 🚀 포트폴리오 완성
- 🚀 취업/창업

---

## 🌟 당부의 말

> "작은 LED 하나를 켜는 것부터 시작했지만,  
> 이제 여러분은 완전한 AIoT 시스템을 만들 수 있습니다.  
> 계속 도전하고, 실패하고, 배우세요.  
> 가장 중요한 것은 멈추지 않는 것입니다!"

---

**🎉 Chapter 29 완료!**  
**🎉 PART 8 완료!**  
**🎉 "HexaBoard AI Sensor Lab" eBook 전체 완료!**

**감사합니다! 즐거운 메이킹 되세요! 🎊🚀**

---

<div style="page-break-after: always;"></div>

# 🎉 맺음말

## 여러분, 축하합니다!

29개 챕터의 긴 여정을 완주하셨습니다! 처음 LED 하나를 켜는 것부터 시작하여, 이제 여러분은:

### 할 수 있게 된 것

- ✅ ESP32로 IoT 장치 만들기
- ✅ 센서 데이터 수집 및 분석
- ✅ MQTT로 통신하기
- ✅ AI로 제어하기
- ✅ 웹 대시보드 구축하기

### 앞으로 할 수 있는 것

- 🚀 더 복잡한 프로젝트 도전
- 🚀 창의적 아이디어 구현
- 🚀 공모전 참여
- 🚀 포트폴리오 완성
- 🚀 취업/창업 준비

---

## 당부의 말

> "작은 LED 하나를 켜는 것부터 시작했지만,  
> 이제 여러분은 완전한 AIoT 시스템을 만들 수 있습니다.  
> 계속 도전하고, 실패하고, 배우세요.  
> 가장 중요한 것은 멈추지 않는 것입니다!"

---

## 다음 단계

### 계속 학습하기

1. **공식 문서 읽기**: MicroPython, OpenAI, MQTT 공식 문서
2. **오픈소스 참여**: GitHub에서 프로젝트 기여
3. **커뮤니티 활동**: 포럼, Discord에서 질문하고 답변하기
4. **공모전 도전**: Hackaday, 메이커 페어, IoT 경진대회
5. **포트폴리오 구축**: 나만의 프로젝트로 실력 증명

### 추천 프로젝트 아이디어

**개인 프로젝트**:

- 나만의 날씨 스테이션
- 스마트 화분
- 수면 트래커

**팀 프로젝트**:

- 교실 환경 모니터
- 스마트 오피스
- IoT 보안 시스템

**공모전/경진대회**:

- 스마트 시티 미니어처
- 재난 감지 네트워크
- 친환경 에너지 모니터

---

## 감사의 글

이 책이 완성되기까지 많은 분들의 도움이 있었습니다:

- **MicroPython 커뮤니티**: 훌륭한 오픈소스 프레임워크
- **OpenAI**: 혁신적인 AI 기술
- **MQTT 커뮤니티**: 안정적인 IoT 프로토콜
- **모든 독자분들**: 이 책을 선택해주셔서 감사합니다

---

## 계속 연결되어 있기

- **GitHub**: github.com/your-repo/eBook_AIoT
- **이메일**: support@example.com
- **커뮤니티**: Discord (향후 개설)

---

## 마지막 메시지

여러분은 이제 AIoT 시스템을 만들 수 있는 능력을 갖추었습니다.

이 책에서 배운 것은 시작일 뿐입니다.

더 멋진 프로젝트를 만들고, 세상을 바꾸는 혁신을 이루어내세요!

**감사합니다! 즐거운 메이킹 되세요! 🎊🚀**

---

**📘 헥사보드 AI 센서랩**  
**OpenAI와 함께하는 스마트 환경 실험실**

**저자**: MakeItNow Team  
**버전**: v1.0  
**발행일**: 2025년 1월

Copyright © 2025 MakeItNow Team  
All rights reserved.

---
